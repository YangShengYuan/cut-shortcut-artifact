<beaver.Symbol: void <init>()>
<jas.AsciiCP: void <init>(java.lang.String)>
<jas.AsciiCP: void resolve(jas.ClassEnv)>
<jas.AsciiCP: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.CP: java.lang.String getUniq()>
<jas.CP: void <init>()>
<jas.CPOperand: int size(jas.ClassEnv,jas.CodeAttr)>
<jas.CPOperand: void <init>(jas.CP)>
<jas.CPOperand: void resolve(jas.ClassEnv)>
<jas.CPOperand: void write(jas.ClassEnv,jas.CodeAttr,java.io.DataOutputStream)>
<jas.ClassCP: void <init>(java.lang.String)>
<jas.ClassCP: void resolve(jas.ClassEnv)>
<jas.ClassCP: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.ClassEnv: boolean isClassSynth()>
<jas.ClassEnv: int getCPIndex(jas.CP)>
<jas.ClassEnv: void <init>()>
<jas.ClassEnv: void addCPItem(jas.CP)>
<jas.ClassEnv: void addMethod(jas.Method)>
<jas.ClassEnv: void setClass(jas.CP)>
<jas.ClassEnv: void setClassAccess(short)>
<jas.ClassEnv: void setSource(java.lang.String)>
<jas.ClassEnv: void setSuperClass(jas.CP)>
<jas.ClassEnv: void write(java.io.DataOutputStream)>
<jas.CodeAttr: int processSootAttributes()>
<jas.CodeAttr: void <clinit>()>
<jas.CodeAttr: void <init>()>
<jas.CodeAttr: void addInsn(jas.Insn)>
<jas.CodeAttr: void resolve(jas.ClassEnv)>
<jas.CodeAttr: void setLabelTable(java.util.Hashtable)>
<jas.CodeAttr: void setStackSize(short)>
<jas.CodeAttr: void setVarSize(short)>
<jas.CodeAttr: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.FieldCP: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<jas.FieldCP: void resolve(jas.ClassEnv)>
<jas.FieldCP: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.Insn: int size(jas.ClassEnv,jas.CodeAttr)>
<jas.Insn: void <init>()>
<jas.Insn: void <init>(int)>
<jas.Insn: void <init>(int,jas.CP)>
<jas.Insn: void resolve(jas.ClassEnv)>
<jas.Insn: void write(jas.ClassEnv,jas.CodeAttr,java.io.DataOutputStream)>
<jas.InsnOperand: void <init>()>
<jas.InsnOperand: void writePrefix(jas.ClassEnv,jas.CodeAttr,java.io.DataOutputStream)>
<jas.Label: int size(jas.ClassEnv,jas.CodeAttr)>
<jas.Label: void <init>(java.lang.String)>
<jas.Label: void write(jas.ClassEnv,jas.CodeAttr,java.io.DataOutputStream)>
<jas.LdcOperand: int size(jas.ClassEnv,jas.CodeAttr)>
<jas.LdcOperand: void <init>(jas.Insn,jas.CP,boolean)>
<jas.LdcOperand: void resolve(jas.ClassEnv)>
<jas.LdcOperand: void write(jas.ClassEnv,jas.CodeAttr,java.io.DataOutputStream)>
<jas.Method: void <init>(short,jas.CP,jas.CP,jas.CodeAttr,jas.ExceptAttr)>
<jas.Method: void resolve(jas.ClassEnv)>
<jas.Method: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.MethodCP: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<jas.MethodCP: void resolve(jas.ClassEnv)>
<jas.MethodCP: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.NameTypeCP: void <init>(java.lang.String,java.lang.String)>
<jas.NameTypeCP: void resolve(jas.ClassEnv)>
<jas.NameTypeCP: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.RuntimeConstants: void <clinit>()>
<jas.SourceAttr: void <clinit>()>
<jas.SourceAttr: void <init>(java.lang.String)>
<jas.SourceAttr: void resolve(jas.ClassEnv)>
<jas.SourceAttr: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jas.StringCP: void <init>(java.lang.String)>
<jas.StringCP: void resolve(jas.ClassEnv)>
<jas.StringCP: void write(jas.ClassEnv,java.io.DataOutputStream)>
<jasmin.CUP$parser$actions: java_cup.runtime.Symbol CUP$parser$do_action(int,java_cup.runtime.lr_parser,java.util.Stack,int)>
<jasmin.CUP$parser$actions: void <init>(jasmin.parser)>
<jasmin.ClassFile: int errorCount()>
<jasmin.ClassFile: jas.CodeAttr _getCode()>
<jasmin.ClassFile: jas.Label getLabel(java.lang.String)>
<jasmin.ClassFile: void <init>()>
<jasmin.ClassFile: void addClassDeprAttr(java.lang.Object)>
<jasmin.ClassFile: void addClassSigAttr(java.lang.Object)>
<jasmin.ClassFile: void autoNumber()>
<jasmin.ClassFile: void endMethod()>
<jasmin.ClassFile: void newMethod(java.lang.String,java.lang.String,int)>
<jasmin.ClassFile: void plant(java.lang.String)>
<jasmin.ClassFile: void plant(java.lang.String,java.lang.String)>
<jasmin.ClassFile: void plant(java.lang.String,java.lang.String,java.lang.String)>
<jasmin.ClassFile: void plantLabel(java.lang.String)>
<jasmin.ClassFile: void plantString(java.lang.String,java.lang.String)>
<jasmin.ClassFile: void readJasmin(java.io.InputStream,java.lang.String,boolean)>
<jasmin.ClassFile: void setClass(java.lang.String,short)>
<jasmin.ClassFile: void setLine(int)>
<jasmin.ClassFile: void setSource(java.lang.String)>
<jasmin.ClassFile: void setStackSize(short)>
<jasmin.ClassFile: void setSuperClass(java.lang.String)>
<jasmin.ClassFile: void setVarSize(short)>
<jasmin.ClassFile: void write(java.io.OutputStream)>
<jasmin.InsnInfo: boolean contains(java.lang.String)>
<jasmin.InsnInfo: jasmin.InsnInfo get(java.lang.String)>
<jasmin.InsnInfo: void <clinit>()>
<jasmin.InsnInfo: void <init>()>
<jasmin.InsnInfo: void addInfo(java.lang.String,int,java.lang.String)>
<jasmin.Main: void assemble(java.io.InputStream,java.io.OutputStream,boolean)>
<jasmin.ReservedWords: java_cup.runtime.Symbol get(java.lang.String)>
<jasmin.ReservedWords: void <clinit>()>
<jasmin.Scanner: boolean separator(int)>
<jasmin.Scanner: boolean whitespace(int)>
<jasmin.Scanner: java_cup.runtime.Symbol next_token()>
<jasmin.Scanner: void <init>(java.io.InputStream)>
<jasmin.Scanner: void advance()>
<jasmin.ScannerUtils: java.lang.Number convertInt(java.lang.String,int)>
<jasmin.ScannerUtils: java.lang.Number convertNumber(java.lang.String)>
<jasmin.ScannerUtils: java.lang.String convertChars(java.lang.String,java.lang.String,char)>
<jasmin.ScannerUtils: java.lang.String convertDots(java.lang.String)>
<jasmin.ScannerUtils: java.lang.String[] splitClassField(java.lang.String)>
<jasmin.ScannerUtils: java.lang.String[] splitClassMethodSignature(java.lang.String)>
<jasmin.ScannerUtils: java.lang.String[] splitMethodSignature(java.lang.String)>
<jasmin.parser: int start_state()>
<jasmin.parser: java_cup.runtime.Symbol do_action(int,java_cup.runtime.lr_parser,java.util.Stack,int)>
<jasmin.parser: java_cup.runtime.Symbol scan()>
<jasmin.parser: short[][] action_table()>
<jasmin.parser: short[][] production_table()>
<jasmin.parser: short[][] reduce_table()>
<jasmin.parser: void <clinit>()>
<jasmin.parser: void <init>(jasmin.ClassFile,jasmin.Scanner)>
<jasmin.parser: void init_actions()>
<jasmin.parser: void user_init()>
<java.io.BufferedInputStream: byte[] getBufIfOpen()>
<java.io.BufferedInputStream: int read()>
<java.io.BufferedInputStream: java.io.InputStream getInIfOpen()>
<java.io.BufferedInputStream: void <init>(java.io.InputStream)>
<java.io.BufferedInputStream: void <init>(java.io.InputStream,int)>
<java.io.BufferedInputStream: void close()>
<java.io.BufferedInputStream: void fill()>
<java.io.BufferedOutputStream: void flush()>
<java.io.BufferedOutputStream: void flushBuffer()>
<java.io.BufferedOutputStream: void write(byte[],int,int)>
<java.io.BufferedReader: java.lang.String readLine()>
<java.io.BufferedReader: java.lang.String readLine(boolean)>
<java.io.BufferedReader: void <init>(java.io.Reader)>
<java.io.BufferedReader: void <init>(java.io.Reader,int)>
<java.io.BufferedReader: void close()>
<java.io.BufferedReader: void ensureOpen()>
<java.io.BufferedReader: void fill()>
<java.io.BufferedWriter: int min(int,int)>
<java.io.BufferedWriter: void ensureOpen()>
<java.io.BufferedWriter: void flushBuffer()>
<java.io.BufferedWriter: void newLine()>
<java.io.BufferedWriter: void write(java.lang.String,int,int)>
<java.io.ByteArrayInputStream: int available()>
<java.io.ByteArrayInputStream: int read()>
<java.io.ByteArrayInputStream: int read(byte[],int,int)>
<java.io.ByteArrayInputStream: void <init>(byte[])>
<java.io.ByteArrayInputStream: void close()>
<java.io.ByteArrayOutputStream: byte[] toByteArray()>
<java.io.ByteArrayOutputStream: void <init>()>
<java.io.ByteArrayOutputStream: void <init>(int)>
<java.io.ByteArrayOutputStream: void close()>
<java.io.ByteArrayOutputStream: void write(byte[],int,int)>
<java.io.DataInputStream: int read(byte[])>
<java.io.DataInputStream: int readInt()>
<java.io.DataInputStream: int readUnsignedByte()>
<java.io.DataInputStream: int readUnsignedShort()>
<java.io.DataInputStream: java.lang.String readUTF()>
<java.io.DataInputStream: java.lang.String readUTF(java.io.DataInput)>
<java.io.DataInputStream: void <init>(java.io.InputStream)>
<java.io.DataInputStream: void readFully(byte[],int,int)>
<java.io.DataOutputStream: int writeUTF(java.lang.String,java.io.DataOutput)>
<java.io.DataOutputStream: void <init>(java.io.OutputStream)>
<java.io.DataOutputStream: void flush()>
<java.io.DataOutputStream: void incCount(int)>
<java.io.DataOutputStream: void write(byte[],int,int)>
<java.io.DataOutputStream: void writeByte(int)>
<java.io.DataOutputStream: void writeInt(int)>
<java.io.DataOutputStream: void writeShort(int)>
<java.io.DataOutputStream: void writeUTF(java.lang.String)>
<java.io.ExpiringCache$1: boolean removeEldestEntry(java.util.Map$Entry)>
<java.io.ExpiringCache$Entry: java.lang.String val()>
<java.io.ExpiringCache$Entry: long timestamp()>
<java.io.ExpiringCache$Entry: void <init>(long,java.lang.String)>
<java.io.ExpiringCache: int access$000(java.io.ExpiringCache)>
<java.io.ExpiringCache: java.io.ExpiringCache$Entry entryFor(java.lang.String)>
<java.io.ExpiringCache: java.lang.String get(java.lang.String)>
<java.io.ExpiringCache: void put(java.lang.String,java.lang.String)>
<java.io.File: boolean canRead()>
<java.io.File: boolean equals(java.lang.Object)>
<java.io.File: boolean exists()>
<java.io.File: boolean isDirectory()>
<java.io.File: boolean isFile()>
<java.io.File: boolean mkdirs()>
<java.io.File: int compareTo(java.io.File)>
<java.io.File: int getPrefixLength()>
<java.io.File: int hashCode()>
<java.io.File: java.io.File getCanonicalFile()>
<java.io.File: java.io.File getParentFile()>
<java.io.File: java.lang.String getAbsolutePath()>
<java.io.File: java.lang.String getCanonicalPath()>
<java.io.File: java.lang.String getName()>
<java.io.File: java.lang.String getParent()>
<java.io.File: java.lang.String getPath()>
<java.io.File: long lastModified()>
<java.io.File: long length()>
<java.io.File: void <init>(java.io.File,java.lang.String)>
<java.io.File: void <init>(java.lang.String)>
<java.io.File: void <init>(java.lang.String,int)>
<java.io.File: void <init>(java.lang.String,java.lang.String)>
<java.io.FileDescriptor: int decrementAndGetUseCount()>
<java.io.FileDescriptor: int incrementAndGetUseCount()>
<java.io.FileDescriptor: void <init>()>
<java.io.FileInputStream: int read(byte[])>
<java.io.FileInputStream: int read(byte[],int,int)>
<java.io.FileInputStream: void <init>(java.io.File)>
<java.io.FileInputStream: void close()>
<java.io.FileInputStream: void finalize()>
<java.io.FileNotFoundException: void <init>(java.lang.String)>
<java.io.FileOutputStream: void <init>(java.io.File,boolean)>
<java.io.FileOutputStream: void <init>(java.lang.String)>
<java.io.FileOutputStream: void write(byte[],int,int)>
<java.io.FilePermission$1: java.lang.Object run()>
<java.io.FilePermission$1: java.lang.String run()>
<java.io.FilePermission$1: void <init>(java.io.FilePermission)>
<java.io.FilePermission: int getMask(java.lang.String)>
<java.io.FilePermission: java.lang.String access$000(java.io.FilePermission)>
<java.io.FilePermission: java.security.PermissionCollection newPermissionCollection()>
<java.io.FilePermission: void <init>(java.lang.String,java.lang.String)>
<java.io.FilePermission: void init(int)>
<java.io.FilePermissionCollection: void <clinit>()>
<java.io.FilePermissionCollection: void <init>()>
<java.io.FilePermissionCollection: void add(java.security.Permission)>
<java.io.FileReader: void <init>(java.io.File)>
<java.io.FilterInputStream: int available()>
<java.io.FilterInputStream: int read(byte[],int,int)>
<java.io.FilterInputStream: void <init>(java.io.InputStream)>
<java.io.FilterInputStream: void close()>
<java.io.FilterOutputStream: void <init>(java.io.OutputStream)>
<java.io.IOException: void <init>(java.lang.String)>
<java.io.InputStream: int read(byte[])>
<java.io.InputStream: void <init>()>
<java.io.InputStreamReader: int read(char[],int,int)>
<java.io.InputStreamReader: void <init>(java.io.InputStream)>
<java.io.InputStreamReader: void close()>
<java.io.ObjectStreamClass: java.lang.String getClassSignature(java.lang.Class)>
<java.io.ObjectStreamField: void <init>(java.lang.String,java.lang.Class)>
<java.io.ObjectStreamField: void <init>(java.lang.String,java.lang.Class,boolean)>
<java.io.OutputStream: void <init>()>
<java.io.OutputStream: void flush()>
<java.io.OutputStreamWriter: void <init>(java.io.OutputStream)>
<java.io.OutputStreamWriter: void flush()>
<java.io.OutputStreamWriter: void flushBuffer()>
<java.io.OutputStreamWriter: void write(char[],int,int)>
<java.io.OutputStreamWriter: void write(java.lang.String,int,int)>
<java.io.PrintStream: void ensureOpen()>
<java.io.PrintStream: void newLine()>
<java.io.PrintStream: void print(java.lang.String)>
<java.io.PrintStream: void println(java.lang.String)>
<java.io.PrintStream: void write(byte[],int,int)>
<java.io.PrintStream: void write(java.lang.String)>
<java.io.PrintWriter: void <init>(java.io.Writer)>
<java.io.PrintWriter: void <init>(java.io.Writer,boolean)>
<java.io.PrintWriter: void ensureOpen()>
<java.io.PrintWriter: void flush()>
<java.io.PrintWriter: void newLine()>
<java.io.PrintWriter: void print(java.lang.String)>
<java.io.PrintWriter: void println()>
<java.io.PrintWriter: void println(java.lang.String)>
<java.io.PrintWriter: void write(java.lang.String)>
<java.io.PrintWriter: void write(java.lang.String,int,int)>
<java.io.Reader: void <init>(java.lang.Object)>
<java.io.UnixFileSystem: boolean isAbsolute(java.io.File)>
<java.io.UnixFileSystem: int compare(java.io.File,java.io.File)>
<java.io.UnixFileSystem: int getBooleanAttributes(java.io.File)>
<java.io.UnixFileSystem: int hashCode(java.io.File)>
<java.io.UnixFileSystem: int prefixLength(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String canonicalize(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String normalize(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String normalize(java.lang.String,int,int)>
<java.io.UnixFileSystem: java.lang.String parentOrNull(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String resolve(java.io.File)>
<java.io.UnixFileSystem: java.lang.String resolve(java.lang.String,java.lang.String)>
<java.io.Writer: void <init>(java.lang.Object)>
<java.io.Writer: void write(java.lang.String)>
<java.lang.AbstractStringBuilder: int stringSizeOfInt(int)>
<java.lang.AbstractStringBuilder: int stringSizeOfLong(long)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(char)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(int)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(java.lang.String)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(long)>
<java.lang.AbstractStringBuilder: void <init>(int)>
<java.lang.AbstractStringBuilder: void expandCapacity(int)>
<java.lang.AbstractStringBuilder: void setLength(int)>
<java.lang.ApplicationShutdownHooks$1: void run()>
<java.lang.ApplicationShutdownHooks: void runHooks()>
<java.lang.Character: boolean isHighSurrogate(char)>
<java.lang.Character: boolean isLetter(char)>
<java.lang.Character: boolean isLetter(int)>
<java.lang.Character: boolean isLetterOrDigit(char)>
<java.lang.Character: boolean isLetterOrDigit(int)>
<java.lang.Character: char toLowerCase(char)>
<java.lang.Character: char toUpperCase(char)>
<java.lang.Character: int charCount(int)>
<java.lang.Character: int codePointAtImpl(char[],int,int)>
<java.lang.Character: int digit(char,int)>
<java.lang.Character: int digit(int,int)>
<java.lang.Character: int toLowerCase(int)>
<java.lang.Character: int toUpperCase(int)>
<java.lang.Character: int toUpperCaseEx(int)>
<java.lang.CharacterDataLatin1: boolean isLetter(int)>
<java.lang.CharacterDataLatin1: boolean isLetterOrDigit(int)>
<java.lang.CharacterDataLatin1: int digit(int,int)>
<java.lang.CharacterDataLatin1: int getProperties(int)>
<java.lang.CharacterDataLatin1: int getType(int)>
<java.lang.CharacterDataLatin1: int toLowerCase(int)>
<java.lang.CharacterDataLatin1: int toUpperCase(int)>
<java.lang.CharacterDataLatin1: int toUpperCaseEx(int)>
<java.lang.Class$1: java.lang.Object run()>
<java.lang.Class$1: void <init>(java.lang.Class,java.lang.reflect.Constructor)>
<java.lang.Class: boolean arrayContentsEq(java.lang.Object[],java.lang.Object[])>
<java.lang.Class: boolean desiredAssertionStatus()>
<java.lang.Class: java.io.InputStream getResourceAsStream(java.lang.String)>
<java.lang.Class: java.lang.Class forName(java.lang.String)>
<java.lang.Class: java.lang.ClassLoader getClassLoader()>
<java.lang.Class: java.lang.Object newInstance()>
<java.lang.Class: java.lang.Object newInstance0()>
<java.lang.Class: java.lang.String getName()>
<java.lang.Class: java.lang.String resolveName(java.lang.String)>
<java.lang.Class: java.lang.reflect.Constructor getConstructor0(java.lang.Class[],int)>
<java.lang.Class: java.lang.reflect.Constructor[] privateGetDeclaredConstructors(boolean)>
<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>
<java.lang.Class: java.lang.reflect.Field searchFields(java.lang.reflect.Field[],java.lang.String)>
<java.lang.Class: java.lang.reflect.Field[] privateGetDeclaredFields(boolean)>
<java.lang.Class: sun.reflect.ReflectionFactory getReflectionFactory()>
<java.lang.Class: void checkInitted()>
<java.lang.Class: void checkMemberAccess(int,java.lang.ClassLoader,boolean)>
<java.lang.Class: void clearCachesOnClassRedefinition()>
<java.lang.ClassLoader$2: boolean hasMoreElements()>
<java.lang.ClassLoader$2: void <init>(java.util.Enumeration)>
<java.lang.ClassLoader: boolean checkName(java.lang.String)>
<java.lang.ClassLoader: boolean compareCerts(java.security.cert.Certificate[],java.security.cert.Certificate[])>
<java.lang.ClassLoader: java.io.InputStream getResourceAsStream(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)>
<java.lang.ClassLoader: java.lang.Class defineClassCond(java.lang.String,byte[],int,int,java.security.ProtectionDomain,boolean)>
<java.lang.ClassLoader: java.lang.Class findBootstrapClassOrNull(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class findLoadedClass(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class loadClass(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class loadClass(java.lang.String,boolean)>
<java.lang.ClassLoader: java.lang.ClassLoader getCallerClassLoader()>
<java.lang.ClassLoader: java.lang.ClassLoader getParent()>
<java.lang.ClassLoader: java.lang.ClassLoader getSystemClassLoader()>
<java.lang.ClassLoader: java.lang.Package definePackage(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL)>
<java.lang.ClassLoader: java.lang.Package getPackage(java.lang.String)>
<java.lang.ClassLoader: java.lang.String defineClassSourceLocation(java.security.ProtectionDomain)>
<java.lang.ClassLoader: java.lang.Void checkCreateClassLoader()>
<java.lang.ClassLoader: java.net.URL getBootstrapResource(java.lang.String)>
<java.lang.ClassLoader: java.net.URL getResource(java.lang.String)>
<java.lang.ClassLoader: java.security.ProtectionDomain preDefineClass(java.lang.String,java.security.ProtectionDomain)>
<java.lang.ClassLoader: java.util.Enumeration getBootstrapResources(java.lang.String)>
<java.lang.ClassLoader: java.util.Enumeration getResources(java.lang.String)>
<java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)>
<java.lang.ClassLoader: sun.misc.URLClassPath getBootstrapClassPath()>
<java.lang.ClassLoader: void <init>()>
<java.lang.ClassLoader: void <init>(java.lang.Void,java.lang.ClassLoader)>
<java.lang.ClassLoader: void addClass(java.lang.Class)>
<java.lang.ClassLoader: void checkCerts(java.lang.String,java.security.CodeSource)>
<java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)>
<java.lang.ClassLoader: void initSystemClassLoader()>
<java.lang.ClassLoader: void postDefineClass(java.lang.Class,java.security.ProtectionDomain)>
<java.lang.ClassNotFoundException: void <init>(java.lang.String)>
<java.lang.Double: double doubleValue()>
<java.lang.Double: java.lang.Double valueOf(double)>
<java.lang.Double: void <init>(double)>
<java.lang.Exception: void <init>()>
<java.lang.Exception: void <init>(java.lang.String)>
<java.lang.Exception: void <init>(java.lang.String,java.lang.Throwable)>
<java.lang.Exception: void <init>(java.lang.Throwable)>
<java.lang.Float: boolean isNaN(float)>
<java.lang.Float: float floatValue()>
<java.lang.Float: java.lang.Float valueOf(float)>
<java.lang.Float: void <init>(float)>
<java.lang.Integer: boolean equals(java.lang.Object)>
<java.lang.Integer: int hashCode()>
<java.lang.Integer: int intValue()>
<java.lang.Integer: int parseInt(java.lang.String,int)>
<java.lang.Integer: int stringSize(int)>
<java.lang.Integer: java.lang.Integer valueOf(int)>
<java.lang.Integer: java.lang.String toString()>
<java.lang.Integer: java.lang.String toString(int)>
<java.lang.Integer: java.lang.String toString(int,int)>
<java.lang.Integer: void <init>(int)>
<java.lang.Integer: void <init>(java.lang.String)>
<java.lang.Integer: void getChars(int,int,char[])>
<java.lang.Long: java.lang.Long valueOf(long)>
<java.lang.Long: long longValue()>
<java.lang.Long: long parseLong(java.lang.String,int)>
<java.lang.Long: void <init>(long)>
<java.lang.Long: void getChars(long,int,char[])>
<java.lang.Math: int max(int,int)>
<java.lang.Math: int min(int,int)>
<java.lang.Number: void <init>()>
<java.lang.Package: boolean isSealed()>
<java.lang.Package: java.lang.Package getSystemPackage(java.lang.String)>
<java.lang.Package: void <clinit>()>
<java.lang.Package: void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL,java.lang.ClassLoader)>
<java.lang.RuntimeException: void <init>()>
<java.lang.RuntimePermission: void <init>(java.lang.String)>
<java.lang.Short: int intValue()>
<java.lang.Short: void <clinit>()>
<java.lang.Short: void <init>(short)>
<java.lang.Shutdown: void runHooks()>
<java.lang.Shutdown: void sequence()>
<java.lang.Shutdown: void shutdown()>
<java.lang.System: java.lang.SecurityManager getSecurityManager()>
<java.lang.System: java.lang.String getProperty(java.lang.String)>
<java.lang.System: java.lang.String getProperty(java.lang.String,java.lang.String)>
<java.lang.System: java.lang.String setProperty(java.lang.String,java.lang.String)>
<java.lang.System: void checkKey(java.lang.String)>
<java.lang.Throwable: void <init>()>
<java.lang.Throwable: void <init>(java.lang.String)>
<java.lang.Throwable: void <init>(java.lang.String,java.lang.Throwable)>
<java.lang.Throwable: void <init>(java.lang.Throwable)>
<java.lang.ref.FinalReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.ref.Finalizer: boolean hasBeenFinalized()>
<java.lang.ref.Finalizer: java.lang.ref.ReferenceQueue access$000()>
<java.lang.ref.Finalizer: void <init>(java.lang.Object)>
<java.lang.ref.Finalizer: void access$100(java.lang.ref.Finalizer)>
<java.lang.ref.Finalizer: void add()>
<java.lang.ref.Finalizer: void register(java.lang.Object)>
<java.lang.ref.Finalizer: void remove()>
<java.lang.ref.Finalizer: void runFinalizer()>
<java.lang.ref.Reference: java.lang.Object get()>
<java.lang.ref.Reference: java.lang.ref.Reference access$200()>
<java.lang.ref.Reference: java.lang.ref.Reference access$202(java.lang.ref.Reference)>
<java.lang.ref.Reference: java.lang.ref.Reference$Lock access$100()>
<java.lang.ref.Reference: void <init>(java.lang.Object)>
<java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.ref.Reference: void clear()>
<java.lang.ref.ReferenceQueue$Lock: void <init>()>
<java.lang.ref.ReferenceQueue$Lock: void <init>(java.lang.ref.ReferenceQueue$1)>
<java.lang.ref.ReferenceQueue: boolean enqueue(java.lang.ref.Reference)>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference poll()>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference reallyPoll()>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference remove()>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference remove(long)>
<java.lang.ref.ReferenceQueue: void <init>()>
<java.lang.ref.SoftReference: java.lang.Object get()>
<java.lang.ref.SoftReference: void <init>(java.lang.Object)>
<java.lang.ref.SoftReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.ref.WeakReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.reflect.AccessibleObject: void <init>()>
<java.lang.reflect.AccessibleObject: void setAccessible(boolean)>
<java.lang.reflect.AccessibleObject: void setAccessible0(java.lang.reflect.AccessibleObject,boolean)>
<java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)>
<java.lang.reflect.Constructor: int getModifiers()>
<java.lang.reflect.Constructor: java.lang.Class getDeclaringClass()>
<java.lang.reflect.Constructor: java.lang.Class[] getParameterTypes()>
<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>
<java.lang.reflect.Constructor: java.lang.reflect.Constructor copy()>
<java.lang.reflect.Constructor: sun.reflect.ConstructorAccessor getConstructorAccessor()>
<java.lang.reflect.Constructor: void <init>(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])>
<java.lang.reflect.Constructor: void acquireConstructorAccessor()>
<java.lang.reflect.Constructor: void setConstructorAccessor(sun.reflect.ConstructorAccessor)>
<java.lang.reflect.Field: java.lang.String getName()>
<java.lang.reflect.Field: java.lang.reflect.Field copy()>
<java.lang.reflect.Field: void <init>(java.lang.Class,java.lang.String,java.lang.Class,int,int,java.lang.String,byte[])>
<java.lang.reflect.Method: int getModifiers()>
<java.lang.reflect.Modifier: boolean isAbstract(int)>
<java.lang.reflect.Modifier: boolean isPublic(int)>
<java.lang.reflect.ReflectAccess: java.lang.reflect.Constructor copyConstructor(java.lang.reflect.Constructor)>
<java.lang.reflect.ReflectAccess: java.lang.reflect.Field copyField(java.lang.reflect.Field)>
<java.net.ContentHandler: void <init>()>
<java.net.JarURLConnection: java.lang.String getEntryName()>
<java.net.JarURLConnection: java.net.URL getJarFileURL()>
<java.net.JarURLConnection: void <init>(java.net.URL)>
<java.net.JarURLConnection: void parseSpecs(java.net.URL)>
<java.net.Parts: java.lang.String getPath()>
<java.net.Parts: java.lang.String getQuery()>
<java.net.Parts: java.lang.String getRef()>
<java.net.Parts: void <init>(java.lang.String)>
<java.net.URL: boolean equals(java.lang.Object)>
<java.net.URL: boolean isValidProtocol(java.lang.String)>
<java.net.URL: int getDefaultPort()>
<java.net.URL: int getPort()>
<java.net.URL: int hashCode()>
<java.net.URL: java.io.InputStream openStream()>
<java.net.URL: java.lang.String getAuthority()>
<java.net.URL: java.lang.String getFile()>
<java.net.URL: java.lang.String getHost()>
<java.net.URL: java.lang.String getPath()>
<java.net.URL: java.lang.String getProtocol()>
<java.net.URL: java.lang.String getQuery()>
<java.net.URL: java.lang.String getRef()>
<java.net.URL: java.lang.String getUserInfo()>
<java.net.URL: java.lang.String toExternalForm()>
<java.net.URL: java.lang.String toString()>
<java.net.URL: java.net.URLConnection openConnection()>
<java.net.URL: java.net.URLStreamHandler getURLStreamHandler(java.lang.String)>
<java.net.URL: void <init>(java.lang.String)>
<java.net.URL: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>
<java.net.URL: void <init>(java.lang.String,java.lang.String,int,java.lang.String,java.net.URLStreamHandler)>
<java.net.URL: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<java.net.URL: void <init>(java.net.URL,java.lang.String)>
<java.net.URL: void <init>(java.net.URL,java.lang.String,java.net.URLStreamHandler)>
<java.net.URL: void set(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<java.net.URLClassLoader$1: java.lang.Object run()>
<java.net.URLClassLoader$1: void <init>(java.net.URLClassLoader,java.lang.String)>
<java.net.URLClassLoader$2: java.lang.Object run()>
<java.net.URLClassLoader$2: void <init>(java.net.URLClassLoader,java.lang.String)>
<java.net.URLClassLoader$3$1: java.lang.Object run()>
<java.net.URLClassLoader$3$1: void <init>(java.net.URLClassLoader$3)>
<java.net.URLClassLoader$3: boolean hasMoreElements()>
<java.net.URLClassLoader$3: boolean next()>
<java.net.URLClassLoader$3: void <init>(java.net.URLClassLoader,java.util.Enumeration)>
<java.net.URLClassLoader: boolean isSealed(java.lang.String,java.util.jar.Manifest)>
<java.net.URLClassLoader: java.lang.Class access$000(java.net.URLClassLoader,java.lang.String,sun.misc.Resource,boolean)>
<java.net.URLClassLoader: java.lang.Class defineClass(java.lang.String,sun.misc.Resource,boolean)>
<java.net.URLClassLoader: java.lang.Class findClass(java.lang.String)>
<java.net.URLClassLoader: java.lang.Package definePackage(java.lang.String,java.util.jar.Manifest,java.net.URL)>
<java.net.URLClassLoader: java.net.URL findResource(java.lang.String)>
<java.net.URLClassLoader: java.security.AccessControlContext access$100(java.net.URLClassLoader)>
<java.net.URLClassLoader: java.security.PermissionCollection getPermissions(java.security.CodeSource)>
<java.net.URLClassLoader: java.util.Enumeration findResources(java.lang.String)>
<java.net.URLConnection: boolean getUseCaches()>
<java.net.URLConnection: void <clinit>()>
<java.net.URLConnection: void <init>(java.net.URL)>
<java.net.URLStreamHandler: boolean equals(java.net.URL,java.net.URL)>
<java.net.URLStreamHandler: boolean hostsEqual(java.net.URL,java.net.URL)>
<java.net.URLStreamHandler: boolean sameFile(java.net.URL,java.net.URL)>
<java.net.URLStreamHandler: int getDefaultPort()>
<java.net.URLStreamHandler: int hashCode(java.net.URL)>
<java.net.URLStreamHandler: java.lang.String toExternalForm(java.net.URL)>
<java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
<java.net.URLStreamHandler: void <init>()>
<java.net.URLStreamHandler: void parseURL(java.net.URL,java.lang.String,int,int)>
<java.net.URLStreamHandler: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String)>
<java.net.URLStreamHandler: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<java.net.UnknownContentHandler: void <init>()>
<java.nio.Bits: java.nio.ByteOrder byteOrder()>
<java.nio.Buffer: boolean hasRemaining()>
<java.nio.Buffer: int capacity()>
<java.nio.Buffer: int limit()>
<java.nio.Buffer: int position()>
<java.nio.Buffer: int remaining()>
<java.nio.Buffer: java.nio.Buffer clear()>
<java.nio.Buffer: java.nio.Buffer flip()>
<java.nio.Buffer: java.nio.Buffer limit(int)>
<java.nio.Buffer: java.nio.Buffer position(int)>
<java.nio.Buffer: void <init>(int,int,int,int)>
<java.nio.ByteBuffer: boolean hasArray()>
<java.nio.ByteBuffer: byte[] array()>
<java.nio.ByteBuffer: int arrayOffset()>
<java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>
<java.nio.ByteBuffer: java.nio.ByteBuffer wrap(byte[])>
<java.nio.ByteBuffer: java.nio.ByteBuffer wrap(byte[],int,int)>
<java.nio.ByteBuffer: void <init>(int,int,int,int,byte[],int)>
<java.nio.CharBuffer: boolean hasArray()>
<java.nio.CharBuffer: char[] array()>
<java.nio.CharBuffer: int arrayOffset()>
<java.nio.CharBuffer: java.nio.CharBuffer wrap(char[])>
<java.nio.CharBuffer: java.nio.CharBuffer wrap(char[],int,int)>
<java.nio.CharBuffer: void <init>(int,int,int,int,char[],int)>
<java.nio.HeapByteBuffer: int ix(int)>
<java.nio.HeapByteBuffer: java.nio.ByteBuffer compact()>
<java.nio.HeapByteBuffer: void <init>(byte[],int,int)>
<java.nio.HeapByteBuffer: void <init>(int,int)>
<java.nio.HeapCharBuffer: void <init>(char[],int,int)>
<java.nio.charset.Charset: boolean atBugLevel(java.lang.String)>
<java.nio.charset.Charset: boolean isSupported(java.lang.String)>
<java.nio.charset.Charset: java.lang.String name()>
<java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>
<java.nio.charset.Charset: java.nio.charset.Charset forName(java.lang.String)>
<java.nio.charset.Charset: java.nio.charset.Charset lookup(java.lang.String)>
<java.nio.charset.CharsetDecoder: float maxCharsPerByte()>
<java.nio.charset.CharsetDecoder: java.nio.charset.Charset charset()>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder onMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder onUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder replaceWith(java.lang.String)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder reset()>
<java.nio.charset.CharsetDecoder: java.nio.charset.CoderResult decode(java.nio.ByteBuffer,java.nio.CharBuffer,boolean)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CoderResult flush(java.nio.CharBuffer)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CoderResult implFlush(java.nio.CharBuffer)>
<java.nio.charset.CharsetDecoder: void <init>(java.nio.charset.Charset,float,float)>
<java.nio.charset.CharsetDecoder: void <init>(java.nio.charset.Charset,float,float,java.lang.String)>
<java.nio.charset.CharsetDecoder: void implOnMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: void implReplaceWith(java.lang.String)>
<java.nio.charset.CharsetDecoder: void implReset()>
<java.nio.charset.CharsetEncoder: float maxBytesPerChar()>
<java.nio.charset.CharsetEncoder: java.nio.charset.Charset charset()>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder onMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder onUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder replaceWith(byte[])>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder reset()>
<java.nio.charset.CharsetEncoder: java.nio.charset.CoderResult encode(java.nio.CharBuffer,java.nio.ByteBuffer,boolean)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CoderResult flush(java.nio.ByteBuffer)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CoderResult implFlush(java.nio.ByteBuffer)>
<java.nio.charset.CharsetEncoder: void <init>(java.nio.charset.Charset,float,float)>
<java.nio.charset.CharsetEncoder: void <init>(java.nio.charset.Charset,float,float,byte[])>
<java.nio.charset.CharsetEncoder: void implOnMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: void implReplaceWith(byte[])>
<java.nio.charset.CharsetEncoder: void implReset()>
<java.nio.charset.CoderResult: boolean isOverflow()>
<java.nio.charset.CoderResult: boolean isUnderflow()>
<java.security.AccessControlContext: java.security.AccessControlContext optimize()>
<java.security.AccessController: java.security.AccessControlContext getContext()>
<java.security.BasicPermission: java.lang.String getCanonicalName()>
<java.security.BasicPermission: java.security.PermissionCollection newPermissionCollection()>
<java.security.BasicPermission: void <init>(java.lang.String)>
<java.security.BasicPermission: void init(java.lang.String)>
<java.security.BasicPermissionCollection: void <clinit>()>
<java.security.BasicPermissionCollection: void <init>()>
<java.security.BasicPermissionCollection: void add(java.security.Permission)>
<java.security.CodeSource: boolean equals(java.lang.Object)>
<java.security.CodeSource: boolean matchCerts(java.security.CodeSource,boolean)>
<java.security.CodeSource: int hashCode()>
<java.security.CodeSource: java.net.URL getLocation()>
<java.security.CodeSource: java.security.cert.Certificate[] getCertificates()>
<java.security.CodeSource: void <init>(java.net.URL,java.security.CodeSigner[])>
<java.security.Permission: java.lang.String getName()>
<java.security.Permission: void <init>(java.lang.String)>
<java.security.PermissionCollection: boolean isReadOnly()>
<java.security.PermissionCollection: void <init>()>
<java.security.PermissionCollection: void setReadOnly()>
<java.security.Permissions: java.security.PermissionCollection getPermissionCollection(java.security.Permission,boolean)>
<java.security.Permissions: void <clinit>()>
<java.security.Permissions: void <init>()>
<java.security.Permissions: void add(java.security.Permission)>
<java.security.Policy$PolicyInfo: void <init>(java.security.Policy,boolean)>
<java.security.Policy$UnsupportedEmptyCollection: void <init>()>
<java.security.Policy: void <clinit>()>
<java.security.PrivilegedActionException: java.lang.Exception getException()>
<java.security.PrivilegedActionException: void <init>(java.lang.Exception)>
<java.security.ProtectionDomain$2: void <init>()>
<java.security.ProtectionDomain$Key: void <init>(java.security.ProtectionDomain)>
<java.security.ProtectionDomain: java.security.CodeSource getCodeSource()>
<java.security.ProtectionDomain: void <clinit>()>
<java.security.ProtectionDomain: void <init>(java.security.CodeSource,java.security.PermissionCollection,java.lang.ClassLoader,java.security.Principal[])>
<java.security.SecureClassLoader: java.lang.Class defineClass(java.lang.String,byte[],int,int,java.security.CodeSource)>
<java.security.SecureClassLoader: java.security.PermissionCollection getPermissions(java.security.CodeSource)>
<java.security.SecureClassLoader: java.security.ProtectionDomain getProtectionDomain(java.security.CodeSource)>
<java.security.SecureClassLoader: void check()>
<java.util.AbstractCollection: boolean addAll(java.util.Collection)>
<java.util.AbstractCollection: boolean containsAll(java.util.Collection)>
<java.util.AbstractCollection: boolean isEmpty()>
<java.util.AbstractCollection: boolean retainAll(java.util.Collection)>
<java.util.AbstractCollection: java.lang.Object[] toArray()>
<java.util.AbstractCollection: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.AbstractCollection: void <init>()>
<java.util.AbstractList$Itr: boolean hasNext()>
<java.util.AbstractList$Itr: java.lang.Object next()>
<java.util.AbstractList$Itr: void <init>(java.util.AbstractList)>
<java.util.AbstractList$Itr: void <init>(java.util.AbstractList,java.util.AbstractList$1)>
<java.util.AbstractList$Itr: void checkForComodification()>
<java.util.AbstractList$Itr: void remove()>
<java.util.AbstractList$ListItr: int nextIndex()>
<java.util.AbstractList$ListItr: void <init>(java.util.AbstractList,int)>
<java.util.AbstractList: boolean equals(java.lang.Object)>
<java.util.AbstractList: int hashCode()>
<java.util.AbstractList: java.util.Iterator iterator()>
<java.util.AbstractList: java.util.List subList(int,int)>
<java.util.AbstractList: java.util.ListIterator listIterator()>
<java.util.AbstractList: java.util.ListIterator listIterator(int)>
<java.util.AbstractList: void <init>()>
<java.util.AbstractMap: boolean isEmpty()>
<java.util.AbstractMap: void <init>()>
<java.util.AbstractSequentialList: java.util.Iterator iterator()>
<java.util.AbstractSequentialList: void <init>()>
<java.util.AbstractSet: boolean equals(java.lang.Object)>
<java.util.AbstractSet: boolean removeAll(java.util.Collection)>
<java.util.AbstractSet: void <init>()>
<java.util.ArrayList: boolean add(java.lang.Object)>
<java.util.ArrayList: boolean addAll(java.util.Collection)>
<java.util.ArrayList: boolean contains(java.lang.Object)>
<java.util.ArrayList: boolean isEmpty()>
<java.util.ArrayList: boolean remove(java.lang.Object)>
<java.util.ArrayList: int indexOf(java.lang.Object)>
<java.util.ArrayList: int size()>
<java.util.ArrayList: java.lang.Object get(int)>
<java.util.ArrayList: java.lang.Object remove(int)>
<java.util.ArrayList: java.lang.Object set(int,java.lang.Object)>
<java.util.ArrayList: java.lang.Object[] toArray()>
<java.util.ArrayList: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.ArrayList: void <init>()>
<java.util.ArrayList: void <init>(int)>
<java.util.ArrayList: void <init>(java.util.Collection)>
<java.util.ArrayList: void RangeCheck(int)>
<java.util.ArrayList: void clear()>
<java.util.ArrayList: void ensureCapacity(int)>
<java.util.ArrayList: void fastRemove(int)>
<java.util.Arrays$ArrayList: int size()>
<java.util.Arrays$ArrayList: java.lang.Object get(int)>
<java.util.Arrays$ArrayList: void <init>(java.lang.Object[])>
<java.util.Arrays: byte[] copyOf(byte[],int)>
<java.util.Arrays: char[] copyOf(char[],int)>
<java.util.Arrays: char[] copyOfRange(char[],int,int)>
<java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int)>
<java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int,java.lang.Class)>
<java.util.Arrays: java.util.List asList(java.lang.Object[])>
<java.util.BitSet: boolean get(int)>
<java.util.BitSet: int wordIndex(int)>
<java.util.BitSet: void checkInvariants()>
<java.util.Collections$EmptyList: int size()>
<java.util.Collections$EmptyMap: java.lang.Object get(java.lang.Object)>
<java.util.Collections$EmptySet$1: boolean hasNext()>
<java.util.Collections$EmptySet$1: void <init>(java.util.Collections$EmptySet)>
<java.util.Collections$EmptySet: boolean contains(java.lang.Object)>
<java.util.Collections$EmptySet: int size()>
<java.util.Collections$EmptySet: java.util.Iterator iterator()>
<java.util.Collections$SynchronizedMap: java.lang.Object get(java.lang.Object)>
<java.util.Collections$UnmodifiableCollection$1: boolean hasNext()>
<java.util.Collections$UnmodifiableCollection$1: java.lang.Object next()>
<java.util.Collections$UnmodifiableCollection$1: void <init>(java.util.Collections$UnmodifiableCollection)>
<java.util.Collections$UnmodifiableCollection: boolean contains(java.lang.Object)>
<java.util.Collections$UnmodifiableCollection: boolean isEmpty()>
<java.util.Collections$UnmodifiableCollection: int size()>
<java.util.Collections$UnmodifiableCollection: java.lang.Object[] toArray()>
<java.util.Collections$UnmodifiableCollection: java.util.Iterator iterator()>
<java.util.Collections$UnmodifiableCollection: void <init>(java.util.Collection)>
<java.util.Collections$UnmodifiableList: java.lang.Object get(int)>
<java.util.Collections$UnmodifiableList: void <init>(java.util.List)>
<java.util.Collections$UnmodifiableMap: boolean containsKey(java.lang.Object)>
<java.util.Collections$UnmodifiableMap: java.lang.Object get(java.lang.Object)>
<java.util.Collections$UnmodifiableMap: void <init>(java.util.Map)>
<java.util.Collections$UnmodifiableRandomAccessList: void <init>(java.util.List)>
<java.util.Collections$UnmodifiableSet: boolean equals(java.lang.Object)>
<java.util.Collections$UnmodifiableSet: void <init>(java.util.Set)>
<java.util.Collections: java.util.List emptyList()>
<java.util.Collections: java.util.List unmodifiableList(java.util.List)>
<java.util.Collections: java.util.Map emptyMap()>
<java.util.Collections: java.util.Map unmodifiableMap(java.util.Map)>
<java.util.Collections: java.util.Set emptySet()>
<java.util.Collections: java.util.Set unmodifiableSet(java.util.Set)>
<java.util.Date: java.lang.String toString()>
<java.util.Date: java.lang.StringBuilder convertToAbbr(java.lang.StringBuilder,java.lang.String)>
<java.util.Date: long getTime()>
<java.util.Date: long getTimeImpl()>
<java.util.Date: sun.util.calendar.BaseCalendar getCalendarSystem(long)>
<java.util.Date: sun.util.calendar.BaseCalendar$Date normalize()>
<java.util.Date: void <clinit>()>
<java.util.Date: void <init>()>
<java.util.Date: void <init>(long)>
<java.util.Dictionary: void <init>()>
<java.util.HashMap$Entry: java.lang.Object getKey()>
<java.util.HashMap$Entry: java.lang.Object getValue()>
<java.util.HashMap$Entry: java.lang.Object setValue(java.lang.Object)>
<java.util.HashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.HashMap$Entry)>
<java.util.HashMap$Entry: void recordAccess(java.util.HashMap)>
<java.util.HashMap$Entry: void recordRemoval(java.util.HashMap)>
<java.util.HashMap$EntryIterator: java.lang.Object next()>
<java.util.HashMap$EntryIterator: java.util.Map$Entry next()>
<java.util.HashMap$EntryIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$EntryIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$EntrySet: java.util.Iterator iterator()>
<java.util.HashMap$EntrySet: void <init>(java.util.HashMap)>
<java.util.HashMap$EntrySet: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$HashIterator: boolean hasNext()>
<java.util.HashMap$HashIterator: java.util.HashMap$Entry nextEntry()>
<java.util.HashMap$HashIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$HashIterator: void remove()>
<java.util.HashMap$KeyIterator: java.lang.Object next()>
<java.util.HashMap$KeyIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$KeyIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$KeySet: int size()>
<java.util.HashMap$KeySet: java.util.Iterator iterator()>
<java.util.HashMap$KeySet: void <init>(java.util.HashMap)>
<java.util.HashMap$KeySet: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$ValueIterator: java.lang.Object next()>
<java.util.HashMap$ValueIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$ValueIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$Values: java.util.Iterator iterator()>
<java.util.HashMap$Values: void <init>(java.util.HashMap)>
<java.util.HashMap$Values: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap: boolean containsKey(java.lang.Object)>
<java.util.HashMap: boolean isEmpty()>
<java.util.HashMap: int hash(int)>
<java.util.HashMap: int indexFor(int,int)>
<java.util.HashMap: int size()>
<java.util.HashMap: java.lang.Object get(java.lang.Object)>
<java.util.HashMap: java.lang.Object getForNullKey()>
<java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.HashMap: java.lang.Object putForNullKey(java.lang.Object)>
<java.util.HashMap: java.lang.Object remove(java.lang.Object)>
<java.util.HashMap: java.util.Collection values()>
<java.util.HashMap: java.util.HashMap$Entry getEntry(java.lang.Object)>
<java.util.HashMap: java.util.HashMap$Entry removeEntryForKey(java.lang.Object)>
<java.util.HashMap: java.util.Iterator newEntryIterator()>
<java.util.HashMap: java.util.Iterator newKeyIterator()>
<java.util.HashMap: java.util.Iterator newValueIterator()>
<java.util.HashMap: java.util.Set entrySet()>
<java.util.HashMap: java.util.Set entrySet0()>
<java.util.HashMap: java.util.Set keySet()>
<java.util.HashMap: void <init>()>
<java.util.HashMap: void <init>(int)>
<java.util.HashMap: void <init>(int,float)>
<java.util.HashMap: void <init>(java.util.Map)>
<java.util.HashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.HashMap: void clear()>
<java.util.HashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.HashMap: void init()>
<java.util.HashMap: void putAll(java.util.Map)>
<java.util.HashMap: void putAllForCreate(java.util.Map)>
<java.util.HashMap: void putForCreate(java.lang.Object,java.lang.Object)>
<java.util.HashMap: void resize(int)>
<java.util.HashMap: void transfer(java.util.HashMap$Entry[])>
<java.util.HashSet: boolean add(java.lang.Object)>
<java.util.HashSet: boolean contains(java.lang.Object)>
<java.util.HashSet: boolean isEmpty()>
<java.util.HashSet: boolean remove(java.lang.Object)>
<java.util.HashSet: int size()>
<java.util.HashSet: java.util.Iterator iterator()>
<java.util.HashSet: void <init>()>
<java.util.HashSet: void <init>(int)>
<java.util.HashSet: void <init>(int,float,boolean)>
<java.util.HashSet: void <init>(java.util.Collection)>
<java.util.HashSet: void clear()>
<java.util.Hashtable$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.Hashtable$Entry)>
<java.util.Hashtable$Enumerator: boolean hasMoreElements()>
<java.util.Hashtable$Enumerator: java.lang.Object nextElement()>
<java.util.Hashtable$Enumerator: void <init>(java.util.Hashtable,int,boolean)>
<java.util.Hashtable: boolean isEmpty()>
<java.util.Hashtable: int access$500(java.util.Hashtable)>
<java.util.Hashtable: java.lang.Object get(java.lang.Object)>
<java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.Hashtable: java.util.Enumeration elements()>
<java.util.Hashtable: java.util.Enumeration getEnumeration(int)>
<java.util.Hashtable: java.util.Hashtable$Entry[] access$400(java.util.Hashtable)>
<java.util.Hashtable: void <init>()>
<java.util.Hashtable: void <init>(int)>
<java.util.Hashtable: void <init>(int,float)>
<java.util.Hashtable: void rehash()>
<java.util.IdentityHashMap$IdentityHashMapIterator: boolean hasNext()>
<java.util.IdentityHashMap$IdentityHashMapIterator: int nextIndex()>
<java.util.IdentityHashMap$IdentityHashMapIterator: void <init>(java.util.IdentityHashMap)>
<java.util.IdentityHashMap$IdentityHashMapIterator: void <init>(java.util.IdentityHashMap,java.util.IdentityHashMap$1)>
<java.util.IdentityHashMap$KeyIterator: java.lang.Object next()>
<java.util.IdentityHashMap$KeyIterator: void <init>(java.util.IdentityHashMap)>
<java.util.IdentityHashMap$KeyIterator: void <init>(java.util.IdentityHashMap,java.util.IdentityHashMap$1)>
<java.util.IdentityHashMap$KeySet: java.util.Iterator iterator()>
<java.util.IdentityHashMap$KeySet: void <init>(java.util.IdentityHashMap)>
<java.util.IdentityHashMap$KeySet: void <init>(java.util.IdentityHashMap,java.util.IdentityHashMap$1)>
<java.util.IdentityHashMap: int access$000(java.util.IdentityHashMap)>
<java.util.IdentityHashMap: int access$200(java.util.IdentityHashMap)>
<java.util.IdentityHashMap: int capacity(int)>
<java.util.IdentityHashMap: int hash(java.lang.Object,int)>
<java.util.IdentityHashMap: int nextKeyIndex(int,int)>
<java.util.IdentityHashMap: java.lang.Object access$600(java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object get(java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object maskNull(java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object unmaskNull(java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object[] access$100(java.util.IdentityHashMap)>
<java.util.IdentityHashMap: java.util.Set keySet()>
<java.util.IdentityHashMap: void <init>()>
<java.util.IdentityHashMap: void <init>(int)>
<java.util.IdentityHashMap: void init(int)>
<java.util.IdentityHashMap: void resize(int)>
<java.util.LinkedHashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.HashMap$Entry)>
<java.util.LinkedHashMap$Entry: void access$600(java.util.LinkedHashMap$Entry,java.util.LinkedHashMap$Entry)>
<java.util.LinkedHashMap$Entry: void addBefore(java.util.LinkedHashMap$Entry)>
<java.util.LinkedHashMap$Entry: void recordAccess(java.util.HashMap)>
<java.util.LinkedHashMap$Entry: void recordRemoval(java.util.HashMap)>
<java.util.LinkedHashMap$Entry: void remove()>
<java.util.LinkedHashMap$EntryIterator: void <init>(java.util.LinkedHashMap)>
<java.util.LinkedHashMap$EntryIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
<java.util.LinkedHashMap$LinkedHashIterator: boolean hasNext()>
<java.util.LinkedHashMap$LinkedHashIterator: void <init>(java.util.LinkedHashMap)>
<java.util.LinkedHashMap$LinkedHashIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
<java.util.LinkedHashMap: boolean access$000(java.util.LinkedHashMap)>
<java.util.LinkedHashMap: boolean removeEldestEntry(java.util.Map$Entry)>
<java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
<java.util.LinkedHashMap: java.util.Iterator newEntryIterator()>
<java.util.LinkedHashMap: java.util.LinkedHashMap$Entry access$100(java.util.LinkedHashMap)>
<java.util.LinkedHashMap: void <init>()>
<java.util.LinkedHashMap: void <init>(int)>
<java.util.LinkedHashMap: void <init>(int,float)>
<java.util.LinkedHashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.LinkedHashMap: void clear()>
<java.util.LinkedHashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.LinkedHashMap: void init()>
<java.util.LinkedHashMap: void transfer(java.util.HashMap$Entry[])>
<java.util.LinkedHashSet: void <init>()>
<java.util.LinkedList$Entry: void <init>(java.lang.Object,java.util.LinkedList$Entry,java.util.LinkedList$Entry)>
<java.util.LinkedList$ListItr: boolean hasNext()>
<java.util.LinkedList$ListItr: java.lang.Object next()>
<java.util.LinkedList$ListItr: void <init>(java.util.LinkedList,int)>
<java.util.LinkedList$ListItr: void checkForComodification()>
<java.util.LinkedList$ListItr: void remove()>
<java.util.LinkedList: boolean add(java.lang.Object)>
<java.util.LinkedList: boolean addAll(int,java.util.Collection)>
<java.util.LinkedList: boolean addAll(java.util.Collection)>
<java.util.LinkedList: boolean contains(java.lang.Object)>
<java.util.LinkedList: int access$100(java.util.LinkedList)>
<java.util.LinkedList: int indexOf(java.lang.Object)>
<java.util.LinkedList: int size()>
<java.util.LinkedList: java.lang.Object access$200(java.util.LinkedList,java.util.LinkedList$Entry)>
<java.util.LinkedList: java.lang.Object element()>
<java.util.LinkedList: java.lang.Object get(int)>
<java.util.LinkedList: java.lang.Object getFirst()>
<java.util.LinkedList: java.lang.Object remove()>
<java.util.LinkedList: java.lang.Object remove(int)>
<java.util.LinkedList: java.lang.Object remove(java.util.LinkedList$Entry)>
<java.util.LinkedList: java.lang.Object removeFirst()>
<java.util.LinkedList: java.lang.Object removeLast()>
<java.util.LinkedList: java.lang.Object set(int,java.lang.Object)>
<java.util.LinkedList: java.lang.Object[] toArray()>
<java.util.LinkedList: java.util.LinkedList$Entry access$000(java.util.LinkedList)>
<java.util.LinkedList: java.util.LinkedList$Entry addBefore(java.lang.Object,java.util.LinkedList$Entry)>
<java.util.LinkedList: java.util.LinkedList$Entry entry(int)>
<java.util.LinkedList: java.util.ListIterator listIterator(int)>
<java.util.LinkedList: void <init>()>
<java.util.LinkedList: void <init>(java.util.Collection)>
<java.util.LinkedList: void add(int,java.lang.Object)>
<java.util.LinkedList: void addFirst(java.lang.Object)>
<java.util.LinkedList: void addLast(java.lang.Object)>
<java.util.LinkedList: void clear()>
<java.util.Locale: boolean equals(java.lang.Object)>
<java.util.Locale: int hashCode()>
<java.util.Locale: java.lang.String getCountry()>
<java.util.Locale: java.lang.String getLanguage()>
<java.util.Locale: java.lang.String getVariant()>
<java.util.Locale: java.lang.String toString()>
<java.util.Locale: java.util.Locale getDefault()>
<java.util.Locale: java.util.Locale getInstance(java.lang.String,java.lang.String,java.lang.String)>
<java.util.Properties: java.lang.Object setProperty(java.lang.String,java.lang.String)>
<java.util.Properties: java.lang.String getProperty(java.lang.String)>
<java.util.Properties: java.lang.String getProperty(java.lang.String,java.lang.String)>
<java.util.RandomAccessSubList: void <init>(java.util.AbstractList,int,int)>
<java.util.ResourceBundle$1: void <init>()>
<java.util.ResourceBundle$BundleReference: void <init>(java.util.ResourceBundle,java.lang.ref.ReferenceQueue,java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$CacheKey: int hashCode()>
<java.util.ResourceBundle$CacheKey: java.lang.ClassLoader getLoader()>
<java.util.ResourceBundle$CacheKey: java.lang.Object clone()>
<java.util.ResourceBundle$CacheKey: java.lang.String getName()>
<java.util.ResourceBundle$CacheKey: java.lang.Throwable access$400(java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$CacheKey: java.lang.Throwable getCause()>
<java.util.ResourceBundle$CacheKey: java.util.Locale getLocale()>
<java.util.ResourceBundle$CacheKey: java.util.ResourceBundle$CacheKey setLocale(java.util.Locale)>
<java.util.ResourceBundle$CacheKey: long access$600(java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$CacheKey: long access$602(java.util.ResourceBundle$CacheKey,long)>
<java.util.ResourceBundle$CacheKey: void <init>(java.lang.String,java.util.Locale,java.lang.ClassLoader)>
<java.util.ResourceBundle$CacheKey: void calculateHashCode()>
<java.util.ResourceBundle$CacheKey: void setFormat(java.lang.String)>
<java.util.ResourceBundle$Control: java.lang.String toBundleName(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: java.util.List getCandidateLocales(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: java.util.List getFormats(java.lang.String)>
<java.util.ResourceBundle$Control: java.util.ResourceBundle newBundle(java.lang.String,java.util.Locale,java.lang.String,java.lang.ClassLoader,boolean)>
<java.util.ResourceBundle$Control: java.util.ResourceBundle$Control access$300()>
<java.util.ResourceBundle$Control: long getTimeToLive(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: void <clinit>()>
<java.util.ResourceBundle$Control: void <init>()>
<java.util.ResourceBundle$LoaderReference: void <init>(java.lang.ClassLoader,java.lang.ref.ReferenceQueue,java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$RBClassLoader$1: java.lang.Object run()>
<java.util.ResourceBundle$RBClassLoader$1: java.util.ResourceBundle$RBClassLoader run()>
<java.util.ResourceBundle$RBClassLoader$1: void <init>()>
<java.util.ResourceBundle$RBClassLoader: java.lang.Class loadClass(java.lang.String)>
<java.util.ResourceBundle$RBClassLoader: java.util.ResourceBundle$RBClassLoader access$000()>
<java.util.ResourceBundle$RBClassLoader: void <clinit>()>
<java.util.ResourceBundle$RBClassLoader: void <init>()>
<java.util.ResourceBundle$RBClassLoader: void <init>(java.util.ResourceBundle$1)>
<java.util.ResourceBundle: boolean checkList(java.util.List)>
<java.util.ResourceBundle: boolean isValidBundle(java.util.ResourceBundle)>
<java.util.ResourceBundle: java.lang.ClassLoader getLoader()>
<java.util.ResourceBundle: java.lang.Object getObject(java.lang.String)>
<java.util.ResourceBundle: java.lang.String[] getStringArray(java.lang.String)>
<java.util.ResourceBundle: java.lang.ref.ReferenceQueue access$200()>
<java.util.ResourceBundle: java.util.ResourceBundle findBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.List,int,java.util.ResourceBundle$Control,java.util.ResourceBundle)>
<java.util.ResourceBundle: java.util.ResourceBundle findBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: java.util.ResourceBundle getBundle(java.lang.String,java.util.Locale,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: java.util.ResourceBundle getBundleImpl(java.lang.String,java.util.Locale,java.lang.ClassLoader,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: java.util.ResourceBundle loadBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.ResourceBundle$Control,boolean)>
<java.util.ResourceBundle: java.util.ResourceBundle putBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: void <clinit>()>
<java.util.ResourceBundle: void <init>()>
<java.util.ResourceBundle: void setExpirationTime(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: void setParent(java.util.ResourceBundle)>
<java.util.ServiceLoader$1: boolean hasNext()>
<java.util.ServiceLoader$1: void <init>(java.util.ServiceLoader)>
<java.util.ServiceLoader$LazyIterator: boolean hasNext()>
<java.util.ServiceLoader$LazyIterator: void <init>(java.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader)>
<java.util.ServiceLoader$LazyIterator: void <init>(java.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader,java.util.ServiceLoader$1)>
<java.util.ServiceLoader: java.util.Iterator iterator()>
<java.util.ServiceLoader: java.util.LinkedHashMap access$400(java.util.ServiceLoader)>
<java.util.ServiceLoader: java.util.ServiceLoader load(java.lang.Class,java.lang.ClassLoader)>
<java.util.ServiceLoader: java.util.ServiceLoader loadInstalled(java.lang.Class)>
<java.util.ServiceLoader: java.util.ServiceLoader$LazyIterator access$500(java.util.ServiceLoader)>
<java.util.ServiceLoader: void <init>(java.lang.Class,java.lang.ClassLoader)>
<java.util.ServiceLoader: void reload()>
<java.util.Stack: boolean empty()>
<java.util.Stack: java.lang.Object peek()>
<java.util.Stack: java.lang.Object pop()>
<java.util.Stack: java.lang.Object push(java.lang.Object)>
<java.util.Stack: void <init>()>
<java.util.StringTokenizer: boolean hasMoreTokens()>
<java.util.StringTokenizer: int countTokens()>
<java.util.StringTokenizer: int scanToken(int)>
<java.util.StringTokenizer: int skipDelimiters(int)>
<java.util.StringTokenizer: java.lang.String nextToken()>
<java.util.StringTokenizer: void <init>(java.lang.String)>
<java.util.StringTokenizer: void <init>(java.lang.String,java.lang.String)>
<java.util.StringTokenizer: void <init>(java.lang.String,java.lang.String,boolean)>
<java.util.StringTokenizer: void setMaxDelimCodePoint()>
<java.util.SubList$1: boolean hasNext()>
<java.util.SubList$1: int nextIndex()>
<java.util.SubList$1: java.lang.Object next()>
<java.util.SubList$1: void <init>(java.util.SubList,int)>
<java.util.SubList: int access$000(java.util.SubList)>
<java.util.SubList: int access$200(java.util.SubList)>
<java.util.SubList: int size()>
<java.util.SubList: java.util.AbstractList access$100(java.util.SubList)>
<java.util.SubList: java.util.Iterator iterator()>
<java.util.SubList: java.util.ListIterator listIterator(int)>
<java.util.SubList: void <init>(java.util.AbstractList,int,int)>
<java.util.SubList: void checkForComodification()>
<java.util.TimeZone$1: java.lang.Object run()>
<java.util.TimeZone$1: void <init>(java.lang.String)>
<java.util.TimeZone$DisplayNames: java.util.Map access$000()>
<java.util.TimeZone$DisplayNames: void <clinit>()>
<java.util.TimeZone: java.lang.Object clone()>
<java.util.TimeZone: java.lang.String getDisplayName(boolean,int,java.util.Locale)>
<java.util.TimeZone: java.lang.String getID()>
<java.util.TimeZone: java.lang.String[] getDisplayNames(java.lang.String,java.util.Locale)>
<java.util.TimeZone: java.util.TimeZone getDefaultInAppContext()>
<java.util.TimeZone: java.util.TimeZone getDefaultRef()>
<java.util.TimeZone: java.util.TimeZone getTimeZone(java.lang.String,boolean)>
<java.util.TimeZone: java.util.TimeZone setDefaultZone()>
<java.util.TimeZone: void <clinit>()>
<java.util.TimeZone: void <init>()>
<java.util.TimeZone: void setID(java.lang.String)>
<java.util.TreeMap$Entry: java.lang.Object setValue(java.lang.Object)>
<java.util.TreeMap$Entry: void <init>(java.lang.Object,java.lang.Object,java.util.TreeMap$Entry)>
<java.util.TreeMap$KeyIterator: java.lang.Object next()>
<java.util.TreeMap$KeyIterator: void <init>(java.util.TreeMap,java.util.TreeMap$Entry)>
<java.util.TreeMap$KeySet: java.util.Iterator iterator()>
<java.util.TreeMap$KeySet: void <init>(java.util.NavigableMap)>
<java.util.TreeMap$PrivateEntryIterator: boolean hasNext()>
<java.util.TreeMap$PrivateEntryIterator: java.util.TreeMap$Entry nextEntry()>
<java.util.TreeMap$PrivateEntryIterator: void <init>(java.util.TreeMap,java.util.TreeMap$Entry)>
<java.util.TreeMap: boolean colorOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: boolean containsKey(java.lang.Object)>
<java.util.TreeMap: int access$100(java.util.TreeMap)>
<java.util.TreeMap: int size()>
<java.util.TreeMap: java.lang.Object firstKey()>
<java.util.TreeMap: java.lang.Object key(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.TreeMap: java.lang.Object remove(java.lang.Object)>
<java.util.TreeMap: java.util.Iterator keyIterator()>
<java.util.TreeMap: java.util.NavigableSet navigableKeySet()>
<java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
<java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
<java.util.TreeMap: java.util.TreeMap$Entry getFirstEntry()>
<java.util.TreeMap: java.util.TreeMap$Entry leftOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.util.TreeMap$Entry parentOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.util.TreeMap$Entry rightOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.util.TreeMap$Entry successor(java.util.TreeMap$Entry)>
<java.util.TreeMap: void <init>()>
<java.util.TreeMap: void <init>(java.util.Comparator)>
<java.util.TreeMap: void deleteEntry(java.util.TreeMap$Entry)>
<java.util.TreeMap: void fixAfterDeletion(java.util.TreeMap$Entry)>
<java.util.TreeMap: void fixAfterInsertion(java.util.TreeMap$Entry)>
<java.util.TreeMap: void rotateLeft(java.util.TreeMap$Entry)>
<java.util.TreeMap: void rotateRight(java.util.TreeMap$Entry)>
<java.util.TreeMap: void setColor(java.util.TreeMap$Entry,boolean)>
<java.util.TreeSet: boolean add(java.lang.Object)>
<java.util.TreeSet: boolean addAll(java.util.Collection)>
<java.util.TreeSet: boolean contains(java.lang.Object)>
<java.util.TreeSet: boolean isEmpty()>
<java.util.TreeSet: boolean remove(java.lang.Object)>
<java.util.TreeSet: int size()>
<java.util.TreeSet: java.lang.Object first()>
<java.util.TreeSet: java.util.Iterator iterator()>
<java.util.TreeSet: void <clinit>()>
<java.util.TreeSet: void <init>()>
<java.util.TreeSet: void <init>(java.util.Collection)>
<java.util.TreeSet: void <init>(java.util.Comparator)>
<java.util.TreeSet: void <init>(java.util.NavigableMap)>
<java.util.Vector$1: boolean hasMoreElements()>
<java.util.Vector$1: java.lang.Object nextElement()>
<java.util.Vector$1: void <init>(java.util.Vector)>
<java.util.Vector: boolean add(java.lang.Object)>
<java.util.Vector: int size()>
<java.util.Vector: java.lang.Object elementAt(int)>
<java.util.Vector: java.lang.Object firstElement()>
<java.util.Vector: java.lang.Object get(int)>
<java.util.Vector: java.lang.Object remove(int)>
<java.util.Vector: java.util.Enumeration elements()>
<java.util.Vector: void <init>()>
<java.util.Vector: void <init>(int)>
<java.util.Vector: void <init>(int,int)>
<java.util.Vector: void addElement(java.lang.Object)>
<java.util.Vector: void ensureCapacity(int)>
<java.util.Vector: void ensureCapacityHelper(int)>
<java.util.Vector: void removeAllElements()>
<java.util.Vector: void removeElementAt(int)>
<java.util.concurrent.ConcurrentHashMap$HashEntry: java.util.concurrent.ConcurrentHashMap$HashEntry[] newArray(int)>
<java.util.concurrent.ConcurrentHashMap$HashEntry: void <init>(java.lang.Object,int,java.util.concurrent.ConcurrentHashMap$HashEntry,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.lang.Object get(java.lang.Object,int)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.lang.Object put(java.lang.Object,int,java.lang.Object,boolean)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.util.concurrent.ConcurrentHashMap$HashEntry getFirst(int)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.util.concurrent.ConcurrentHashMap$Segment[] newArray(int)>
<java.util.concurrent.ConcurrentHashMap$Segment: void <init>(int,float)>
<java.util.concurrent.ConcurrentHashMap$Segment: void setTable(java.util.concurrent.ConcurrentHashMap$HashEntry[])>
<java.util.concurrent.ConcurrentHashMap: int hash(int)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap$Segment segmentFor(int)>
<java.util.concurrent.ConcurrentHashMap: void <init>()>
<java.util.concurrent.ConcurrentHashMap: void <init>(int)>
<java.util.concurrent.ConcurrentHashMap: void <init>(int,float,int)>
<java.util.concurrent.atomic.AtomicInteger: boolean compareAndSet(int,int)>
<java.util.concurrent.atomic.AtomicInteger: int decrementAndGet()>
<java.util.concurrent.atomic.AtomicInteger: int get()>
<java.util.concurrent.atomic.AtomicInteger: int incrementAndGet()>
<java.util.concurrent.atomic.AtomicInteger: void <init>()>
<java.util.concurrent.atomic.AtomicReference: void <clinit>()>
<java.util.concurrent.atomic.AtomicReference: void <init>(java.lang.Object)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl: boolean compareAndSet(java.lang.Object,java.lang.Object,java.lang.Object)>
<java.util.concurrent.locks.AbstractOwnableSynchronizer: java.lang.Thread getExclusiveOwnerThread()>
<java.util.concurrent.locks.AbstractOwnableSynchronizer: void <init>()>
<java.util.concurrent.locks.AbstractOwnableSynchronizer: void setExclusiveOwnerThread(java.lang.Thread)>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: boolean compareAndSetState(int,int)>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: boolean release(int)>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: int getState()>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: void <init>()>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: void setState(int)>
<java.util.concurrent.locks.ReentrantLock$NonfairSync: void <init>()>
<java.util.concurrent.locks.ReentrantLock$NonfairSync: void lock()>
<java.util.concurrent.locks.ReentrantLock$Sync: boolean tryRelease(int)>
<java.util.concurrent.locks.ReentrantLock$Sync: void <init>()>
<java.util.concurrent.locks.ReentrantLock: void <init>()>
<java.util.concurrent.locks.ReentrantLock: void lock()>
<java.util.concurrent.locks.ReentrantLock: void unlock()>
<java.util.jar.Attributes$Name: boolean isAlpha(char)>
<java.util.jar.Attributes$Name: boolean isDigit(char)>
<java.util.jar.Attributes$Name: boolean isValid(char)>
<java.util.jar.Attributes$Name: boolean isValid(java.lang.String)>
<java.util.jar.Attributes$Name: int hashCode()>
<java.util.jar.Attributes$Name: void <clinit>()>
<java.util.jar.Attributes$Name: void <init>(java.lang.String)>
<java.util.jar.Attributes: java.lang.Object get(java.lang.Object)>
<java.util.jar.Attributes: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.jar.Attributes: java.lang.String getValue(java.util.jar.Attributes$Name)>
<java.util.jar.Attributes: java.lang.String putValue(java.lang.String,java.lang.String)>
<java.util.jar.Attributes: void <init>()>
<java.util.jar.Attributes: void <init>(int)>
<java.util.jar.Attributes: void read(java.util.jar.Manifest$FastInputStream,byte[])>
<java.util.jar.JarEntry: void <init>(java.util.jar.JarEntry)>
<java.util.jar.JarEntry: void <init>(java.util.zip.ZipEntry)>
<java.util.jar.JarFile$JarFileEntry: java.security.CodeSigner[] getCodeSigners()>
<java.util.jar.JarFile$JarFileEntry: void <init>(java.util.jar.JarFile,java.util.zip.ZipEntry)>
<java.util.jar.JarFile: boolean hasClassPathAttribute()>
<java.util.jar.JarFile: boolean isKnownToNotHaveClassPathAttribute()>
<java.util.jar.JarFile: byte[] getBytes(java.util.zip.ZipEntry)>
<java.util.jar.JarFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>
<java.util.jar.JarFile: java.util.jar.JarEntry getJarEntry(java.lang.String)>
<java.util.jar.JarFile: java.util.jar.JarEntry getManEntry()>
<java.util.jar.JarFile: java.util.jar.JarVerifier access$100(java.util.jar.JarFile)>
<java.util.jar.JarFile: java.util.jar.Manifest getManifest()>
<java.util.jar.JarFile: java.util.jar.Manifest getManifestFromReference()>
<java.util.jar.JarFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
<java.util.jar.JarFile: void <clinit>()>
<java.util.jar.JarFile: void <init>(java.io.File,boolean,int)>
<java.util.jar.JarFile: void <init>(java.lang.String)>
<java.util.jar.JarFile: void access$000(java.util.jar.JarFile)>
<java.util.jar.JarFile: void initializeVerifier()>
<java.util.jar.JarFile: void maybeInstantiateVerifier()>
<java.util.jar.JarVerifier$3: void <init>(java.util.jar.JarVerifier)>
<java.util.jar.JarVerifier: boolean nothingToVerify()>
<java.util.jar.JarVerifier: void <clinit>()>
<java.util.jar.JarVerifier: void <init>(byte[])>
<java.util.jar.JarVerifier: void beginEntry(java.util.jar.JarEntry,sun.security.util.ManifestEntryVerifier)>
<java.util.jar.JarVerifier: void doneWithMeta()>
<java.util.jar.JarVerifier: void processEntry(sun.security.util.ManifestEntryVerifier)>
<java.util.jar.JarVerifier: void update(int,byte[],int,int,sun.security.util.ManifestEntryVerifier)>
<java.util.jar.JavaUtilJarAccessImpl: boolean jarFileHasClassPathAttribute(java.util.jar.JarFile)>
<java.util.jar.JavaUtilJarAccessImpl: void <init>()>
<java.util.jar.Manifest$FastInputStream: byte peek()>
<java.util.jar.Manifest$FastInputStream: int readLine(byte[])>
<java.util.jar.Manifest$FastInputStream: int readLine(byte[],int,int)>
<java.util.jar.Manifest$FastInputStream: void <init>(java.io.InputStream)>
<java.util.jar.Manifest$FastInputStream: void <init>(java.io.InputStream,int)>
<java.util.jar.Manifest$FastInputStream: void fill()>
<java.util.jar.Manifest: java.util.Map getEntries()>
<java.util.jar.Manifest: java.util.jar.Attributes getAttributes(java.lang.String)>
<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>
<java.util.jar.Manifest: void <init>(java.io.InputStream)>
<java.util.jar.Manifest: void read(java.io.InputStream)>
<java.util.regex.Matcher: boolean find()>
<java.util.regex.Matcher: boolean search(int)>
<java.util.regex.Matcher: int end()>
<java.util.regex.Matcher: int getTextLength()>
<java.util.regex.Matcher: int start()>
<java.util.regex.Matcher: java.util.regex.Matcher reset()>
<java.util.regex.Matcher: void <init>(java.util.regex.Pattern,java.lang.CharSequence)>
<java.util.regex.Pattern$BmpCharProperty: boolean match(java.util.regex.Matcher,int,java.lang.CharSequence)>
<java.util.regex.Pattern$BmpCharProperty: void <init>()>
<java.util.regex.Pattern$BmpCharProperty: void <init>(java.util.regex.Pattern$1)>
<java.util.regex.Pattern$CharProperty: boolean study(java.util.regex.Pattern$TreeInfo)>
<java.util.regex.Pattern$CharProperty: void <init>()>
<java.util.regex.Pattern$CharProperty: void <init>(java.util.regex.Pattern$1)>
<java.util.regex.Pattern$LastNode: boolean match(java.util.regex.Matcher,int,java.lang.CharSequence)>
<java.util.regex.Pattern$Node: boolean study(java.util.regex.Pattern$TreeInfo)>
<java.util.regex.Pattern$Node: void <init>()>
<java.util.regex.Pattern$Single: boolean isSatisfiedBy(int)>
<java.util.regex.Pattern$Single: void <init>(int)>
<java.util.regex.Pattern$Start: boolean match(java.util.regex.Matcher,int,java.lang.CharSequence)>
<java.util.regex.Pattern$Start: void <init>(java.util.regex.Pattern$Node)>
<java.util.regex.Pattern$TreeInfo: void <init>()>
<java.util.regex.Pattern$TreeInfo: void reset()>
<java.util.regex.Pattern: boolean has(int)>
<java.util.regex.Pattern: boolean isSupplementary(int)>
<java.util.regex.Pattern: boolean isSurrogate(int)>
<java.util.regex.Pattern: int next()>
<java.util.regex.Pattern: int peek()>
<java.util.regex.Pattern: java.lang.String[] split(java.lang.CharSequence,int)>
<java.util.regex.Pattern: java.util.regex.Matcher matcher(java.lang.CharSequence)>
<java.util.regex.Pattern: java.util.regex.Pattern compile(java.lang.String)>
<java.util.regex.Pattern: java.util.regex.Pattern$CharProperty newSingle(int)>
<java.util.regex.Pattern: java.util.regex.Pattern$Node atom()>
<java.util.regex.Pattern: java.util.regex.Pattern$Node closure(java.util.regex.Pattern$Node)>
<java.util.regex.Pattern: java.util.regex.Pattern$Node expr(java.util.regex.Pattern$Node)>
<java.util.regex.Pattern: java.util.regex.Pattern$Node sequence(java.util.regex.Pattern$Node)>
<java.util.regex.Pattern: void <init>(java.lang.String,int)>
<java.util.regex.Pattern: void RemoveQEQuoting()>
<java.util.regex.Pattern: void append(int,int)>
<java.util.regex.Pattern: void compile()>
<java.util.zip.Inflater: boolean finished()>
<java.util.zip.Inflater: boolean needsDictionary()>
<java.util.zip.Inflater: boolean needsInput()>
<java.util.zip.Inflater: int inflate(byte[],int,int)>
<java.util.zip.Inflater: long getBytesWritten()>
<java.util.zip.Inflater: void <clinit>()>
<java.util.zip.Inflater: void <init>(boolean)>
<java.util.zip.Inflater: void end()>
<java.util.zip.Inflater: void ensureOpen()>
<java.util.zip.Inflater: void finalize()>
<java.util.zip.Inflater: void reset()>
<java.util.zip.Inflater: void setInput(byte[],int,int)>
<java.util.zip.InflaterInputStream: int read(byte[],int,int)>
<java.util.zip.InflaterInputStream: void <init>(java.io.InputStream,java.util.zip.Inflater,int)>
<java.util.zip.InflaterInputStream: void ensureOpen()>
<java.util.zip.ZStreamRef: long address()>
<java.util.zip.ZStreamRef: void <init>(long)>
<java.util.zip.ZStreamRef: void clear()>
<java.util.zip.ZipEntry: boolean isDirectory()>
<java.util.zip.ZipEntry: java.lang.String getName()>
<java.util.zip.ZipEntry: long getSize()>
<java.util.zip.ZipEntry: void <clinit>()>
<java.util.zip.ZipEntry: void <init>(java.lang.String,long)>
<java.util.zip.ZipEntry: void <init>(java.util.zip.ZipEntry)>
<java.util.zip.ZipEntry: void <init>(long)>
<java.util.zip.ZipFile$1: int available()>
<java.util.zip.ZipFile$1: void <init>(java.util.zip.ZipFile,java.io.InputStream,java.util.zip.Inflater,int,java.util.zip.ZipFile$ZipFileInputStream)>
<java.util.zip.ZipFile$1: void close()>
<java.util.zip.ZipFile$1: void fill()>
<java.util.zip.ZipFile$2: boolean hasMoreElements()>
<java.util.zip.ZipFile$2: java.lang.Object nextElement()>
<java.util.zip.ZipFile$2: java.util.zip.ZipEntry nextElement()>
<java.util.zip.ZipFile$2: void <init>(java.util.zip.ZipFile)>
<java.util.zip.ZipFile$ZipFileInputStream: int read(byte[],int,int)>
<java.util.zip.ZipFile$ZipFileInputStream: long size()>
<java.util.zip.ZipFile$ZipFileInputStream: void <init>(java.util.zip.ZipFile,long)>
<java.util.zip.ZipFile$ZipFileInputStream: void close()>
<java.util.zip.ZipFile: int access$1200(long,long,long,byte[],int,int)>
<java.util.zip.ZipFile: int access$200(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: java.io.InputStream getInputStream(java.lang.String)>
<java.util.zip.ZipFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>
<java.util.zip.ZipFile: java.lang.String getName()>
<java.util.zip.ZipFile: java.util.Enumeration entries()>
<java.util.zip.ZipFile: java.util.zip.Inflater getInflater()>
<java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
<java.util.zip.ZipFile: long access$1000(long)>
<java.util.zip.ZipFile: long access$300(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: long access$400(long,int)>
<java.util.zip.ZipFile: long access$900(long)>
<java.util.zip.ZipFile: void <clinit>()>
<java.util.zip.ZipFile: void <init>(java.io.File)>
<java.util.zip.ZipFile: void <init>(java.io.File,int)>
<java.util.zip.ZipFile: void <init>(java.lang.String)>
<java.util.zip.ZipFile: void access$000(java.util.zip.ZipFile,java.util.zip.Inflater)>
<java.util.zip.ZipFile: void access$100(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: void access$1100(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: void access$800(long,long)>
<java.util.zip.ZipFile: void close()>
<java.util.zip.ZipFile: void ensureOpen()>
<java.util.zip.ZipFile: void ensureOpenOrZipException()>
<java.util.zip.ZipFile: void finalize()>
<java.util.zip.ZipFile: void releaseInflater(java.util.zip.Inflater)>
<java_cup.runtime.Symbol: void <init>(int)>
<java_cup.runtime.Symbol: void <init>(int,int)>
<java_cup.runtime.Symbol: void <init>(int,int,int,java.lang.Object)>
<java_cup.runtime.Symbol: void <init>(int,java.lang.Object)>
<java_cup.runtime.lr_parser: java_cup.runtime.Symbol parse()>
<java_cup.runtime.lr_parser: short get_action(int,int)>
<java_cup.runtime.lr_parser: short get_reduce(int,int)>
<java_cup.runtime.lr_parser: short[][] unpackFromStrings(java.lang.String[])>
<java_cup.runtime.lr_parser: void <init>()>
<java_cup.runtime.lr_parser: void done_parsing()>
<soot.AbstractJasminClass$1: void <init>()>
<soot.AbstractJasminClass$1: void caseArrayType(soot.ArrayType)>
<soot.AbstractJasminClass$1: void caseRefType(soot.RefType)>
<soot.AbstractJasminClass$1: void caseVoidType(soot.VoidType)>
<soot.AbstractJasminClass: int sizeOfType(soot.Type)>
<soot.AbstractJasminClass: java.lang.String jasminDescriptorOf(soot.SootMethodRef)>
<soot.AbstractJasminClass: java.lang.String jasminDescriptorOf(soot.Type)>
<soot.AbstractJasminClass: java.lang.String slashify(java.lang.String)>
<soot.AbstractJasminClass: void <init>(soot.SootClass)>
<soot.AbstractJasminClass: void emit(java.lang.String)>
<soot.AbstractJasminClass: void emitMethod(soot.SootMethod)>
<soot.AbstractJasminClass: void okayEmit(java.lang.String)>
<soot.AbstractJasminClass: void print(java.io.PrintWriter)>
<soot.AbstractSootFieldRef: boolean isStatic()>
<soot.AbstractSootFieldRef: java.lang.String name()>
<soot.AbstractSootFieldRef: soot.SootClass declaringClass()>
<soot.AbstractSootFieldRef: soot.SootField checkStatic(soot.SootField)>
<soot.AbstractSootFieldRef: soot.SootField resolve()>
<soot.AbstractSootFieldRef: soot.SootField resolve(java.lang.StringBuffer)>
<soot.AbstractSootFieldRef: soot.Type type()>
<soot.AbstractSootFieldRef: void <init>(soot.SootClass,java.lang.String,soot.Type,boolean)>
<soot.AbstractSootMethodRef: boolean isStatic()>
<soot.AbstractSootMethodRef: java.lang.String name()>
<soot.AbstractSootMethodRef: java.util.List parameterTypes()>
<soot.AbstractSootMethodRef: soot.SootClass declaringClass()>
<soot.AbstractSootMethodRef: soot.SootMethod checkStatic(soot.SootMethod)>
<soot.AbstractSootMethodRef: soot.SootMethod resolve()>
<soot.AbstractSootMethodRef: soot.SootMethod resolve(java.lang.StringBuffer)>
<soot.AbstractSootMethodRef: soot.Type parameterType(int)>
<soot.AbstractSootMethodRef: soot.Type returnType()>
<soot.AbstractSootMethodRef: soot.util.NumberedString getSubSignature()>
<soot.AbstractSootMethodRef: void <init>(soot.SootClass,java.lang.String,java.util.List,soot.Type,boolean)>
<soot.AbstractTrap: soot.SootClass getException()>
<soot.AbstractTrap: soot.Unit getBeginUnit()>
<soot.AbstractTrap: soot.Unit getEndUnit()>
<soot.AbstractTrap: soot.Unit getHandlerUnit()>
<soot.AbstractTrap: void <init>(soot.SootClass,soot.UnitBox,soot.UnitBox,soot.UnitBox)>
<soot.AbstractUnit: java.util.List getBoxesPointingToThis()>
<soot.AbstractUnit: java.util.List getDefBoxes()>
<soot.AbstractUnit: java.util.List getUnitBoxes()>
<soot.AbstractUnit: java.util.List getUseBoxes()>
<soot.AbstractUnit: void <clinit>()>
<soot.AbstractUnit: void <init>()>
<soot.AbstractUnit: void addBoxPointingToThis(soot.UnitBox)>
<soot.AbstractUnit: void clearUnitBoxes()>
<soot.AbstractUnit: void redirectJumpsToThisTo(soot.Unit)>
<soot.AbstractUnit: void removeBoxPointingToThis(soot.UnitBox)>
<soot.AbstractUnitAllMapTo: void <init>(java.lang.Object)>
<soot.AbstractUnitBox: boolean isBranchTarget()>
<soot.AbstractUnitBox: soot.Unit getUnit()>
<soot.AbstractUnitBox: void <init>()>
<soot.AbstractUnitBox: void setUnit(soot.Unit)>
<soot.AbstractValueBox: soot.Value getValue()>
<soot.AbstractValueBox: void <init>()>
<soot.AbstractValueBox: void setValue(soot.Value)>
<soot.AnySubType: soot.AnySubType v(soot.RefType)>
<soot.AnySubType: soot.RefType getBase()>
<soot.AnySubType: void <init>(soot.RefType)>
<soot.ArrayType: boolean equals(java.lang.Object)>
<soot.ArrayType: int hashCode()>
<soot.ArrayType: java.lang.String toString()>
<soot.ArrayType: soot.ArrayType makeArrayType()>
<soot.ArrayType: soot.ArrayType v(soot.Type,int)>
<soot.ArrayType: soot.Type getElementType()>
<soot.ArrayType: void <init>(soot.Type,int)>
<soot.ArrayType: void apply(soot.util.Switch)>
<soot.Body: int getLocalCount()>
<soot.Body: java.util.List getAllUnitBoxes()>
<soot.Body: java.util.List getDefBoxes()>
<soot.Body: java.util.List getUnitBoxes(boolean)>
<soot.Body: java.util.List getUseBoxes()>
<soot.Body: soot.Local getThisLocal()>
<soot.Body: soot.PatchingChain getUnits()>
<soot.Body: soot.SootMethod getMethod()>
<soot.Body: soot.util.Chain getLocals()>
<soot.Body: soot.util.Chain getTraps()>
<soot.Body: void <init>(soot.SootMethod)>
<soot.Body: void validate()>
<soot.Body: void validateLocal(soot.ValueBox)>
<soot.Body: void validateLocals()>
<soot.Body: void validateTraps()>
<soot.Body: void validateUnitBoxes()>
<soot.BodyPack: void <init>(java.lang.String)>
<soot.BodyPack: void internalApply(soot.Body)>
<soot.BodyTransformer: void <init>()>
<soot.BodyTransformer: void transform(soot.Body)>
<soot.BodyTransformer: void transform(soot.Body,java.lang.String)>
<soot.BodyTransformer: void transform(soot.Body,java.lang.String,java.util.Map)>
<soot.BooleanType: boolean equals(java.lang.Object)>
<soot.BooleanType: int hashCode()>
<soot.BooleanType: java.lang.String toString()>
<soot.BooleanType: soot.BooleanType v()>
<soot.BooleanType: void <init>(soot.Singletons$Global)>
<soot.ByteType: boolean equals(java.lang.Object)>
<soot.ByteType: int hashCode()>
<soot.ByteType: java.lang.String toString()>
<soot.ByteType: soot.ByteType v()>
<soot.ByteType: void <init>(soot.Singletons$Global)>
<soot.CharType: boolean equals(java.lang.Object)>
<soot.CharType: int hashCode()>
<soot.CharType: java.lang.String toString()>
<soot.CharType: soot.CharType v()>
<soot.CharType: void <init>(soot.Singletons$Global)>
<soot.ClassSource: void <init>(java.lang.String)>
<soot.CoffiClassProvider: soot.ClassSource find(java.lang.String)>
<soot.CoffiClassProvider: void <init>()>
<soot.CoffiClassSource: soot.javaToJimple.IInitialResolver$Dependencies resolve(soot.SootClass)>
<soot.CoffiClassSource: void <init>(java.lang.String,java.io.InputStream)>
<soot.DoubleType: boolean equals(java.lang.Object)>
<soot.DoubleType: int hashCode()>
<soot.DoubleType: java.lang.String toString()>
<soot.DoubleType: soot.DoubleType v()>
<soot.DoubleType: void <init>(soot.Singletons$Global)>
<soot.EntryPoints: java.util.List all()>
<soot.EntryPoints: java.util.List application()>
<soot.EntryPoints: java.util.List clinitsOf(soot.SootClass)>
<soot.EntryPoints: java.util.List implicit()>
<soot.EntryPoints: soot.EntryPoints v()>
<soot.EntryPoints: void <init>(soot.Singletons$Global)>
<soot.EntryPoints: void addMethod(java.util.List,java.lang.String)>
<soot.EntryPoints: void addMethod(java.util.List,soot.SootClass,soot.util.NumberedString)>
<soot.ErroneousType: soot.ErroneousType v()>
<soot.ErroneousType: void <init>(soot.Singletons$Global)>
<soot.FastHierarchy$Interval: boolean isSubrange(soot.FastHierarchy$Interval)>
<soot.FastHierarchy$Interval: void <init>(soot.FastHierarchy)>
<soot.FastHierarchy: boolean canStoreClass(soot.SootClass,soot.SootClass)>
<soot.FastHierarchy: boolean canStoreType(soot.Type,soot.Type)>
<soot.FastHierarchy: int dfsVisit(int,soot.SootClass)>
<soot.FastHierarchy: java.util.Collection getSubclassesOf(soot.SootClass)>
<soot.FastHierarchy: java.util.Set getAllImplementersOfInterface(soot.SootClass)>
<soot.FastHierarchy: java.util.Set getAllSubinterfaces(soot.SootClass)>
<soot.FastHierarchy: void <init>()>
<soot.FastHierarchy: void put(java.util.Map,java.lang.Object,java.lang.Object)>
<soot.FloatType: boolean equals(java.lang.Object)>
<soot.FloatType: int hashCode()>
<soot.FloatType: java.lang.String toString()>
<soot.FloatType: soot.FloatType v()>
<soot.FloatType: void <init>(soot.Singletons$Global)>
<soot.G: soot.G v()>
<soot.G: void <clinit>()>
<soot.G: void <init>()>
<soot.IntType: boolean equals(java.lang.Object)>
<soot.IntType: int hashCode()>
<soot.IntType: java.lang.String toString()>
<soot.IntType: soot.IntType v()>
<soot.IntType: void <init>(soot.Singletons$Global)>
<soot.JastAddJ.ASTNode$State: void <init>()>
<soot.JastAddJ.ASTNode: void <clinit>()>
<soot.JastAddJ.ASTNode: void <init>()>
<soot.JastAddJ.ASTNode: void is$Final(boolean)>
<soot.JastAddJ.ASTNode: void reset()>
<soot.JastAddJ.ASTNode: void setChild(soot.JastAddJ.ASTNode,int)>
<soot.JastAddJ.ASTNode: void setParent(soot.JastAddJ.ASTNode)>
<soot.JastAddJ.BytecodeParser: void <init>()>
<soot.JastAddJ.BytecodeParser: void <init>(java.lang.String)>
<soot.JastAddJ.FileNamesPart: void <init>(soot.JastAddJ.Program)>
<soot.JastAddJ.FolderPart: void <init>(java.io.File)>
<soot.JastAddJ.List: void <init>()>
<soot.JastAddJ.Option: void <init>(java.lang.String,boolean,boolean)>
<soot.JastAddJ.PathPart: soot.JastAddJ.PathPart createClassPath(java.lang.String,soot.JastAddJ.Program)>
<soot.JastAddJ.PathPart: soot.JastAddJ.PathPart createPathPart(java.lang.String)>
<soot.JastAddJ.PathPart: soot.JastAddJ.PathPart createSourcePath(java.lang.String,soot.JastAddJ.Program)>
<soot.JastAddJ.PathPart: void <init>()>
<soot.JastAddJ.Program: boolean hasOption(java.lang.String)>
<soot.JastAddJ.Program: boolean hasValueForOption(java.lang.String)>
<soot.JastAddJ.Program: boolean verbose()>
<soot.JastAddJ.Program: java.lang.String getValueForOption(java.lang.String)>
<soot.JastAddJ.Program: void <clinit>()>
<soot.JastAddJ.Program: void <init>()>
<soot.JastAddJ.Program: void addKeyValueOption(java.lang.String)>
<soot.JastAddJ.Program: void initBytecodeReader(soot.JastAddJ.BytecodeReader)>
<soot.JastAddJ.Program: void initJavaParser(soot.JastAddJ.JavaParser)>
<soot.JastAddJ.Program: void initOptions()>
<soot.JastAddJ.Program: void initPaths()>
<soot.JastAddJ.Program: void setSrcPrec(int)>
<soot.JastAddJ.Program: void setValueForOption(java.lang.String,java.lang.String)>
<soot.JastAddJ.ZipFilePart: void <init>(java.util.zip.ZipFile)>
<soot.JavaClassProvider: void <init>()>
<soot.JavaToJimpleBodyPack: void <init>()>
<soot.JimpleBodyPack: void <init>()>
<soot.JimpleBodyPack: void applyPhaseOptions(soot.jimple.JimpleBody,java.util.Map)>
<soot.JimpleBodyPack: void internalApply(soot.Body)>
<soot.JimpleClassProvider: void <init>()>
<soot.Kind: boolean isClinit()>
<soot.Kind: boolean isExplicit()>
<soot.Kind: boolean isInstance()>
<soot.Kind: boolean isStatic()>
<soot.Kind: boolean passesParameters()>
<soot.Kind: int getNumber()>
<soot.Kind: void <clinit>()>
<soot.Kind: void <init>(java.lang.String)>
<soot.Kind: void setNumber(int)>
<soot.LongType: boolean equals(java.lang.Object)>
<soot.LongType: int hashCode()>
<soot.LongType: java.lang.String toString()>
<soot.LongType: soot.LongType v()>
<soot.LongType: void <init>(soot.Singletons$Global)>
<soot.Main: int run(java.lang.String[])>
<soot.Main: soot.Main v()>
<soot.Main: void <init>(soot.Singletons$Global)>
<soot.Main: void exitCompilation(int)>
<soot.Main: void exitCompilation(int,java.lang.String)>
<soot.Main: void main(java.lang.String[])>
<soot.Main: void postCmdLineCheck()>
<soot.Main: void processCmdLine(java.lang.String[])>
<soot.MethodContext: soot.MethodOrMethodContext v(soot.SootMethod,soot.Context)>
<soot.Modifier: boolean isAbstract(int)>
<soot.Modifier: boolean isAnnotation(int)>
<soot.Modifier: boolean isEnum(int)>
<soot.Modifier: boolean isFinal(int)>
<soot.Modifier: boolean isInterface(int)>
<soot.Modifier: boolean isNative(int)>
<soot.Modifier: boolean isPublic(int)>
<soot.Modifier: boolean isStatic(int)>
<soot.Modifier: boolean isStrictFP(int)>
<soot.Modifier: boolean isSynchronized(int)>
<soot.Modifier: boolean isTransient(int)>
<soot.Modifier: boolean isVolatile(int)>
<soot.Modifier: java.lang.String toString(int)>
<soot.NullType: boolean equals(java.lang.Object)>
<soot.NullType: soot.NullType v()>
<soot.NullType: void <init>(soot.Singletons$Global)>
<soot.Pack: java.lang.String getDefaultOptions()>
<soot.Pack: java.lang.String getPhaseName()>
<soot.Pack: java.util.Iterator iterator()>
<soot.Pack: soot.Transform get(java.lang.String)>
<soot.Pack: void <init>(java.lang.String)>
<soot.Pack: void add(soot.Transform)>
<soot.Pack: void apply()>
<soot.Pack: void apply(soot.Body)>
<soot.PackManager: boolean hasPack(java.lang.String)>
<soot.PackManager: boolean hasPhase(java.lang.String)>
<soot.PackManager: boolean onlyStandardPacks()>
<soot.PackManager: java.util.Collection allPacks()>
<soot.PackManager: java.util.Iterator reachableClasses()>
<soot.PackManager: soot.HasPhaseOptions getPhase(java.lang.String)>
<soot.PackManager: soot.Pack getPack(java.lang.String)>
<soot.PackManager: soot.PackManager v()>
<soot.PackManager: soot.Transform getTransform(java.lang.String)>
<soot.PackManager: void <clinit>()>
<soot.PackManager: void <init>(soot.Singletons$Global)>
<soot.PackManager: void addPack(soot.Pack)>
<soot.PackManager: void handleInnerClasses()>
<soot.PackManager: void init()>
<soot.PackManager: void notifyAddPack()>
<soot.PackManager: void postProcessXML(java.util.Iterator)>
<soot.PackManager: void preProcessDAVA()>
<soot.PackManager: void releaseBodies(java.util.Iterator)>
<soot.PackManager: void releaseBodies(soot.SootClass)>
<soot.PackManager: void retrieveAllBodies()>
<soot.PackManager: void runBodyPacks()>
<soot.PackManager: void runBodyPacks(java.util.Iterator)>
<soot.PackManager: void runBodyPacks(soot.SootClass)>
<soot.PackManager: void runPacks()>
<soot.PackManager: void runWholeProgramPacks()>
<soot.PackManager: void writeClass(soot.SootClass)>
<soot.PackManager: void writeOutput()>
<soot.PackManager: void writeOutput(java.util.Iterator)>
<soot.PatchingChain$PatchingIterator: boolean hasNext()>
<soot.PatchingChain$PatchingIterator: java.lang.Object next()>
<soot.PatchingChain$PatchingIterator: void <init>(soot.PatchingChain,soot.util.Chain)>
<soot.PatchingChain$PatchingIterator: void <init>(soot.PatchingChain,soot.util.Chain,java.lang.Object)>
<soot.PatchingChain$PatchingIterator: void <init>(soot.PatchingChain,soot.util.Chain,java.lang.Object,java.lang.Object)>
<soot.PatchingChain$PatchingIterator: void remove()>
<soot.PatchingChain: boolean add(java.lang.Object)>
<soot.PatchingChain: boolean contains(java.lang.Object)>
<soot.PatchingChain: boolean remove(java.lang.Object)>
<soot.PatchingChain: int size()>
<soot.PatchingChain: java.lang.Object getFirst()>
<soot.PatchingChain: java.lang.Object getLast()>
<soot.PatchingChain: java.lang.Object getPredOf(java.lang.Object)>
<soot.PatchingChain: java.lang.Object getSuccOf(java.lang.Object)>
<soot.PatchingChain: java.util.Iterator iterator()>
<soot.PatchingChain: java.util.Iterator iterator(java.lang.Object)>
<soot.PatchingChain: java.util.Iterator iterator(java.lang.Object,java.lang.Object)>
<soot.PatchingChain: java.util.Iterator snapshotIterator()>
<soot.PatchingChain: soot.util.Chain getNonPatchingChain()>
<soot.PatchingChain: void <init>(soot.util.Chain)>
<soot.PatchingChain: void insertAfter(java.lang.Object,java.lang.Object)>
<soot.PatchingChain: void insertBefore(java.lang.Object,java.lang.Object)>
<soot.PatchingChain: void insertBeforeNoRedirect(java.lang.Object,java.lang.Object)>
<soot.PatchingChain: void swapWith(java.lang.Object,java.lang.Object)>
<soot.PhaseOptions: boolean checkParentEnabled(java.lang.String)>
<soot.PhaseOptions: boolean declaresOption(soot.HasPhaseOptions,java.lang.String)>
<soot.PhaseOptions: boolean getBoolean(java.util.Map,java.lang.String)>
<soot.PhaseOptions: boolean processPhaseOptions(java.lang.String,java.lang.String)>
<soot.PhaseOptions: boolean setPhaseOption(java.lang.String,java.lang.String)>
<soot.PhaseOptions: boolean setPhaseOption(soot.HasPhaseOptions,java.lang.String)>
<soot.PhaseOptions: int getInt(java.util.Map,java.lang.String)>
<soot.PhaseOptions: java.lang.String getKey(java.lang.String)>
<soot.PhaseOptions: java.lang.String getString(java.util.Map,java.lang.String)>
<soot.PhaseOptions: java.lang.String getValue(java.lang.String)>
<soot.PhaseOptions: java.util.Map getPhaseOptions(java.lang.String)>
<soot.PhaseOptions: java.util.Map getPhaseOptions(soot.HasPhaseOptions)>
<soot.PhaseOptions: java.util.Map mapForPhase(soot.HasPhaseOptions)>
<soot.PhaseOptions: soot.PackManager getPM()>
<soot.PhaseOptions: soot.PhaseOptions v()>
<soot.PhaseOptions: void <init>(soot.Singletons$Global)>
<soot.PhaseOptions: void resetRadioPack(java.lang.String)>
<soot.PhaseOptions: void setPackManager(soot.PackManager)>
<soot.PrimType: void <init>()>
<soot.RadioScenePack: void <init>(java.lang.String)>
<soot.RadioScenePack: void add(soot.Transform)>
<soot.RadioScenePack: void checkEnabled(soot.Transform)>
<soot.RadioScenePack: void internalApply()>
<soot.RefLikeType: void <init>()>
<soot.RefType: boolean equals(java.lang.Object)>
<soot.RefType: boolean hasSootClass()>
<soot.RefType: int hashCode()>
<soot.RefType: java.lang.String getClassName()>
<soot.RefType: java.lang.String toString()>
<soot.RefType: soot.AnySubType getAnySubType()>
<soot.RefType: soot.RefType v()>
<soot.RefType: soot.RefType v(java.lang.String)>
<soot.RefType: soot.SootClass getSootClass()>
<soot.RefType: void <init>(java.lang.String)>
<soot.RefType: void <init>(soot.Singletons$Global)>
<soot.RefType: void apply(soot.util.Switch)>
<soot.RefType: void setAnySubType(soot.AnySubType)>
<soot.RefType: void setSootClass(soot.SootClass)>
<soot.Scene: boolean allowsPhantomRefs()>
<soot.Scene: boolean containsClass(java.lang.String)>
<soot.Scene: boolean containsMethod(java.lang.String)>
<soot.Scene: boolean doneResolving()>
<soot.Scene: boolean getPhantomRefs()>
<soot.Scene: boolean hasCallGraph()>
<soot.Scene: boolean hasFastHierarchy()>
<soot.Scene: java.lang.String defaultClassPath()>
<soot.Scene: java.lang.String getSootClassPath()>
<soot.Scene: java.lang.String quotedNameOf(java.lang.String)>
<soot.Scene: java.lang.String signatureToClass(java.lang.String)>
<soot.Scene: java.lang.String signatureToSubsignature(java.lang.String)>
<soot.Scene: java.util.Collection dynamicClasses()>
<soot.Scene: java.util.List getClasses(int)>
<soot.Scene: java.util.List getEntryPoints()>
<soot.Scene: java.util.Set getReservedNames()>
<soot.Scene: soot.FastHierarchy getFastHierarchy()>
<soot.Scene: soot.FastHierarchy getOrMakeFastHierarchy()>
<soot.Scene: soot.RefType getRefType(java.lang.String)>
<soot.Scene: soot.Scene v()>
<soot.Scene: soot.SootClass getMainClass()>
<soot.Scene: soot.SootClass getSootClass(java.lang.String)>
<soot.Scene: soot.SootClass loadClass(java.lang.String,int)>
<soot.Scene: soot.SootClass loadClassAndSupport(java.lang.String)>
<soot.Scene: soot.SootClass tryLoadClass(java.lang.String,int)>
<soot.Scene: soot.SootFieldRef makeFieldRef(soot.SootClass,java.lang.String,soot.Type,boolean)>
<soot.Scene: soot.SootMethod getMethod(java.lang.String)>
<soot.Scene: soot.SootMethod grabMethod(java.lang.String)>
<soot.Scene: soot.SootMethodRef makeMethodRef(soot.SootClass,java.lang.String,java.util.List,soot.Type,boolean)>
<soot.Scene: soot.jimple.toolkits.callgraph.CallGraph getCallGraph()>
<soot.Scene: soot.jimple.toolkits.callgraph.ReachableMethods getReachableMethods()>
<soot.Scene: soot.toolkits.exceptions.ThrowAnalysis getDefaultThrowAnalysis()>
<soot.Scene: soot.util.ArrayNumberer getFieldNumberer()>
<soot.Scene: soot.util.ArrayNumberer getLocalNumberer()>
<soot.Scene: soot.util.ArrayNumberer getMethodNumberer()>
<soot.Scene: soot.util.ArrayNumberer getTypeNumberer()>
<soot.Scene: soot.util.Chain getApplicationClasses()>
<soot.Scene: soot.util.Chain getClasses()>
<soot.Scene: soot.util.Chain getContainingChain(soot.SootClass)>
<soot.Scene: soot.util.Chain getLibraryClasses()>
<soot.Scene: soot.util.Chain getPhantomClasses()>
<soot.Scene: soot.util.StringNumberer getSubSigNumberer()>
<soot.Scene: void <init>(soot.Singletons$Global)>
<soot.Scene: void addBasicClass(java.lang.String)>
<soot.Scene: void addBasicClass(java.lang.String,int)>
<soot.Scene: void addClass(soot.SootClass)>
<soot.Scene: void addRefType(soot.RefType)>
<soot.Scene: void addSootBasicClasses()>
<soot.Scene: void loadBasicClasses()>
<soot.Scene: void loadDynamicClasses()>
<soot.Scene: void loadNecessaryClass(java.lang.String)>
<soot.Scene: void loadNecessaryClasses()>
<soot.Scene: void modifyHierarchy()>
<soot.Scene: void prepareClasses()>
<soot.Scene: void setCallGraph(soot.jimple.toolkits.callgraph.CallGraph)>
<soot.Scene: void setDoneResolving()>
<soot.Scene: void setFastHierarchy(soot.FastHierarchy)>
<soot.Scene: void setMainClass(soot.SootClass)>
<soot.Scene: void setMainClassFromOptions()>
<soot.Scene: void setPhantomRefs(boolean)>
<soot.Scene: void setPointsToAnalysis(soot.PointsToAnalysis)>
<soot.Scene: void setReservedNames()>
<soot.ScenePack: void <init>(java.lang.String)>
<soot.ScenePack: void internalApply()>
<soot.SceneTransformer: void <init>()>
<soot.SceneTransformer: void transform(java.lang.String,java.util.Map)>
<soot.ShortType: boolean equals(java.lang.Object)>
<soot.ShortType: int hashCode()>
<soot.ShortType: java.lang.String toString()>
<soot.ShortType: soot.ShortType v()>
<soot.ShortType: void <init>(soot.Singletons$Global)>
<soot.Singletons$Global: void <init>(soot.Singletons)>
<soot.Singletons$Global: void <init>(soot.Singletons,soot.Singletons$1)>
<soot.Singletons: soot.BooleanType soot_BooleanType()>
<soot.Singletons: soot.ByteType soot_ByteType()>
<soot.Singletons: soot.CharType soot_CharType()>
<soot.Singletons: soot.DoubleType soot_DoubleType()>
<soot.Singletons: soot.EntryPoints soot_EntryPoints()>
<soot.Singletons: soot.ErroneousType soot_ErroneousType()>
<soot.Singletons: soot.FloatType soot_FloatType()>
<soot.Singletons: soot.IntType soot_IntType()>
<soot.Singletons: soot.LongType soot_LongType()>
<soot.Singletons: soot.Main soot_Main()>
<soot.Singletons: soot.NullType soot_NullType()>
<soot.Singletons: soot.PackManager soot_PackManager()>
<soot.Singletons: soot.PhaseOptions soot_PhaseOptions()>
<soot.Singletons: soot.RefType soot_RefType()>
<soot.Singletons: soot.Scene soot_Scene()>
<soot.Singletons: soot.ShortType soot_ShortType()>
<soot.Singletons: soot.SootResolver soot_SootResolver()>
<soot.Singletons: soot.SourceLocator soot_SourceLocator()>
<soot.Singletons: soot.StmtAddressType soot_StmtAddressType()>
<soot.Singletons: soot.Timers soot_Timers()>
<soot.Singletons: soot.UnknownType soot_UnknownType()>
<soot.Singletons: soot.VoidType soot_VoidType()>
<soot.Singletons: soot.baf.Baf soot_baf_Baf()>
<soot.Singletons: soot.baf.WordType soot_baf_WordType()>
<soot.Singletons: soot.baf.toolkits.base.LoadStoreOptimizer soot_baf_toolkits_base_LoadStoreOptimizer()>
<soot.Singletons: soot.baf.toolkits.base.PeepholeOptimizer soot_baf_toolkits_base_PeepholeOptimizer()>
<soot.Singletons: soot.coffi.CONSTANT_Utf8_collector soot_coffi_CONSTANT_Utf8_collector()>
<soot.Singletons: soot.coffi.Double2ndHalfType soot_coffi_Double2ndHalfType()>
<soot.Singletons: soot.coffi.Long2ndHalfType soot_coffi_Long2ndHalfType()>
<soot.Singletons: soot.coffi.Util soot_coffi_Util()>
<soot.Singletons: soot.grimp.toolkits.base.ConstructorFolder soot_grimp_toolkits_base_ConstructorFolder()>
<soot.Singletons: soot.jimple.Jimple soot_jimple_Jimple()>
<soot.Singletons: soot.jimple.NullConstant soot_jimple_NullConstant()>
<soot.Singletons: soot.jimple.paddle.PaddleHook soot_jimple_paddle_PaddleHook()>
<soot.Singletons: soot.jimple.spark.SparkTransformer soot_jimple_spark_SparkTransformer()>
<soot.Singletons: soot.jimple.spark.fieldrw.FieldTagAggregator soot_jimple_spark_fieldrw_FieldTagAggregator()>
<soot.Singletons: soot.jimple.spark.fieldrw.FieldTagger soot_jimple_spark_fieldrw_FieldTagger()>
<soot.Singletons: soot.jimple.spark.pag.ArrayElement soot_jimple_spark_pag_ArrayElement()>
<soot.Singletons: soot.jimple.spark.sets.EmptyPointsToSet soot_jimple_spark_sets_EmptyPointsToSet()>
<soot.Singletons: soot.jimple.toolkits.annotation.AvailExprTagger soot_jimple_toolkits_annotation_AvailExprTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.DominatorsTagger soot_jimple_toolkits_annotation_DominatorsTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.arraycheck.ArrayBoundsChecker soot_jimple_toolkits_annotation_arraycheck_ArrayBoundsChecker()>
<soot.Singletons: soot.jimple.toolkits.annotation.arraycheck.RectangularArrayFinder soot_jimple_toolkits_annotation_arraycheck_RectangularArrayFinder()>
<soot.Singletons: soot.jimple.toolkits.annotation.callgraph.CallGraphGrapher soot_jimple_toolkits_annotation_callgraph_CallGraphGrapher()>
<soot.Singletons: soot.jimple.toolkits.annotation.callgraph.CallGraphTagger soot_jimple_toolkits_annotation_callgraph_CallGraphTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.defs.ReachingDefsTagger soot_jimple_toolkits_annotation_defs_ReachingDefsTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.fields.UnreachableFieldsTagger soot_jimple_toolkits_annotation_fields_UnreachableFieldsTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.liveness.LiveVarsTagger soot_jimple_toolkits_annotation_liveness_LiveVarsTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.logic.LoopInvariantFinder soot_jimple_toolkits_annotation_logic_LoopInvariantFinder()>
<soot.Singletons: soot.jimple.toolkits.annotation.methods.UnreachableMethodsTagger soot_jimple_toolkits_annotation_methods_UnreachableMethodsTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.nullcheck.NullPointerChecker soot_jimple_toolkits_annotation_nullcheck_NullPointerChecker()>
<soot.Singletons: soot.jimple.toolkits.annotation.nullcheck.NullPointerColorer soot_jimple_toolkits_annotation_nullcheck_NullPointerColorer()>
<soot.Singletons: soot.jimple.toolkits.annotation.parity.ParityTagger soot_jimple_toolkits_annotation_parity_ParityTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.profiling.ProfilingGenerator soot_jimple_toolkits_annotation_profiling_ProfilingGenerator()>
<soot.Singletons: soot.jimple.toolkits.annotation.purity.PurityAnalysis soot_jimple_toolkits_annotation_purity_PurityAnalysis()>
<soot.Singletons: soot.jimple.toolkits.annotation.qualifiers.TightestQualifiersTagger soot_jimple_toolkits_annotation_qualifiers_TightestQualifiersTagger()>
<soot.Singletons: soot.jimple.toolkits.annotation.tags.ArrayNullTagAggregator soot_jimple_toolkits_annotation_tags_ArrayNullTagAggregator()>
<soot.Singletons: soot.jimple.toolkits.base.Aggregator soot_jimple_toolkits_base_Aggregator()>
<soot.Singletons: soot.jimple.toolkits.callgraph.CHATransformer soot_jimple_toolkits_callgraph_CHATransformer()>
<soot.Singletons: soot.jimple.toolkits.callgraph.VirtualCalls soot_jimple_toolkits_callgraph_VirtualCalls()>
<soot.Singletons: soot.jimple.toolkits.invoke.StaticInliner soot_jimple_toolkits_invoke_StaticInliner()>
<soot.Singletons: soot.jimple.toolkits.invoke.StaticMethodBinder soot_jimple_toolkits_invoke_StaticMethodBinder()>
<soot.Singletons: soot.jimple.toolkits.pointer.CastCheckEliminatorDumper soot_jimple_toolkits_pointer_CastCheckEliminatorDumper()>
<soot.Singletons: soot.jimple.toolkits.pointer.DependenceTagAggregator soot_jimple_toolkits_pointer_DependenceTagAggregator()>
<soot.Singletons: soot.jimple.toolkits.pointer.ParameterAliasTagger soot_jimple_toolkits_pointer_ParameterAliasTagger()>
<soot.Singletons: soot.jimple.toolkits.pointer.SideEffectTagger soot_jimple_toolkits_pointer_SideEffectTagger()>
<soot.Singletons: soot.jimple.toolkits.pointer.representations.Environment soot_jimple_toolkits_pointer_representations_Environment()>
<soot.Singletons: soot.jimple.toolkits.pointer.representations.TypeConstants soot_jimple_toolkits_pointer_representations_TypeConstants()>
<soot.Singletons: soot.jimple.toolkits.scalar.CommonSubexpressionEliminator soot_jimple_toolkits_scalar_CommonSubexpressionEliminator()>
<soot.Singletons: soot.jimple.toolkits.scalar.ConditionalBranchFolder soot_jimple_toolkits_scalar_ConditionalBranchFolder()>
<soot.Singletons: soot.jimple.toolkits.scalar.ConstantPropagatorAndFolder soot_jimple_toolkits_scalar_ConstantPropagatorAndFolder()>
<soot.Singletons: soot.jimple.toolkits.scalar.CopyPropagator soot_jimple_toolkits_scalar_CopyPropagator()>
<soot.Singletons: soot.jimple.toolkits.scalar.DeadAssignmentEliminator soot_jimple_toolkits_scalar_DeadAssignmentEliminator()>
<soot.Singletons: soot.jimple.toolkits.scalar.LocalNameStandardizer soot_jimple_toolkits_scalar_LocalNameStandardizer()>
<soot.Singletons: soot.jimple.toolkits.scalar.NopEliminator soot_jimple_toolkits_scalar_NopEliminator()>
<soot.Singletons: soot.jimple.toolkits.scalar.UnconditionalBranchFolder soot_jimple_toolkits_scalar_UnconditionalBranchFolder()>
<soot.Singletons: soot.jimple.toolkits.scalar.UnreachableCodeEliminator soot_jimple_toolkits_scalar_UnreachableCodeEliminator()>
<soot.Singletons: soot.jimple.toolkits.scalar.pre.BusyCodeMotion soot_jimple_toolkits_scalar_pre_BusyCodeMotion()>
<soot.Singletons: soot.jimple.toolkits.scalar.pre.LazyCodeMotion soot_jimple_toolkits_scalar_pre_LazyCodeMotion()>
<soot.Singletons: soot.jimple.toolkits.thread.synchronization.LockAllocator soot_jimple_toolkits_thread_synchronization_LockAllocator()>
<soot.Singletons: soot.jimple.toolkits.typing.TypeAssigner soot_jimple_toolkits_typing_TypeAssigner()>
<soot.Singletons: soot.jimple.toolkits.typing.integer.ClassHierarchy soot_jimple_toolkits_typing_integer_ClassHierarchy()>
<soot.Singletons: soot.options.Options soot_options_Options()>
<soot.Singletons: soot.shimple.toolkits.scalar.SConstantPropagatorAndFolder soot_shimple_toolkits_scalar_SConstantPropagatorAndFolder()>
<soot.Singletons: soot.tagkit.InnerClassTagAggregator soot_tagkit_InnerClassTagAggregator()>
<soot.Singletons: soot.tagkit.LineNumberTagAggregator soot_tagkit_LineNumberTagAggregator()>
<soot.Singletons: soot.toolkits.exceptions.PedanticThrowAnalysis soot_toolkits_exceptions_PedanticThrowAnalysis()>
<soot.Singletons: soot.toolkits.exceptions.ThrowableSet$Manager soot_toolkits_exceptions_ThrowableSet_Manager()>
<soot.Singletons: soot.toolkits.exceptions.TrapTightener soot_toolkits_exceptions_TrapTightener()>
<soot.Singletons: soot.toolkits.scalar.LocalPacker soot_toolkits_scalar_LocalPacker()>
<soot.Singletons: soot.toolkits.scalar.LocalSplitter soot_toolkits_scalar_LocalSplitter()>
<soot.Singletons: soot.toolkits.scalar.UnusedLocalEliminator soot_toolkits_scalar_UnusedLocalEliminator()>
<soot.Singletons: soot.util.PhaseDumper soot_util_PhaseDumper()>
<soot.Singletons: void <init>()>
<soot.SootClass: boolean containsBafBody()>
<soot.SootClass: boolean declaresField(java.lang.String)>
<soot.SootClass: boolean declaresField(java.lang.String,soot.Type)>
<soot.SootClass: boolean declaresMethod(java.lang.String)>
<soot.SootClass: boolean declaresMethod(java.lang.String,java.util.List,soot.Type)>
<soot.SootClass: boolean declaresMethod(soot.util.NumberedString)>
<soot.SootClass: boolean hasOuterClass()>
<soot.SootClass: boolean hasSuperclass()>
<soot.SootClass: boolean implementsInterface(java.lang.String)>
<soot.SootClass: boolean isAbstract()>
<soot.SootClass: boolean isApplicationClass()>
<soot.SootClass: boolean isConcrete()>
<soot.SootClass: boolean isInScene()>
<soot.SootClass: boolean isInterface()>
<soot.SootClass: boolean isLibraryClass()>
<soot.SootClass: boolean isPhantom()>
<soot.SootClass: boolean isPhantomClass()>
<soot.SootClass: int getFieldCount()>
<soot.SootClass: int getInterfaceCount()>
<soot.SootClass: int getModifiers()>
<soot.SootClass: int resolvingLevel()>
<soot.SootClass: java.lang.String getName()>
<soot.SootClass: java.util.Iterator methodIterator()>
<soot.SootClass: java.util.List getMethods()>
<soot.SootClass: soot.RefType getType()>
<soot.SootClass: soot.SootClass getSuperclass()>
<soot.SootClass: soot.SootField getField(java.lang.String,soot.Type)>
<soot.SootClass: soot.SootField getFieldByName(java.lang.String)>
<soot.SootClass: soot.SootMethod getMethod(java.lang.String)>
<soot.SootClass: soot.SootMethod getMethod(soot.util.NumberedString)>
<soot.SootClass: soot.util.Chain getFields()>
<soot.SootClass: soot.util.Chain getInterfaces()>
<soot.SootClass: void <init>(java.lang.String)>
<soot.SootClass: void <init>(java.lang.String,int)>
<soot.SootClass: void addField(soot.SootField)>
<soot.SootClass: void addInterface(soot.SootClass)>
<soot.SootClass: void addMethod(soot.SootMethod)>
<soot.SootClass: void checkLevel(int)>
<soot.SootClass: void setApplicationClass()>
<soot.SootClass: void setInScene(boolean)>
<soot.SootClass: void setLibraryClass()>
<soot.SootClass: void setModifiers(int)>
<soot.SootClass: void setName(java.lang.String)>
<soot.SootClass: void setResolvingLevel(int)>
<soot.SootClass: void setSuperclass(soot.SootClass)>
<soot.SootField: boolean isDeclared()>
<soot.SootField: boolean isStatic()>
<soot.SootField: int getModifiers()>
<soot.SootField: int getNumber()>
<soot.SootField: java.lang.String getName()>
<soot.SootField: java.lang.String getSubSignature()>
<soot.SootField: soot.SootClass getDeclaringClass()>
<soot.SootField: soot.Type getType()>
<soot.SootField: void <init>(java.lang.String,soot.Type,int)>
<soot.SootField: void setNumber(int)>
<soot.SootMethod: boolean hasActiveBody()>
<soot.SootMethod: boolean isAbstract()>
<soot.SootMethod: boolean isConcrete()>
<soot.SootMethod: boolean isDeclared()>
<soot.SootMethod: boolean isNative()>
<soot.SootMethod: boolean isPhantom()>
<soot.SootMethod: boolean isStatic()>
<soot.SootMethod: boolean throwsException(soot.SootClass)>
<soot.SootMethod: int getModifiers()>
<soot.SootMethod: int getNumber()>
<soot.SootMethod: int getParameterCount()>
<soot.SootMethod: java.lang.String getName()>
<soot.SootMethod: java.lang.String getSignature()>
<soot.SootMethod: java.lang.String getSignature(soot.SootClass,java.lang.String,java.util.List,soot.Type)>
<soot.SootMethod: java.lang.String getSubSignature()>
<soot.SootMethod: java.lang.String getSubSignature(java.lang.String,java.util.List,soot.Type)>
<soot.SootMethod: java.lang.String getSubSignatureImpl(java.lang.String,java.util.List,soot.Type)>
<soot.SootMethod: java.util.List getExceptions()>
<soot.SootMethod: java.util.List getParameterTypes()>
<soot.SootMethod: soot.Body getActiveBody()>
<soot.SootMethod: soot.Body getBodyFromMethodSource(java.lang.String)>
<soot.SootMethod: soot.Body retrieveActiveBody()>
<soot.SootMethod: soot.Context context()>
<soot.SootMethod: soot.SootClass getDeclaringClass()>
<soot.SootMethod: soot.SootMethod method()>
<soot.SootMethod: soot.SootMethodRef makeRef()>
<soot.SootMethod: soot.Type getParameterType(int)>
<soot.SootMethod: soot.Type getReturnType()>
<soot.SootMethod: soot.util.NumberedString getNumberedSubSignature()>
<soot.SootMethod: void <clinit>()>
<soot.SootMethod: void <init>(java.lang.String,java.util.List,soot.Type,int)>
<soot.SootMethod: void addException(soot.SootClass)>
<soot.SootMethod: void addExceptionIfAbsent(soot.SootClass)>
<soot.SootMethod: void releaseActiveBody()>
<soot.SootMethod: void setActiveBody(soot.Body)>
<soot.SootMethod: void setNumber(int)>
<soot.SootMethod: void setSource(soot.MethodSource)>
<soot.SootResolver$1: void <init>(soot.SootResolver)>
<soot.SootResolver: boolean resolveEverything()>
<soot.SootResolver: soot.SootClass makeClassRef(java.lang.String)>
<soot.SootResolver: soot.SootClass resolveClass(java.lang.String,int)>
<soot.SootResolver: soot.SootResolver v()>
<soot.SootResolver: void <init>(soot.Singletons$Global)>
<soot.SootResolver: void addToResolveWorklist(java.lang.String,int)>
<soot.SootResolver: void addToResolveWorklist(soot.SootClass,int)>
<soot.SootResolver: void addToResolveWorklist(soot.Type,int)>
<soot.SootResolver: void bringToBodies(soot.SootClass)>
<soot.SootResolver: void bringToHierarchy(soot.SootClass)>
<soot.SootResolver: void bringToSignatures(soot.SootClass)>
<soot.SootResolver: void processResolveWorklist()>
<soot.SootResolver: void reResolveHierarchy(soot.SootClass)>
<soot.SourceLocator$FoundFile: java.io.InputStream inputStream()>
<soot.SourceLocator$FoundFile: void <init>(java.io.File)>
<soot.SourceLocator$FoundFile: void <init>(java.util.zip.ZipFile,java.util.zip.ZipEntry)>
<soot.SourceLocator: boolean isJar(java.lang.String)>
<soot.SourceLocator: java.io.InputStream access$000(java.io.InputStream,long)>
<soot.SourceLocator: java.io.InputStream doJDKBugWorkaround(java.io.InputStream,long)>
<soot.SourceLocator: java.lang.String getExtensionFor(int)>
<soot.SourceLocator: java.lang.String getFileNameFor(soot.SootClass,int)>
<soot.SourceLocator: java.lang.String getOutputDir()>
<soot.SourceLocator: java.util.List explodeClassPath(java.lang.String)>
<soot.SourceLocator: soot.ClassSource getClassSource(java.lang.String)>
<soot.SourceLocator: soot.SourceLocator v()>
<soot.SourceLocator: soot.SourceLocator$FoundFile lookupInClassPath(java.lang.String)>
<soot.SourceLocator: soot.SourceLocator$FoundFile lookupInDir(java.lang.String,java.lang.String)>
<soot.SourceLocator: soot.SourceLocator$FoundFile lookupInJar(java.lang.String,java.lang.String)>
<soot.SourceLocator: void <init>(soot.Singletons$Global)>
<soot.SourceLocator: void setupClassProviders()>
<soot.StmtAddressType: soot.StmtAddressType v()>
<soot.StmtAddressType: void <init>(soot.Singletons$Global)>
<soot.Timer: void <init>()>
<soot.Timer: void <init>(java.lang.String)>
<soot.Timer: void end()>
<soot.Timer: void start()>
<soot.Timers: soot.Timers v()>
<soot.Timers: void <init>(soot.Singletons$Global)>
<soot.Transform: java.lang.String getDeclaredOptions()>
<soot.Transform: java.lang.String getDefaultOptions()>
<soot.Transform: java.lang.String getPhaseName()>
<soot.Transform: void <init>(java.lang.String,soot.Transformer)>
<soot.Transform: void apply()>
<soot.Transform: void apply(soot.Body)>
<soot.Transformer: void <init>()>
<soot.TrapManager: java.util.List getExceptionTypesOf(soot.Unit,soot.Body)>
<soot.Type: int getNumber()>
<soot.Type: soot.ArrayType getArrayType()>
<soot.Type: soot.ArrayType makeArrayType()>
<soot.Type: void <init>()>
<soot.Type: void setArrayType(soot.ArrayType)>
<soot.Type: void setNumber(int)>
<soot.TypeSwitch: java.lang.Object getResult()>
<soot.TypeSwitch: void <init>()>
<soot.TypeSwitch: void setResult(java.lang.Object)>
<soot.UnknownType: int hashCode()>
<soot.UnknownType: soot.UnknownType v()>
<soot.UnknownType: void <init>(soot.Singletons$Global)>
<soot.VoidType: boolean equals(java.lang.Object)>
<soot.VoidType: int hashCode()>
<soot.VoidType: java.lang.String toString()>
<soot.VoidType: soot.VoidType v()>
<soot.VoidType: void <init>(soot.Singletons$Global)>
<soot.VoidType: void apply(soot.util.Switch)>
<soot.baf.Baf: soot.Local newLocal(java.lang.String,soot.Type)>
<soot.baf.Baf: soot.ValueBox newIdentityRefBox(soot.Value)>
<soot.baf.Baf: soot.ValueBox newLocalBox(soot.Value)>
<soot.baf.Baf: soot.baf.Baf v()>
<soot.baf.Baf: soot.baf.BafBody newBody(soot.Body)>
<soot.baf.Baf: soot.baf.IdentityInst newIdentityInst(soot.Value,soot.Value)>
<soot.baf.Baf: soot.baf.LoadInst newLoadInst(soot.Type,soot.Local)>
<soot.baf.Baf: soot.baf.PushInst newPushInst(soot.jimple.Constant)>
<soot.baf.Baf: soot.baf.ReturnVoidInst newReturnVoidInst()>
<soot.baf.Baf: soot.baf.SpecialInvokeInst newSpecialInvokeInst(soot.SootMethodRef)>
<soot.baf.Baf: soot.baf.StaticGetInst newStaticGetInst(soot.SootFieldRef)>
<soot.baf.Baf: soot.baf.StaticInvokeInst newStaticInvokeInst(soot.SootMethodRef)>
<soot.baf.Baf: soot.baf.StoreInst newStoreInst(soot.Type,soot.Local)>
<soot.baf.Baf: soot.baf.VirtualInvokeInst newVirtualInvokeInst(soot.SootMethodRef)>
<soot.baf.Baf: soot.jimple.ParameterRef newParameterRef(soot.Type,int)>
<soot.baf.Baf: soot.jimple.ThisRef newThisRef(soot.RefType)>
<soot.baf.Baf: void <init>(soot.Singletons$Global)>
<soot.baf.BafBody: void <init>(soot.Body,java.util.Map)>
<soot.baf.JasminClass$1$3: void <init>(soot.baf.JasminClass$1,int)>
<soot.baf.JasminClass$1$3: void caseRefType(soot.RefType)>
<soot.baf.JasminClass$1: void <init>(soot.baf.JasminClass)>
<soot.baf.JasminClass$1: void caseIdentityInst(soot.baf.IdentityInst)>
<soot.baf.JasminClass$1: void caseLoadInst(soot.baf.LoadInst)>
<soot.baf.JasminClass$1: void casePushInst(soot.baf.PushInst)>
<soot.baf.JasminClass$1: void caseReturnVoidInst(soot.baf.ReturnVoidInst)>
<soot.baf.JasminClass$1: void caseSpecialInvokeInst(soot.baf.SpecialInvokeInst)>
<soot.baf.JasminClass$1: void caseStaticGetInst(soot.baf.StaticGetInst)>
<soot.baf.JasminClass$1: void caseStaticInvokeInst(soot.baf.StaticInvokeInst)>
<soot.baf.JasminClass$1: void caseVirtualInvokeInst(soot.baf.VirtualInvokeInst)>
<soot.baf.JasminClass: java.util.Map access$6700(soot.baf.JasminClass)>
<soot.baf.JasminClass: void <init>(soot.SootClass)>
<soot.baf.JasminClass: void access$000(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void access$2600(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void access$27700(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void access$28700(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void access$28800(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void access$29000(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void access$8600(soot.baf.JasminClass,java.lang.String)>
<soot.baf.JasminClass: void calculateLogicalStackHeightCheck(soot.toolkits.graph.Block)>
<soot.baf.JasminClass: void calculateStackHeight(soot.toolkits.graph.Block)>
<soot.baf.JasminClass: void emitInst(soot.baf.Inst)>
<soot.baf.JasminClass: void emitMethodBody(soot.SootMethod)>
<soot.baf.WordType: boolean equals(java.lang.Object)>
<soot.baf.WordType: int hashCode()>
<soot.baf.WordType: soot.baf.WordType v()>
<soot.baf.WordType: void <init>(soot.Singletons$Global)>
<soot.baf.internal.AbstractInst: boolean branches()>
<soot.baf.internal.AbstractInst: boolean fallsThrough()>
<soot.baf.internal.AbstractInst: void <init>()>
<soot.baf.internal.AbstractInvokeInst: int getInCount()>
<soot.baf.internal.AbstractInvokeInst: int getInMachineCount()>
<soot.baf.internal.AbstractInvokeInst: int getOutCount()>
<soot.baf.internal.AbstractInvokeInst: int getOutMachineCount()>
<soot.baf.internal.AbstractInvokeInst: soot.SootMethodRef getMethodRef()>
<soot.baf.internal.AbstractInvokeInst: void <init>()>
<soot.baf.internal.AbstractOpTypeInst: int getOutMachineCount()>
<soot.baf.internal.AbstractOpTypeInst: soot.Type getOpType()>
<soot.baf.internal.AbstractOpTypeInst: void <init>(soot.Type)>
<soot.baf.internal.BIdentityInst: int getInCount()>
<soot.baf.internal.BIdentityInst: int getInMachineCount()>
<soot.baf.internal.BIdentityInst: int getOutCount()>
<soot.baf.internal.BIdentityInst: int getOutMachineCount()>
<soot.baf.internal.BIdentityInst: java.util.List getDefBoxes()>
<soot.baf.internal.BIdentityInst: java.util.List getUseBoxes()>
<soot.baf.internal.BIdentityInst: soot.Value getLeftOp()>
<soot.baf.internal.BIdentityInst: soot.Value getRightOp()>
<soot.baf.internal.BIdentityInst: void <init>(soot.Value,soot.Value)>
<soot.baf.internal.BIdentityInst: void <init>(soot.ValueBox,soot.ValueBox)>
<soot.baf.internal.BIdentityInst: void apply(soot.util.Switch)>
<soot.baf.internal.BLoadInst: int getInCount()>
<soot.baf.internal.BLoadInst: int getInMachineCount()>
<soot.baf.internal.BLoadInst: int getOutCount()>
<soot.baf.internal.BLoadInst: java.util.List getUseBoxes()>
<soot.baf.internal.BLoadInst: soot.Local getLocal()>
<soot.baf.internal.BLoadInst: void <init>(soot.Type,soot.Local)>
<soot.baf.internal.BLoadInst: void apply(soot.util.Switch)>
<soot.baf.internal.BPushInst: int getInCount()>
<soot.baf.internal.BPushInst: int getInMachineCount()>
<soot.baf.internal.BPushInst: int getOutCount()>
<soot.baf.internal.BPushInst: int getOutMachineCount()>
<soot.baf.internal.BPushInst: soot.jimple.Constant getConstant()>
<soot.baf.internal.BPushInst: void <init>(soot.jimple.Constant)>
<soot.baf.internal.BPushInst: void apply(soot.util.Switch)>
<soot.baf.internal.BReturnVoidInst: boolean fallsThrough()>
<soot.baf.internal.BReturnVoidInst: int getInCount()>
<soot.baf.internal.BReturnVoidInst: int getInMachineCount()>
<soot.baf.internal.BReturnVoidInst: int getOutCount()>
<soot.baf.internal.BReturnVoidInst: int getOutMachineCount()>
<soot.baf.internal.BReturnVoidInst: void <init>()>
<soot.baf.internal.BReturnVoidInst: void apply(soot.util.Switch)>
<soot.baf.internal.BSpecialInvokeInst: int getInCount()>
<soot.baf.internal.BSpecialInvokeInst: int getInMachineCount()>
<soot.baf.internal.BSpecialInvokeInst: void <init>(soot.SootMethodRef)>
<soot.baf.internal.BSpecialInvokeInst: void apply(soot.util.Switch)>
<soot.baf.internal.BStaticGetInst: int getInCount()>
<soot.baf.internal.BStaticGetInst: int getInMachineCount()>
<soot.baf.internal.BStaticGetInst: int getOutCount()>
<soot.baf.internal.BStaticGetInst: int getOutMachineCount()>
<soot.baf.internal.BStaticGetInst: soot.SootFieldRef getFieldRef()>
<soot.baf.internal.BStaticGetInst: void <init>(soot.SootFieldRef)>
<soot.baf.internal.BStaticGetInst: void apply(soot.util.Switch)>
<soot.baf.internal.BStaticInvokeInst: int getInCount()>
<soot.baf.internal.BStaticInvokeInst: int getOutCount()>
<soot.baf.internal.BStaticInvokeInst: void <init>(soot.SootMethodRef)>
<soot.baf.internal.BStaticInvokeInst: void apply(soot.util.Switch)>
<soot.baf.internal.BStoreInst: java.util.List getDefBoxes()>
<soot.baf.internal.BStoreInst: void <init>(soot.Type,soot.Local)>
<soot.baf.internal.BVirtualInvokeInst: int getInCount()>
<soot.baf.internal.BVirtualInvokeInst: int getInMachineCount()>
<soot.baf.internal.BVirtualInvokeInst: void <init>(soot.SootMethodRef)>
<soot.baf.internal.BVirtualInvokeInst: void apply(soot.util.Switch)>
<soot.baf.internal.BafLocal: java.lang.Object clone()>
<soot.baf.internal.BafLocal: java.lang.String getName()>
<soot.baf.internal.BafLocal: java.util.List getUseBoxes()>
<soot.baf.internal.BafLocal: soot.Type getType()>
<soot.baf.internal.BafLocal: void <init>(java.lang.String,soot.Type)>
<soot.baf.internal.BafLocal: void setType(soot.Type)>
<soot.baf.internal.BafLocalBox: boolean canContainValue(soot.Value)>
<soot.baf.internal.BafLocalBox: void <init>(soot.Value)>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: int stackIndependent(soot.Unit,soot.Unit,soot.toolkits.graph.Block,int)>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: java.util.List buildStoreList()>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: soot.Body access$002(soot.baf.toolkits.base.LoadStoreOptimizer$Instance,soot.Body)>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: soot.util.Chain access$102(soot.baf.toolkits.base.LoadStoreOptimizer$Instance,soot.util.Chain)>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: void <init>(soot.baf.toolkits.base.LoadStoreOptimizer)>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: void buildUnitToBlockMap()>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: void computeLocalDefsAndLocalUsesInfo()>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: void go()>
<soot.baf.toolkits.base.LoadStoreOptimizer$Instance: void optimizeLoadStores()>
<soot.baf.toolkits.base.LoadStoreOptimizer: java.util.Map access$200(soot.baf.toolkits.base.LoadStoreOptimizer)>
<soot.baf.toolkits.base.LoadStoreOptimizer: soot.baf.toolkits.base.LoadStoreOptimizer v()>
<soot.baf.toolkits.base.LoadStoreOptimizer: void <init>(soot.Singletons$Global)>
<soot.baf.toolkits.base.LoadStoreOptimizer: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.baf.toolkits.base.PeepholeOptimizer: soot.baf.toolkits.base.PeepholeOptimizer v()>
<soot.baf.toolkits.base.PeepholeOptimizer: void <init>(soot.Singletons$Global)>
<soot.baf.toolkits.base.PeepholeOptimizer: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.coffi.BBQ: boolean isEmpty()>
<soot.coffi.BBQ: soot.coffi.BasicBlock pull()>
<soot.coffi.BBQ: void <init>()>
<soot.coffi.BBQ: void push(soot.coffi.BasicBlock)>
<soot.coffi.BasicBlock: soot.jimple.Stmt getHeadJStmt()>
<soot.coffi.BasicBlock: soot.jimple.Stmt getTailJStmt()>
<soot.coffi.BasicBlock: void <init>(soot.coffi.Instruction,soot.coffi.Instruction)>
<soot.coffi.ByteCode: soot.coffi.Instruction disassemble_bytecode(byte[],int)>
<soot.coffi.ByteCode: soot.coffi.Instruction locateInst(int)>
<soot.coffi.ByteCode: soot.coffi.Instruction locateInstr(int,int,int)>
<soot.coffi.ByteCode: void <init>()>
<soot.coffi.ByteCode: void build(soot.coffi.Instruction)>
<soot.coffi.CFG: boolean eliminateJsrRets()>
<soot.coffi.CFG: boolean findOutmostJsrs(soot.coffi.Instruction,soot.coffi.Instruction)>
<soot.coffi.CFG: boolean jimplify(soot.coffi.cp_info[],int,soot.jimple.JimpleBody)>
<soot.coffi.CFG: int typeSize(soot.Type)>
<soot.coffi.CFG: java.lang.String getClassName(soot.coffi.cp_info[],int)>
<soot.coffi.CFG: java.util.HashMap inliningJsrTargets()>
<soot.coffi.CFG: soot.Type byteCodeTypeOf(soot.Type)>
<soot.coffi.CFG: soot.Type jimpleReturnTypeOfInterfaceMethodRef(soot.Scene,soot.coffi.cp_info[],int)>
<soot.coffi.CFG: soot.Type jimpleReturnTypeOfMethodRef(soot.Scene,soot.coffi.cp_info[],int)>
<soot.coffi.CFG: soot.Type jimpleTypeOfAtype(int)>
<soot.coffi.CFG: soot.Type jimpleTypeOfFieldInFieldRef(soot.Scene,soot.coffi.cp_info[],int)>
<soot.coffi.CFG: soot.coffi.Instruction buildBasicBlock(soot.coffi.Instruction)>
<soot.coffi.CFG: soot.coffi.Instruction findMatchingRet(soot.coffi.Instruction,soot.coffi.Instruction,java.util.HashSet)>
<soot.coffi.CFG: soot.coffi.Instruction makeCopyOf(soot.coffi.Instruction,soot.coffi.Instruction,soot.coffi.Instruction)>
<soot.coffi.CFG: soot.coffi.OutFlow processCPEntry(soot.coffi.cp_info[],int,soot.coffi.TypeStack,soot.SootMethod)>
<soot.coffi.CFG: soot.coffi.OutFlow processFlow(soot.coffi.Instruction,soot.coffi.TypeStack,soot.coffi.cp_info[])>
<soot.coffi.CFG: soot.coffi.TypeStack popSafe(soot.coffi.TypeStack,soot.Type)>
<soot.coffi.CFG: soot.coffi.TypeStack popSafeRefType(soot.coffi.TypeStack)>
<soot.coffi.CFG: soot.coffi.TypeStack smartPush(soot.coffi.TypeStack,soot.Type)>
<soot.coffi.CFG: void <clinit>()>
<soot.coffi.CFG: void <init>(soot.coffi.method_info)>
<soot.coffi.CFG: void adjustBranchTargets()>
<soot.coffi.CFG: void adjustExceptionTable()>
<soot.coffi.CFG: void adjustLineNumberTable()>
<soot.coffi.CFG: void buildBBCFG()>
<soot.coffi.CFG: void buildInsnCFGfromBBCFG()>
<soot.coffi.CFG: void generateJimple(soot.coffi.Instruction,soot.coffi.TypeStack,soot.coffi.TypeStack,soot.coffi.cp_info[],java.util.List,soot.coffi.BasicBlock)>
<soot.coffi.CFG: void generateJimpleForCPEntry(soot.coffi.cp_info[],int,soot.coffi.TypeStack,soot.coffi.TypeStack,soot.SootMethod,java.util.List)>
<soot.coffi.CFG: void jimpleTargetFixup()>
<soot.coffi.CFG: void jimplify(soot.coffi.cp_info[],int)>
<soot.coffi.CFG: void processTargetFixup(soot.coffi.BBQ)>
<soot.coffi.CONSTANT_Class_info: java.lang.String toString(soot.coffi.cp_info[])>
<soot.coffi.CONSTANT_Class_info: void <init>()>
<soot.coffi.CONSTANT_Double_info: double convert()>
<soot.coffi.CONSTANT_Double_info: void <init>()>
<soot.coffi.CONSTANT_Fieldref_info: void <init>()>
<soot.coffi.CONSTANT_Float_info: float convert()>
<soot.coffi.CONSTANT_Float_info: void <init>()>
<soot.coffi.CONSTANT_Integer_info: void <init>()>
<soot.coffi.CONSTANT_InterfaceMethodref_info: void <init>()>
<soot.coffi.CONSTANT_Long_info: long convert()>
<soot.coffi.CONSTANT_Long_info: void <init>()>
<soot.coffi.CONSTANT_Methodref_info: void <init>()>
<soot.coffi.CONSTANT_NameAndType_info: void <init>()>
<soot.coffi.CONSTANT_String_info: java.lang.String toString(soot.coffi.cp_info[])>
<soot.coffi.CONSTANT_String_info: void <init>()>
<soot.coffi.CONSTANT_Utf8_collector: soot.coffi.CONSTANT_Utf8_collector v()>
<soot.coffi.CONSTANT_Utf8_collector: soot.coffi.CONSTANT_Utf8_info add(soot.coffi.CONSTANT_Utf8_info)>
<soot.coffi.CONSTANT_Utf8_collector: void <init>(soot.Singletons$Global)>
<soot.coffi.CONSTANT_Utf8_info: byte[] toUtf8(java.lang.String)>
<soot.coffi.CONSTANT_Utf8_info: java.lang.String convert()>
<soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(soot.coffi.cp_info[])>
<soot.coffi.CONSTANT_Utf8_info: void <init>(java.io.DataInputStream)>
<soot.coffi.CONSTANT_Utf8_info: void fixConversion(java.lang.String)>
<soot.coffi.ClassFile: boolean loadClassFile(java.io.InputStream)>
<soot.coffi.ClassFile: boolean readAttributes(java.io.DataInputStream,int,soot.coffi.attribute_info[])>
<soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>
<soot.coffi.ClassFile: boolean readConstantPool(java.io.DataInputStream)>
<soot.coffi.ClassFile: boolean readFields(java.io.DataInputStream)>
<soot.coffi.ClassFile: boolean readMethods(java.io.DataInputStream)>
<soot.coffi.ClassFile: java.lang.String parseDesc(java.lang.String,java.lang.String)>
<soot.coffi.ClassFile: java.lang.String parseMethodDesc_params(java.lang.String)>
<soot.coffi.ClassFile: soot.coffi.Instruction parseMethod(soot.coffi.method_info)>
<soot.coffi.ClassFile: soot.coffi.element_value[] readElementValues(int,java.io.DataInputStream,boolean,int)>
<soot.coffi.ClassFile: void <init>(java.lang.String)>
<soot.coffi.Code_attribute: soot.coffi.LocalVariableTable_attribute findLocalVariableTable()>
<soot.coffi.Code_attribute: soot.coffi.LocalVariableTypeTable_attribute findLocalVariableTypeTable()>
<soot.coffi.Code_attribute: void <init>()>
<soot.coffi.CoffiMethodSource: soot.Body getBody(soot.SootMethod,java.lang.String)>
<soot.coffi.CoffiMethodSource: void <init>(soot.coffi.ClassFile,soot.coffi.method_info)>
<soot.coffi.ConstantValue_attribute: void <init>()>
<soot.coffi.Deprecated_attribute: void <init>()>
<soot.coffi.Double2ndHalfType: soot.coffi.Double2ndHalfType v()>
<soot.coffi.Double2ndHalfType: void <init>(soot.Singletons$Global)>
<soot.coffi.EnclosingMethod_attribute: void <init>()>
<soot.coffi.Exception_attribute: void <init>()>
<soot.coffi.FutureStmt: void <init>()>
<soot.coffi.InnerClasses_attribute: void <init>()>
<soot.coffi.Instruction: int getInt(byte[],int)>
<soot.coffi.Instruction: int hashCode()>
<soot.coffi.Instruction: int nextOffset(int)>
<soot.coffi.Instruction: java.lang.Object clone()>
<soot.coffi.Instruction: short getShort(byte[],int)>
<soot.coffi.Instruction: soot.coffi.Instruction[] branchpoints(soot.coffi.Instruction)>
<soot.coffi.Instruction: void <init>(byte)>
<soot.coffi.Instruction: void offsetToPointer(soot.coffi.ByteCode)>
<soot.coffi.Instruction_Aaload: void <init>()>
<soot.coffi.Instruction_Aastore: void <init>()>
<soot.coffi.Instruction_Aconst_null: void <init>()>
<soot.coffi.Instruction_Aload: void <init>()>
<soot.coffi.Instruction_Aload_0: void <init>()>
<soot.coffi.Instruction_Aload_1: void <init>()>
<soot.coffi.Instruction_Aload_2: void <init>()>
<soot.coffi.Instruction_Aload_3: void <init>()>
<soot.coffi.Instruction_Anewarray: void <init>()>
<soot.coffi.Instruction_Areturn: void <init>()>
<soot.coffi.Instruction_Arraylength: void <init>()>
<soot.coffi.Instruction_Astore: int getLocalNumber()>
<soot.coffi.Instruction_Astore: void <init>()>
<soot.coffi.Instruction_Astore_0: void <init>()>
<soot.coffi.Instruction_Astore_1: void <init>()>
<soot.coffi.Instruction_Astore_2: int getLocalNumber()>
<soot.coffi.Instruction_Astore_2: void <init>()>
<soot.coffi.Instruction_Astore_3: int getLocalNumber()>
<soot.coffi.Instruction_Astore_3: void <init>()>
<soot.coffi.Instruction_Athrow: void <init>()>
<soot.coffi.Instruction_Baload: void <init>()>
<soot.coffi.Instruction_Bastore: void <init>()>
<soot.coffi.Instruction_Bipush: void <init>()>
<soot.coffi.Instruction_Caload: void <init>()>
<soot.coffi.Instruction_Castore: void <init>()>
<soot.coffi.Instruction_Checkcast: void <init>()>
<soot.coffi.Instruction_D2i: void <init>()>
<soot.coffi.Instruction_D2l: void <init>()>
<soot.coffi.Instruction_Dadd: void <init>()>
<soot.coffi.Instruction_Daload: void <init>()>
<soot.coffi.Instruction_Dastore: void <init>()>
<soot.coffi.Instruction_Dcmpg: void <init>()>
<soot.coffi.Instruction_Dcmpl: void <init>()>
<soot.coffi.Instruction_Dconst_0: void <init>()>
<soot.coffi.Instruction_Dconst_1: void <init>()>
<soot.coffi.Instruction_Ddiv: void <init>()>
<soot.coffi.Instruction_Dload: void <init>()>
<soot.coffi.Instruction_Dload_0: void <init>()>
<soot.coffi.Instruction_Dload_1: void <init>()>
<soot.coffi.Instruction_Dload_2: void <init>()>
<soot.coffi.Instruction_Dload_3: void <init>()>
<soot.coffi.Instruction_Dmul: void <init>()>
<soot.coffi.Instruction_Dneg: void <init>()>
<soot.coffi.Instruction_Dreturn: void <init>()>
<soot.coffi.Instruction_Dstore: void <init>()>
<soot.coffi.Instruction_Dstore_0: void <init>()>
<soot.coffi.Instruction_Dstore_1: void <init>()>
<soot.coffi.Instruction_Dstore_3: void <init>()>
<soot.coffi.Instruction_Dsub: void <init>()>
<soot.coffi.Instruction_Dup2: void <init>()>
<soot.coffi.Instruction_Dup2_x1: void <init>()>
<soot.coffi.Instruction_Dup: void <init>()>
<soot.coffi.Instruction_Dup_x1: void <init>()>
<soot.coffi.Instruction_Dup_x2: void <init>()>
<soot.coffi.Instruction_F2d: void <init>()>
<soot.coffi.Instruction_F2i: void <init>()>
<soot.coffi.Instruction_F2l: void <init>()>
<soot.coffi.Instruction_Fadd: void <init>()>
<soot.coffi.Instruction_Faload: void <init>()>
<soot.coffi.Instruction_Fastore: void <init>()>
<soot.coffi.Instruction_Fcmpg: void <init>()>
<soot.coffi.Instruction_Fcmpl: void <init>()>
<soot.coffi.Instruction_Fconst_0: void <init>()>
<soot.coffi.Instruction_Fconst_1: void <init>()>
<soot.coffi.Instruction_Fdiv: void <init>()>
<soot.coffi.Instruction_Fload: void <init>()>
<soot.coffi.Instruction_Fload_0: void <init>()>
<soot.coffi.Instruction_Fload_1: void <init>()>
<soot.coffi.Instruction_Fload_2: void <init>()>
<soot.coffi.Instruction_Fload_3: void <init>()>
<soot.coffi.Instruction_Fmul: void <init>()>
<soot.coffi.Instruction_Fneg: void <init>()>
<soot.coffi.Instruction_Freturn: void <init>()>
<soot.coffi.Instruction_Fstore: void <init>()>
<soot.coffi.Instruction_Getfield: void <init>()>
<soot.coffi.Instruction_Getstatic: void <init>()>
<soot.coffi.Instruction_Goto: soot.coffi.Instruction[] branchpoints(soot.coffi.Instruction)>
<soot.coffi.Instruction_Goto: void <init>()>
<soot.coffi.Instruction_I2d: void <init>()>
<soot.coffi.Instruction_I2f: void <init>()>
<soot.coffi.Instruction_I2l: void <init>()>
<soot.coffi.Instruction_Iadd: void <init>()>
<soot.coffi.Instruction_Iaload: void <init>()>
<soot.coffi.Instruction_Iand: void <init>()>
<soot.coffi.Instruction_Iastore: void <init>()>
<soot.coffi.Instruction_Iconst_0: void <init>()>
<soot.coffi.Instruction_Iconst_1: void <init>()>
<soot.coffi.Instruction_Iconst_2: void <init>()>
<soot.coffi.Instruction_Iconst_3: void <init>()>
<soot.coffi.Instruction_Iconst_4: void <init>()>
<soot.coffi.Instruction_Iconst_5: void <init>()>
<soot.coffi.Instruction_Iconst_m1: void <init>()>
<soot.coffi.Instruction_Idiv: void <init>()>
<soot.coffi.Instruction_If_acmpeq: void <init>()>
<soot.coffi.Instruction_If_acmpne: void <init>()>
<soot.coffi.Instruction_If_icmpeq: void <init>()>
<soot.coffi.Instruction_If_icmpge: void <init>()>
<soot.coffi.Instruction_If_icmpgt: void <init>()>
<soot.coffi.Instruction_If_icmple: void <init>()>
<soot.coffi.Instruction_If_icmplt: void <init>()>
<soot.coffi.Instruction_If_icmpne: void <init>()>
<soot.coffi.Instruction_Ifeq: void <init>()>
<soot.coffi.Instruction_Ifge: void <init>()>
<soot.coffi.Instruction_Ifgt: void <init>()>
<soot.coffi.Instruction_Ifle: void <init>()>
<soot.coffi.Instruction_Iflt: void <init>()>
<soot.coffi.Instruction_Ifne: void <init>()>
<soot.coffi.Instruction_Ifnonnull: void <init>()>
<soot.coffi.Instruction_Ifnull: void <init>()>
<soot.coffi.Instruction_Iinc: int nextOffset(int)>
<soot.coffi.Instruction_Iinc: int parse(byte[],int)>
<soot.coffi.Instruction_Iinc: void <init>()>
<soot.coffi.Instruction_Iload: void <init>()>
<soot.coffi.Instruction_Iload_0: void <init>()>
<soot.coffi.Instruction_Iload_1: void <init>()>
<soot.coffi.Instruction_Iload_2: void <init>()>
<soot.coffi.Instruction_Iload_3: void <init>()>
<soot.coffi.Instruction_Imul: void <init>()>
<soot.coffi.Instruction_Ineg: void <init>()>
<soot.coffi.Instruction_Instanceof: void <init>()>
<soot.coffi.Instruction_Int2byte: void <init>()>
<soot.coffi.Instruction_Int2char: void <init>()>
<soot.coffi.Instruction_Int2short: void <init>()>
<soot.coffi.Instruction_Invokeinterface: int nextOffset(int)>
<soot.coffi.Instruction_Invokeinterface: int parse(byte[],int)>
<soot.coffi.Instruction_Invokeinterface: void <init>()>
<soot.coffi.Instruction_Invokenonvirtual: void <init>()>
<soot.coffi.Instruction_Invokestatic: void <init>()>
<soot.coffi.Instruction_Invokevirtual: void <init>()>
<soot.coffi.Instruction_Ior: void <init>()>
<soot.coffi.Instruction_Irem: void <init>()>
<soot.coffi.Instruction_Ireturn: void <init>()>
<soot.coffi.Instruction_Ishl: void <init>()>
<soot.coffi.Instruction_Ishr: void <init>()>
<soot.coffi.Instruction_Istore: void <init>()>
<soot.coffi.Instruction_Istore_0: void <init>()>
<soot.coffi.Instruction_Istore_1: void <init>()>
<soot.coffi.Instruction_Istore_2: void <init>()>
<soot.coffi.Instruction_Istore_3: void <init>()>
<soot.coffi.Instruction_Isub: void <init>()>
<soot.coffi.Instruction_Iushr: void <init>()>
<soot.coffi.Instruction_Ixor: void <init>()>
<soot.coffi.Instruction_Jsr: void <init>()>
<soot.coffi.Instruction_L2d: void <init>()>
<soot.coffi.Instruction_L2i: void <init>()>
<soot.coffi.Instruction_Ladd: void <init>()>
<soot.coffi.Instruction_Laload: void <init>()>
<soot.coffi.Instruction_Land: void <init>()>
<soot.coffi.Instruction_Lastore: void <init>()>
<soot.coffi.Instruction_Lcmp: void <init>()>
<soot.coffi.Instruction_Lconst_0: void <init>()>
<soot.coffi.Instruction_Lconst_1: void <init>()>
<soot.coffi.Instruction_Ldc1: void <init>()>
<soot.coffi.Instruction_Ldc2: void <init>()>
<soot.coffi.Instruction_Ldc2w: void <init>()>
<soot.coffi.Instruction_Ldiv: void <init>()>
<soot.coffi.Instruction_Lload: void <init>()>
<soot.coffi.Instruction_Lload_0: void <init>()>
<soot.coffi.Instruction_Lload_1: void <init>()>
<soot.coffi.Instruction_Lload_2: void <init>()>
<soot.coffi.Instruction_Lload_3: void <init>()>
<soot.coffi.Instruction_Lmul: void <init>()>
<soot.coffi.Instruction_Lneg: void <init>()>
<soot.coffi.Instruction_Lookupswitch: int nextOffset(int)>
<soot.coffi.Instruction_Lookupswitch: int parse(byte[],int)>
<soot.coffi.Instruction_Lookupswitch: soot.coffi.Instruction[] branchpoints(soot.coffi.Instruction)>
<soot.coffi.Instruction_Lookupswitch: void <init>()>
<soot.coffi.Instruction_Lookupswitch: void offsetToPointer(soot.coffi.ByteCode)>
<soot.coffi.Instruction_Lor: void <init>()>
<soot.coffi.Instruction_Lrem: void <init>()>
<soot.coffi.Instruction_Lreturn: void <init>()>
<soot.coffi.Instruction_Lshl: void <init>()>
<soot.coffi.Instruction_Lshr: void <init>()>
<soot.coffi.Instruction_Lstore: void <init>()>
<soot.coffi.Instruction_Lstore_0: void <init>()>
<soot.coffi.Instruction_Lstore_1: void <init>()>
<soot.coffi.Instruction_Lstore_2: void <init>()>
<soot.coffi.Instruction_Lstore_3: void <init>()>
<soot.coffi.Instruction_Lsub: void <init>()>
<soot.coffi.Instruction_Lushr: void <init>()>
<soot.coffi.Instruction_Lxor: void <init>()>
<soot.coffi.Instruction_Monitorenter: void <init>()>
<soot.coffi.Instruction_Monitorexit: void <init>()>
<soot.coffi.Instruction_Multianewarray: int nextOffset(int)>
<soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>
<soot.coffi.Instruction_Multianewarray: void <init>()>
<soot.coffi.Instruction_New: void <init>()>
<soot.coffi.Instruction_Newarray: int nextOffset(int)>
<soot.coffi.Instruction_Newarray: int parse(byte[],int)>
<soot.coffi.Instruction_Newarray: void <init>()>
<soot.coffi.Instruction_Nop: void <init>()>
<soot.coffi.Instruction_Pop2: void <init>()>
<soot.coffi.Instruction_Pop: void <init>()>
<soot.coffi.Instruction_Putfield: void <init>()>
<soot.coffi.Instruction_Putstatic: void <init>()>
<soot.coffi.Instruction_Ret: void <init>()>
<soot.coffi.Instruction_Return: void <init>()>
<soot.coffi.Instruction_Saload: void <init>()>
<soot.coffi.Instruction_Sastore: void <init>()>
<soot.coffi.Instruction_Sipush: void <init>()>
<soot.coffi.Instruction_Tableswitch: int nextOffset(int)>
<soot.coffi.Instruction_Tableswitch: int parse(byte[],int)>
<soot.coffi.Instruction_Tableswitch: soot.coffi.Instruction[] branchpoints(soot.coffi.Instruction)>
<soot.coffi.Instruction_Tableswitch: void <init>()>
<soot.coffi.Instruction_Tableswitch: void offsetToPointer(soot.coffi.ByteCode)>
<soot.coffi.Instruction_branch: soot.coffi.Instruction[] branchpoints(soot.coffi.Instruction)>
<soot.coffi.Instruction_branch: void <init>(byte)>
<soot.coffi.Instruction_branch: void offsetToPointer(soot.coffi.ByteCode)>
<soot.coffi.Instruction_byte: int nextOffset(int)>
<soot.coffi.Instruction_byte: int parse(byte[],int)>
<soot.coffi.Instruction_byte: void <init>(byte)>
<soot.coffi.Instruction_byteindex: int nextOffset(int)>
<soot.coffi.Instruction_byteindex: int parse(byte[],int)>
<soot.coffi.Instruction_byteindex: void <init>(byte)>
<soot.coffi.Instruction_bytevar: int getIntArg()>
<soot.coffi.Instruction_bytevar: int nextOffset(int)>
<soot.coffi.Instruction_bytevar: int parse(byte[],int)>
<soot.coffi.Instruction_bytevar: void <init>(byte)>
<soot.coffi.Instruction_int: int nextOffset(int)>
<soot.coffi.Instruction_int: int parse(byte[],int)>
<soot.coffi.Instruction_int: void <init>(byte)>
<soot.coffi.Instruction_intbranch: int nextOffset(int)>
<soot.coffi.Instruction_intbranch: int parse(byte[],int)>
<soot.coffi.Instruction_intbranch: void <init>(byte)>
<soot.coffi.Instruction_intindex: int nextOffset(int)>
<soot.coffi.Instruction_intindex: int parse(byte[],int)>
<soot.coffi.Instruction_intindex: void <init>(byte)>
<soot.coffi.Instruction_noargs: int parse(byte[],int)>
<soot.coffi.Instruction_noargs: void <init>(byte)>
<soot.coffi.LineNumberTable_attribute: void <init>()>
<soot.coffi.Long2ndHalfType: soot.coffi.Long2ndHalfType v()>
<soot.coffi.Long2ndHalfType: void <init>(soot.Singletons$Global)>
<soot.coffi.OutFlow: void <init>(soot.coffi.TypeStack)>
<soot.coffi.RuntimeVisibleAnnotations_attribute: void <init>()>
<soot.coffi.Signature_attribute: void <init>()>
<soot.coffi.SourceFile_attribute: void <init>()>
<soot.coffi.TypeStack: boolean equals(java.lang.Object)>
<soot.coffi.TypeStack: int topIndex()>
<soot.coffi.TypeStack: soot.Type get(int)>
<soot.coffi.TypeStack: soot.Type top()>
<soot.coffi.TypeStack: soot.coffi.TypeStack merge(soot.coffi.TypeStack)>
<soot.coffi.TypeStack: soot.coffi.TypeStack pop()>
<soot.coffi.TypeStack: soot.coffi.TypeStack push(soot.Type)>
<soot.coffi.TypeStack: soot.coffi.TypeStack v()>
<soot.coffi.TypeStack: void <init>()>
<soot.coffi.Utf8_Enumeration: void <init>()>
<soot.coffi.Util: boolean declaresLocal(soot.Body,java.lang.String)>
<soot.coffi.Util: java.util.ArrayList createElementTags(int,soot.coffi.ClassFile,soot.coffi.element_value[])>
<soot.coffi.Util: soot.Local getLocal(soot.Body,java.lang.String)>
<soot.coffi.Util: soot.Local getLocalCreatingIfNecessary(soot.jimple.JimpleBody,java.lang.String,soot.Type)>
<soot.coffi.Util: soot.Local getLocalForIndex(soot.jimple.JimpleBody,int)>
<soot.coffi.Util: soot.Local getLocalForStackOp(soot.jimple.JimpleBody,soot.coffi.TypeStack,int)>
<soot.coffi.Util: soot.Type jimpleReturnTypeOfMethodDescriptor(java.lang.String)>
<soot.coffi.Util: soot.Type jimpleTypeOfFieldDescriptor(java.lang.String)>
<soot.coffi.Util: soot.Type[] jimpleTypesOfFieldOrMethodDescriptor(java.lang.String)>
<soot.coffi.Util: soot.coffi.Util v()>
<soot.coffi.Util: void <init>(soot.Singletons$Global)>
<soot.coffi.Util: void addAnnotationVisibilityAttribute(soot.tagkit.Host,soot.coffi.attribute_info,soot.coffi.ClassFile,java.util.List)>
<soot.coffi.Util: void addAnnotations(int,soot.coffi.annotation[],soot.coffi.ClassFile,soot.tagkit.VisibilityAnnotationTag,java.util.List)>
<soot.coffi.Util: void resetEasyNames()>
<soot.coffi.Util: void resolveFromClassFile(soot.SootClass,java.io.InputStream,java.util.List)>
<soot.coffi.Util: void setClassNameToAbbreviation(java.util.Map)>
<soot.coffi.annotation: void <init>()>
<soot.coffi.array_element_value: void <init>()>
<soot.coffi.attribute_info: void <init>()>
<soot.coffi.cp_info: int countParams(soot.coffi.cp_info[],int)>
<soot.coffi.cp_info: java.lang.String getTypeDescr(soot.coffi.cp_info[],int)>
<soot.coffi.cp_info: long ints2long(long,long)>
<soot.coffi.cp_info: void <init>()>
<soot.coffi.element_value: void <init>()>
<soot.coffi.enum_constant_element_value: void <init>()>
<soot.coffi.exception_table_entry: void <init>()>
<soot.coffi.field_info: void <init>()>
<soot.coffi.inner_class_entry: void <init>()>
<soot.coffi.line_number_table_entry: void <init>()>
<soot.coffi.method_info: soot.coffi.Code_attribute locate_code_attribute()>
<soot.coffi.method_info: void <init>()>
<soot.grimp.toolkits.base.ConstructorFolder: soot.grimp.toolkits.base.ConstructorFolder v()>
<soot.grimp.toolkits.base.ConstructorFolder: void <init>(soot.Singletons$Global)>
<soot.javaToJimple.IInitialResolver$Dependencies: void <init>()>
<soot.jbco.Main: void <clinit>()>
<soot.jimple.AbstractJimpleValueSwitch: java.lang.Object getResult()>
<soot.jimple.AbstractJimpleValueSwitch: void <init>()>
<soot.jimple.AbstractJimpleValueSwitch: void setResult(java.lang.Object)>
<soot.jimple.AbstractStmtSwitch: void <init>()>
<soot.jimple.AbstractStmtSwitch: void caseEnterMonitorStmt(soot.jimple.EnterMonitorStmt)>
<soot.jimple.AbstractStmtSwitch: void caseExitMonitorStmt(soot.jimple.ExitMonitorStmt)>
<soot.jimple.AbstractStmtSwitch: void caseGotoStmt(soot.jimple.GotoStmt)>
<soot.jimple.AbstractStmtSwitch: void caseIfStmt(soot.jimple.IfStmt)>
<soot.jimple.AbstractStmtSwitch: void caseLookupSwitchStmt(soot.jimple.LookupSwitchStmt)>
<soot.jimple.AbstractStmtSwitch: void caseReturnVoidStmt(soot.jimple.ReturnVoidStmt)>
<soot.jimple.AbstractStmtSwitch: void caseTableSwitchStmt(soot.jimple.TableSwitchStmt)>
<soot.jimple.AbstractStmtSwitch: void defaultCase(java.lang.Object)>
<soot.jimple.ArithmeticConstant: void <init>()>
<soot.jimple.ClassConstant: boolean equals(java.lang.Object)>
<soot.jimple.ClassConstant: int hashCode()>
<soot.jimple.ClassConstant: soot.Type getType()>
<soot.jimple.ClassConstant: soot.jimple.ClassConstant v(java.lang.String)>
<soot.jimple.ClassConstant: void <init>(java.lang.String)>
<soot.jimple.ClassConstant: void apply(soot.util.Switch)>
<soot.jimple.Constant: java.util.List getUseBoxes()>
<soot.jimple.Constant: void <init>()>
<soot.jimple.Constant: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.DoubleConstant: soot.Type getType()>
<soot.jimple.DoubleConstant: soot.jimple.DoubleConstant v(double)>
<soot.jimple.DoubleConstant: void <init>(double)>
<soot.jimple.FloatConstant: soot.Type getType()>
<soot.jimple.FloatConstant: soot.jimple.FloatConstant v(float)>
<soot.jimple.FloatConstant: void <init>(float)>
<soot.jimple.GroupIntPair: int hashCode()>
<soot.jimple.GroupIntPair: void <init>(java.lang.Object,int)>
<soot.jimple.IntConstant: soot.Type getType()>
<soot.jimple.IntConstant: soot.jimple.IntConstant v(int)>
<soot.jimple.IntConstant: void <init>(int)>
<soot.jimple.Jimple: soot.Local newLocal(java.lang.String,soot.Type)>
<soot.jimple.Jimple: soot.Trap newTrap(soot.SootClass,soot.Unit,soot.Unit,soot.Unit)>
<soot.jimple.Jimple: soot.UnitBox newStmtBox(soot.Unit)>
<soot.jimple.Jimple: soot.ValueBox newArgBox(soot.Value)>
<soot.jimple.Jimple: soot.ValueBox newConditionExprBox(soot.Value)>
<soot.jimple.Jimple: soot.ValueBox newIdentityRefBox(soot.Value)>
<soot.jimple.Jimple: soot.ValueBox newImmediateBox(soot.Value)>
<soot.jimple.Jimple: soot.ValueBox newInvokeExprBox(soot.Value)>
<soot.jimple.Jimple: soot.ValueBox newLocalBox(soot.Value)>
<soot.jimple.Jimple: soot.jimple.AddExpr newAddExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.AndExpr newAndExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.ArrayRef newArrayRef(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.AssignStmt newAssignStmt(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.CastExpr newCastExpr(soot.Value,soot.Type)>
<soot.jimple.Jimple: soot.jimple.CaughtExceptionRef newCaughtExceptionRef()>
<soot.jimple.Jimple: soot.jimple.CmpExpr newCmpExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.CmpgExpr newCmpgExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.CmplExpr newCmplExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.DivExpr newDivExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.EnterMonitorStmt newEnterMonitorStmt(soot.Value)>
<soot.jimple.Jimple: soot.jimple.EqExpr newEqExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.ExitMonitorStmt newExitMonitorStmt(soot.Value)>
<soot.jimple.Jimple: soot.jimple.GeExpr newGeExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.GotoStmt newGotoStmt(soot.Unit)>
<soot.jimple.Jimple: soot.jimple.GtExpr newGtExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.IdentityStmt newIdentityStmt(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.IfStmt newIfStmt(soot.Value,soot.Unit)>
<soot.jimple.Jimple: soot.jimple.InstanceFieldRef newInstanceFieldRef(soot.Value,soot.SootFieldRef)>
<soot.jimple.Jimple: soot.jimple.InstanceOfExpr newInstanceOfExpr(soot.Value,soot.Type)>
<soot.jimple.Jimple: soot.jimple.InterfaceInvokeExpr newInterfaceInvokeExpr(soot.Local,soot.SootMethodRef,java.util.List)>
<soot.jimple.Jimple: soot.jimple.InvokeStmt newInvokeStmt(soot.Value)>
<soot.jimple.Jimple: soot.jimple.Jimple v()>
<soot.jimple.Jimple: soot.jimple.JimpleBody newBody(soot.SootMethod)>
<soot.jimple.Jimple: soot.jimple.LeExpr newLeExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.LengthExpr newLengthExpr(soot.Value)>
<soot.jimple.Jimple: soot.jimple.LookupSwitchStmt newLookupSwitchStmt(soot.Value,java.util.List,java.util.List,soot.Unit)>
<soot.jimple.Jimple: soot.jimple.LtExpr newLtExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.MulExpr newMulExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.NeExpr newNeExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.NegExpr newNegExpr(soot.Value)>
<soot.jimple.Jimple: soot.jimple.NewArrayExpr newNewArrayExpr(soot.Type,soot.Value)>
<soot.jimple.Jimple: soot.jimple.NewExpr newNewExpr(soot.RefType)>
<soot.jimple.Jimple: soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(soot.ArrayType,java.util.List)>
<soot.jimple.Jimple: soot.jimple.NopStmt newNopStmt()>
<soot.jimple.Jimple: soot.jimple.OrExpr newOrExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.ParameterRef newParameterRef(soot.Type,int)>
<soot.jimple.Jimple: soot.jimple.RemExpr newRemExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.ReturnStmt newReturnStmt(soot.Value)>
<soot.jimple.Jimple: soot.jimple.ReturnVoidStmt newReturnVoidStmt()>
<soot.jimple.Jimple: soot.jimple.ShlExpr newShlExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.ShrExpr newShrExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.SpecialInvokeExpr newSpecialInvokeExpr(soot.Local,soot.SootMethodRef,java.util.List)>
<soot.jimple.Jimple: soot.jimple.StaticFieldRef newStaticFieldRef(soot.SootFieldRef)>
<soot.jimple.Jimple: soot.jimple.StaticInvokeExpr newStaticInvokeExpr(soot.SootMethodRef,java.util.List)>
<soot.jimple.Jimple: soot.jimple.SubExpr newSubExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.TableSwitchStmt newTableSwitchStmt(soot.Value,int,int,java.util.List,soot.Unit)>
<soot.jimple.Jimple: soot.jimple.ThisRef newThisRef(soot.RefType)>
<soot.jimple.Jimple: soot.jimple.ThrowStmt newThrowStmt(soot.Value)>
<soot.jimple.Jimple: soot.jimple.UshrExpr newUshrExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(soot.Local,soot.SootMethodRef,java.util.List)>
<soot.jimple.Jimple: soot.jimple.XorExpr newXorExpr(soot.Value,soot.Value)>
<soot.jimple.Jimple: void <init>(soot.Singletons$Global)>
<soot.jimple.JimpleBody: void <init>(soot.SootMethod)>
<soot.jimple.JimpleBody: void validate()>
<soot.jimple.JimpleBody: void validateIdentityStatements()>
<soot.jimple.JimpleToBafContext: soot.Local getBafLocalOfJimpleLocal(soot.Local)>
<soot.jimple.JimpleToBafContext: soot.Unit getCurrentUnit()>
<soot.jimple.JimpleToBafContext: void <init>(int)>
<soot.jimple.JimpleToBafContext: void setBafLocalOfJimpleLocal(soot.Local,soot.Local)>
<soot.jimple.JimpleToBafContext: void setCurrentUnit(soot.Unit)>
<soot.jimple.LongConstant: soot.Type getType()>
<soot.jimple.LongConstant: soot.jimple.LongConstant v(long)>
<soot.jimple.LongConstant: void <init>(long)>
<soot.jimple.NullConstant: soot.Type getType()>
<soot.jimple.NullConstant: soot.jimple.NullConstant v()>
<soot.jimple.NullConstant: void <init>(soot.Singletons$Global)>
<soot.jimple.NullConstant: void apply(soot.util.Switch)>
<soot.jimple.NumericConstant: void <init>()>
<soot.jimple.ParameterRef: int getIndex()>
<soot.jimple.ParameterRef: java.util.List getUseBoxes()>
<soot.jimple.ParameterRef: soot.Type getType()>
<soot.jimple.ParameterRef: void <init>(soot.Type,int)>
<soot.jimple.ParameterRef: void apply(soot.util.Switch)>
<soot.jimple.RealConstant: void <init>()>
<soot.jimple.StaticFieldRef: java.util.List getUseBoxes()>
<soot.jimple.StaticFieldRef: soot.SootField getField()>
<soot.jimple.StaticFieldRef: soot.SootFieldRef getFieldRef()>
<soot.jimple.StaticFieldRef: soot.Type getType()>
<soot.jimple.StaticFieldRef: void <init>(soot.SootFieldRef)>
<soot.jimple.StaticFieldRef: void apply(soot.util.Switch)>
<soot.jimple.StaticFieldRef: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.StmtBody: void <init>(soot.SootMethod)>
<soot.jimple.StringConstant: java.lang.String toString()>
<soot.jimple.StringConstant: soot.Type getType()>
<soot.jimple.StringConstant: soot.jimple.StringConstant v(java.lang.String)>
<soot.jimple.StringConstant: void <init>(java.lang.String)>
<soot.jimple.StringConstant: void apply(soot.util.Switch)>
<soot.jimple.ThisRef: java.util.List getUseBoxes()>
<soot.jimple.ThisRef: soot.Type getType()>
<soot.jimple.ThisRef: void <init>(soot.RefType)>
<soot.jimple.ThisRef: void apply(soot.util.Switch)>
<soot.jimple.internal.AbstractBinopExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractBinopExpr: soot.Value getOp1()>
<soot.jimple.internal.AbstractBinopExpr: soot.Value getOp2()>
<soot.jimple.internal.AbstractBinopExpr: void <init>()>
<soot.jimple.internal.AbstractBinopExpr: void setOp1(soot.Value)>
<soot.jimple.internal.AbstractBinopExpr: void setOp2(soot.Value)>
<soot.jimple.internal.AbstractCastExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractCastExpr: soot.Type getCastType()>
<soot.jimple.internal.AbstractCastExpr: soot.Value getOp()>
<soot.jimple.internal.AbstractCastExpr: void <init>(soot.ValueBox,soot.Type)>
<soot.jimple.internal.AbstractCastExpr: void apply(soot.util.Switch)>
<soot.jimple.internal.AbstractDefinitionStmt: boolean branches()>
<soot.jimple.internal.AbstractDefinitionStmt: boolean fallsThrough()>
<soot.jimple.internal.AbstractDefinitionStmt: java.util.List getDefBoxes()>
<soot.jimple.internal.AbstractDefinitionStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractDefinitionStmt: soot.Value getLeftOp()>
<soot.jimple.internal.AbstractDefinitionStmt: soot.Value getRightOp()>
<soot.jimple.internal.AbstractDefinitionStmt: soot.ValueBox getRightOpBox()>
<soot.jimple.internal.AbstractDefinitionStmt: void <init>()>
<soot.jimple.internal.AbstractFloatBinopExpr: void <init>()>
<soot.jimple.internal.AbstractInstanceFieldRef: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractInstanceFieldRef: soot.SootField getField()>
<soot.jimple.internal.AbstractInstanceFieldRef: soot.Type getType()>
<soot.jimple.internal.AbstractInstanceFieldRef: soot.Value getBase()>
<soot.jimple.internal.AbstractInstanceFieldRef: void <init>(soot.ValueBox,soot.SootFieldRef)>
<soot.jimple.internal.AbstractInstanceFieldRef: void apply(soot.util.Switch)>
<soot.jimple.internal.AbstractInstanceFieldRef: void setBase(soot.Value)>
<soot.jimple.internal.AbstractInstanceInvokeExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractInstanceInvokeExpr: soot.Value getBase()>
<soot.jimple.internal.AbstractInstanceInvokeExpr: void <init>()>
<soot.jimple.internal.AbstractInstanceInvokeExpr: void setBase(soot.Value)>
<soot.jimple.internal.AbstractInstanceOfExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractInstanceOfExpr: soot.Value getOp()>
<soot.jimple.internal.AbstractInstanceOfExpr: void <init>(soot.ValueBox,soot.Type)>
<soot.jimple.internal.AbstractInstanceOfExpr: void setOp(soot.Value)>
<soot.jimple.internal.AbstractIntBinopExpr: void <init>()>
<soot.jimple.internal.AbstractIntLongBinopExpr: void <init>()>
<soot.jimple.internal.AbstractInterfaceInvokeExpr: void <init>(soot.ValueBox,soot.SootMethodRef,soot.ValueBox[])>
<soot.jimple.internal.AbstractInvokeExpr: int getArgCount()>
<soot.jimple.internal.AbstractInvokeExpr: soot.SootMethod getMethod()>
<soot.jimple.internal.AbstractInvokeExpr: soot.SootMethodRef getMethodRef()>
<soot.jimple.internal.AbstractInvokeExpr: soot.Value getArg(int)>
<soot.jimple.internal.AbstractInvokeExpr: void <init>()>
<soot.jimple.internal.AbstractInvokeExpr: void setArg(int,soot.Value)>
<soot.jimple.internal.AbstractJimpleFloatBinopExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.AbstractJimpleFloatBinopExpr: void <init>(soot.ValueBox,soot.ValueBox)>
<soot.jimple.internal.AbstractJimpleIntBinopExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.AbstractJimpleIntLongBinopExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.AbstractLengthExpr: void <init>(soot.ValueBox)>
<soot.jimple.internal.AbstractNegExpr: void <init>(soot.ValueBox)>
<soot.jimple.internal.AbstractNewArrayExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractNewArrayExpr: soot.Type getBaseType()>
<soot.jimple.internal.AbstractNewArrayExpr: soot.Type getType()>
<soot.jimple.internal.AbstractNewArrayExpr: soot.Value getSize()>
<soot.jimple.internal.AbstractNewArrayExpr: void <init>(soot.Type,soot.ValueBox)>
<soot.jimple.internal.AbstractNewArrayExpr: void apply(soot.util.Switch)>
<soot.jimple.internal.AbstractNewArrayExpr: void setSize(soot.Value)>
<soot.jimple.internal.AbstractNewExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractNewExpr: soot.RefType getBaseType()>
<soot.jimple.internal.AbstractNewExpr: soot.Type getType()>
<soot.jimple.internal.AbstractNewExpr: void <init>()>
<soot.jimple.internal.AbstractNewExpr: void apply(soot.util.Switch)>
<soot.jimple.internal.AbstractNewMultiArrayExpr: int getSizeCount()>
<soot.jimple.internal.AbstractNewMultiArrayExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractNewMultiArrayExpr: soot.ArrayType getBaseType()>
<soot.jimple.internal.AbstractNewMultiArrayExpr: soot.Type getType()>
<soot.jimple.internal.AbstractNewMultiArrayExpr: soot.Value getSize(int)>
<soot.jimple.internal.AbstractNewMultiArrayExpr: void <init>(soot.ArrayType,soot.ValueBox[])>
<soot.jimple.internal.AbstractNewMultiArrayExpr: void apply(soot.util.Switch)>
<soot.jimple.internal.AbstractNewMultiArrayExpr: void setSize(int,soot.Value)>
<soot.jimple.internal.AbstractSpecialInvokeExpr: void <init>(soot.ValueBox,soot.SootMethodRef,soot.ValueBox[])>
<soot.jimple.internal.AbstractSpecialInvokeExpr: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.AbstractStaticInvokeExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractStaticInvokeExpr: void <init>(soot.SootMethodRef,soot.ValueBox[])>
<soot.jimple.internal.AbstractStaticInvokeExpr: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.AbstractStmt: boolean containsFieldRef()>
<soot.jimple.internal.AbstractStmt: boolean containsInvokeExpr()>
<soot.jimple.internal.AbstractStmt: void <init>()>
<soot.jimple.internal.AbstractUnopExpr: java.util.List getUseBoxes()>
<soot.jimple.internal.AbstractUnopExpr: soot.Value getOp()>
<soot.jimple.internal.AbstractUnopExpr: void <init>(soot.ValueBox)>
<soot.jimple.internal.AbstractUnopExpr: void setOp(soot.Value)>
<soot.jimple.internal.AbstractVirtualInvokeExpr: void <init>(soot.ValueBox,soot.SootMethodRef,soot.ValueBox[])>
<soot.jimple.internal.AbstractVirtualInvokeExpr: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.ConditionExprBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.ConditionExprBox: void <init>(soot.Value)>
<soot.jimple.internal.IdentityRefBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.IdentityRefBox: void <init>(soot.Value)>
<soot.jimple.internal.ImmediateBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.ImmediateBox: void <init>(soot.Value)>
<soot.jimple.internal.InvokeExprBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.InvokeExprBox: void <init>(soot.Value)>
<soot.jimple.internal.JAddExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JAndExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JArrayRef: java.util.List getUseBoxes()>
<soot.jimple.internal.JArrayRef: soot.Type getType()>
<soot.jimple.internal.JArrayRef: soot.Value getBase()>
<soot.jimple.internal.JArrayRef: soot.Value getIndex()>
<soot.jimple.internal.JArrayRef: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JArrayRef: void <init>(soot.ValueBox,soot.ValueBox)>
<soot.jimple.internal.JArrayRef: void apply(soot.util.Switch)>
<soot.jimple.internal.JArrayRef: void setIndex(soot.Value)>
<soot.jimple.internal.JAssignStmt$1: void <init>(soot.jimple.internal.JAssignStmt,soot.jimple.JimpleToBafContext,java.util.List,soot.Value)>
<soot.jimple.internal.JAssignStmt$1: void caseLocal(soot.Local)>
<soot.jimple.internal.JAssignStmt$LinkedRValueBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.JAssignStmt$LinkedRValueBox: void <init>(soot.jimple.internal.JAssignStmt,soot.Value)>
<soot.jimple.internal.JAssignStmt$LinkedRValueBox: void <init>(soot.jimple.internal.JAssignStmt,soot.Value,soot.jimple.internal.JAssignStmt$1)>
<soot.jimple.internal.JAssignStmt$LinkedRValueBox: void setOtherBox(soot.ValueBox)>
<soot.jimple.internal.JAssignStmt$LinkedVariableBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.JAssignStmt$LinkedVariableBox: void <init>(soot.jimple.internal.JAssignStmt,soot.Value)>
<soot.jimple.internal.JAssignStmt$LinkedVariableBox: void <init>(soot.jimple.internal.JAssignStmt,soot.Value,soot.jimple.internal.JAssignStmt$1)>
<soot.jimple.internal.JAssignStmt$LinkedVariableBox: void setOtherBox(soot.ValueBox)>
<soot.jimple.internal.JAssignStmt: boolean containsFieldRef()>
<soot.jimple.internal.JAssignStmt: boolean containsInvokeExpr()>
<soot.jimple.internal.JAssignStmt: java.util.List getUnitBoxes()>
<soot.jimple.internal.JAssignStmt: soot.jimple.FieldRef getFieldRef()>
<soot.jimple.internal.JAssignStmt: soot.jimple.InvokeExpr getInvokeExpr()>
<soot.jimple.internal.JAssignStmt: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JAssignStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JAssignStmt: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.JAssignStmt: void setLeftOp(soot.Value)>
<soot.jimple.internal.JAssignStmt: void setRightOp(soot.Value)>
<soot.jimple.internal.JCastExpr: void <init>(soot.Value,soot.Type)>
<soot.jimple.internal.JCaughtExceptionRef: java.util.List getUseBoxes()>
<soot.jimple.internal.JCaughtExceptionRef: void <init>()>
<soot.jimple.internal.JCaughtExceptionRef: void apply(soot.util.Switch)>
<soot.jimple.internal.JCmpExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JCmpgExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JCmplExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JDivExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JEnterMonitorStmt: boolean branches()>
<soot.jimple.internal.JEnterMonitorStmt: boolean fallsThrough()>
<soot.jimple.internal.JEnterMonitorStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JEnterMonitorStmt: soot.Value getOp()>
<soot.jimple.internal.JEnterMonitorStmt: void <init>(soot.Value)>
<soot.jimple.internal.JEnterMonitorStmt: void <init>(soot.ValueBox)>
<soot.jimple.internal.JEnterMonitorStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JEnterMonitorStmt: void setOp(soot.Value)>
<soot.jimple.internal.JEqExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JExitMonitorStmt: boolean branches()>
<soot.jimple.internal.JExitMonitorStmt: boolean fallsThrough()>
<soot.jimple.internal.JExitMonitorStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JExitMonitorStmt: soot.Value getOp()>
<soot.jimple.internal.JExitMonitorStmt: void <init>(soot.Value)>
<soot.jimple.internal.JExitMonitorStmt: void <init>(soot.ValueBox)>
<soot.jimple.internal.JExitMonitorStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JExitMonitorStmt: void setOp(soot.Value)>
<soot.jimple.internal.JGeExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JGotoStmt: boolean branches()>
<soot.jimple.internal.JGotoStmt: boolean fallsThrough()>
<soot.jimple.internal.JGotoStmt: java.util.List getUnitBoxes()>
<soot.jimple.internal.JGotoStmt: void <init>(soot.Unit)>
<soot.jimple.internal.JGotoStmt: void <init>(soot.UnitBox)>
<soot.jimple.internal.JGotoStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JGotoStmt: void setTarget(soot.Unit)>
<soot.jimple.internal.JGtExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JIdentityStmt: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JIdentityStmt: void <init>(soot.ValueBox,soot.ValueBox)>
<soot.jimple.internal.JIdentityStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JIdentityStmt: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.JIfStmt: boolean branches()>
<soot.jimple.internal.JIfStmt: boolean fallsThrough()>
<soot.jimple.internal.JIfStmt: java.util.List getUnitBoxes()>
<soot.jimple.internal.JIfStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JIfStmt: soot.Value getCondition()>
<soot.jimple.internal.JIfStmt: void <init>(soot.Value,soot.Unit)>
<soot.jimple.internal.JIfStmt: void <init>(soot.ValueBox,soot.UnitBox)>
<soot.jimple.internal.JIfStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JIfStmt: void setTarget(soot.Unit)>
<soot.jimple.internal.JInstanceFieldRef: void <init>(soot.Value,soot.SootFieldRef)>
<soot.jimple.internal.JInstanceOfExpr: void <init>(soot.Value,soot.Type)>
<soot.jimple.internal.JInterfaceInvokeExpr: void <init>(soot.Value,soot.SootMethodRef,java.util.List)>
<soot.jimple.internal.JInvokeStmt: boolean branches()>
<soot.jimple.internal.JInvokeStmt: boolean containsInvokeExpr()>
<soot.jimple.internal.JInvokeStmt: boolean fallsThrough()>
<soot.jimple.internal.JInvokeStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JInvokeStmt: soot.jimple.InvokeExpr getInvokeExpr()>
<soot.jimple.internal.JInvokeStmt: void <init>(soot.Value)>
<soot.jimple.internal.JInvokeStmt: void <init>(soot.ValueBox)>
<soot.jimple.internal.JInvokeStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JInvokeStmt: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.JLeExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JLengthExpr: void <init>(soot.Value)>
<soot.jimple.internal.JLookupSwitchStmt: boolean branches()>
<soot.jimple.internal.JLookupSwitchStmt: boolean fallsThrough()>
<soot.jimple.internal.JLookupSwitchStmt: java.util.List getUnitBoxes()>
<soot.jimple.internal.JLookupSwitchStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JLookupSwitchStmt: soot.UnitBox[] getTargetBoxesArray(java.util.List)>
<soot.jimple.internal.JLookupSwitchStmt: soot.Value getKey()>
<soot.jimple.internal.JLookupSwitchStmt: void <init>(soot.Value,java.util.List,java.util.List,soot.Unit)>
<soot.jimple.internal.JLookupSwitchStmt: void <init>(soot.ValueBox,java.util.List,soot.UnitBox[],soot.UnitBox)>
<soot.jimple.internal.JLookupSwitchStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JLookupSwitchStmt: void setDefaultTarget(soot.Unit)>
<soot.jimple.internal.JLookupSwitchStmt: void setKey(soot.Value)>
<soot.jimple.internal.JLookupSwitchStmt: void setTarget(int,soot.Unit)>
<soot.jimple.internal.JLtExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JMulExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JNeExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JNegExpr: void <init>(soot.Value)>
<soot.jimple.internal.JNewArrayExpr: void <init>(soot.Type,soot.Value)>
<soot.jimple.internal.JNewExpr: void <init>(soot.RefType)>
<soot.jimple.internal.JNewMultiArrayExpr: void <init>(soot.ArrayType,java.util.List)>
<soot.jimple.internal.JNopStmt: boolean branches()>
<soot.jimple.internal.JNopStmt: boolean fallsThrough()>
<soot.jimple.internal.JNopStmt: void <init>()>
<soot.jimple.internal.JNopStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JOrExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JRemExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JReturnStmt: boolean branches()>
<soot.jimple.internal.JReturnStmt: boolean fallsThrough()>
<soot.jimple.internal.JReturnStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JReturnStmt: soot.Value getOp()>
<soot.jimple.internal.JReturnStmt: void <init>(soot.Value)>
<soot.jimple.internal.JReturnStmt: void <init>(soot.ValueBox)>
<soot.jimple.internal.JReturnStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JReturnStmt: void setOp(soot.Value)>
<soot.jimple.internal.JReturnVoidStmt: boolean branches()>
<soot.jimple.internal.JReturnVoidStmt: boolean fallsThrough()>
<soot.jimple.internal.JReturnVoidStmt: void <init>()>
<soot.jimple.internal.JReturnVoidStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JReturnVoidStmt: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.JShlExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JShrExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JSpecialInvokeExpr: void <init>(soot.Local,soot.SootMethodRef,java.util.List)>
<soot.jimple.internal.JStaticInvokeExpr: void <init>(soot.SootMethodRef,java.util.List)>
<soot.jimple.internal.JSubExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JTableSwitchStmt: boolean branches()>
<soot.jimple.internal.JTableSwitchStmt: boolean fallsThrough()>
<soot.jimple.internal.JTableSwitchStmt: java.util.List getUnitBoxes()>
<soot.jimple.internal.JTableSwitchStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JTableSwitchStmt: soot.UnitBox[] getTargetBoxesArray(java.util.List)>
<soot.jimple.internal.JTableSwitchStmt: soot.Value getKey()>
<soot.jimple.internal.JTableSwitchStmt: void <init>(soot.Value,int,int,java.util.List,soot.Unit)>
<soot.jimple.internal.JTableSwitchStmt: void <init>(soot.ValueBox,int,int,soot.UnitBox[],soot.UnitBox)>
<soot.jimple.internal.JTableSwitchStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JTableSwitchStmt: void setDefaultTarget(soot.Unit)>
<soot.jimple.internal.JTableSwitchStmt: void setKey(soot.Value)>
<soot.jimple.internal.JTableSwitchStmt: void setTarget(int,soot.Unit)>
<soot.jimple.internal.JThrowStmt: boolean branches()>
<soot.jimple.internal.JThrowStmt: boolean fallsThrough()>
<soot.jimple.internal.JThrowStmt: java.util.List getUseBoxes()>
<soot.jimple.internal.JThrowStmt: soot.Value getOp()>
<soot.jimple.internal.JThrowStmt: void <init>(soot.Value)>
<soot.jimple.internal.JThrowStmt: void <init>(soot.ValueBox)>
<soot.jimple.internal.JThrowStmt: void apply(soot.util.Switch)>
<soot.jimple.internal.JThrowStmt: void setOp(soot.Value)>
<soot.jimple.internal.JTrap: void <init>(soot.SootClass,soot.Unit,soot.Unit,soot.Unit)>
<soot.jimple.internal.JUshrExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JVirtualInvokeExpr: void <init>(soot.Value,soot.SootMethodRef,java.util.List)>
<soot.jimple.internal.JXorExpr: void <init>(soot.Value,soot.Value)>
<soot.jimple.internal.JimpleLocal: int getNumber()>
<soot.jimple.internal.JimpleLocal: int hashCode()>
<soot.jimple.internal.JimpleLocal: java.lang.Object clone()>
<soot.jimple.internal.JimpleLocal: java.lang.String getName()>
<soot.jimple.internal.JimpleLocal: java.util.List getUseBoxes()>
<soot.jimple.internal.JimpleLocal: soot.Type getType()>
<soot.jimple.internal.JimpleLocal: void <init>(java.lang.String,soot.Type)>
<soot.jimple.internal.JimpleLocal: void apply(soot.util.Switch)>
<soot.jimple.internal.JimpleLocal: void convertToBaf(soot.jimple.JimpleToBafContext,java.util.List)>
<soot.jimple.internal.JimpleLocal: void setName(java.lang.String)>
<soot.jimple.internal.JimpleLocal: void setNumber(int)>
<soot.jimple.internal.JimpleLocal: void setType(soot.Type)>
<soot.jimple.internal.JimpleLocalBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.JimpleLocalBox: void <init>(soot.Value)>
<soot.jimple.internal.RValueBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.RValueBox: void <init>(soot.Value)>
<soot.jimple.internal.StmtBox: boolean canContainUnit(soot.Unit)>
<soot.jimple.internal.StmtBox: void <init>(soot.jimple.Stmt)>
<soot.jimple.internal.VariableBox: boolean canContainValue(soot.Value)>
<soot.jimple.internal.VariableBox: void <init>(soot.Value)>
<soot.jimple.paddle.PaddleHook: soot.jimple.paddle.PaddleHook v()>
<soot.jimple.paddle.PaddleHook: void <init>(soot.Singletons$Global)>
<soot.jimple.paddle.PaddleHook: void finishPhases()>
<soot.jimple.spark.SparkTransformer: soot.jimple.spark.SparkTransformer v()>
<soot.jimple.spark.SparkTransformer: void <init>(soot.Singletons$Global)>
<soot.jimple.spark.SparkTransformer: void internalTransform(java.lang.String,java.util.Map)>
<soot.jimple.spark.SparkTransformer: void reportTime(java.lang.String,java.util.Date,java.util.Date)>
<soot.jimple.spark.builder.ContextInsensitiveBuilder: soot.jimple.spark.pag.PAG setup(soot.options.SparkOptions)>
<soot.jimple.spark.builder.ContextInsensitiveBuilder: void <init>()>
<soot.jimple.spark.builder.ContextInsensitiveBuilder: void build()>
<soot.jimple.spark.builder.ContextInsensitiveBuilder: void handleClass(soot.SootClass)>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseArgv()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseDefaultClassLoader()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseFinalizeQueue()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseMainClassNameString()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseMainThread()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseMainThreadGroup()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseNewInstance(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node casePrivilegedActionException()>
<soot.jimple.spark.builder.GlobalNodeFactory: soot.jimple.spark.pag.Node caseThrow()>
<soot.jimple.spark.builder.GlobalNodeFactory: void <init>(soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.builder.MethodNodeFactory$1: void <init>(soot.jimple.spark.builder.MethodNodeFactory)>
<soot.jimple.spark.builder.MethodNodeFactory$1: void caseAssignStmt(soot.jimple.AssignStmt)>
<soot.jimple.spark.builder.MethodNodeFactory$1: void caseIdentityStmt(soot.jimple.IdentityStmt)>
<soot.jimple.spark.builder.MethodNodeFactory$1: void caseReturnStmt(soot.jimple.ReturnStmt)>
<soot.jimple.spark.builder.MethodNodeFactory$1: void caseThrowStmt(soot.jimple.ThrowStmt)>
<soot.jimple.spark.builder.MethodNodeFactory: soot.jimple.spark.pag.Node caseArray(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.builder.MethodNodeFactory: soot.jimple.spark.pag.Node caseParm(int)>
<soot.jimple.spark.builder.MethodNodeFactory: soot.jimple.spark.pag.Node caseRet()>
<soot.jimple.spark.builder.MethodNodeFactory: soot.jimple.spark.pag.Node caseThis()>
<soot.jimple.spark.builder.MethodNodeFactory: soot.jimple.spark.pag.Node getNode()>
<soot.jimple.spark.builder.MethodNodeFactory: soot.jimple.spark.pag.Node getNode(soot.Value)>
<soot.jimple.spark.builder.MethodNodeFactory: void <init>(soot.jimple.spark.pag.PAG,soot.jimple.spark.pag.MethodPAG)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseArrayRef(soot.jimple.ArrayRef)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseCastExpr(soot.jimple.CastExpr)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseCaughtExceptionRef(soot.jimple.CaughtExceptionRef)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseClassConstant(soot.jimple.ClassConstant)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseInstanceFieldRef(soot.jimple.InstanceFieldRef)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseLocal(soot.Local)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseNewArrayExpr(soot.jimple.NewArrayExpr)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseNewExpr(soot.jimple.NewExpr)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseNewMultiArrayExpr(soot.jimple.NewMultiArrayExpr)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseNullConstant(soot.jimple.NullConstant)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseParameterRef(soot.jimple.ParameterRef)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseStaticFieldRef(soot.jimple.StaticFieldRef)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseStringConstant(soot.jimple.StringConstant)>
<soot.jimple.spark.builder.MethodNodeFactory: void caseThisRef(soot.jimple.ThisRef)>
<soot.jimple.spark.builder.MethodNodeFactory: void handleStmt(soot.jimple.Stmt)>
<soot.jimple.spark.builder.MethodNodeFactory: void setCurrentMethod(soot.SootMethod)>
<soot.jimple.spark.fieldrw.FieldTagAggregator: soot.jimple.spark.fieldrw.FieldTagAggregator v()>
<soot.jimple.spark.fieldrw.FieldTagAggregator: void <init>(soot.Singletons$Global)>
<soot.jimple.spark.fieldrw.FieldTagger: soot.jimple.spark.fieldrw.FieldTagger v()>
<soot.jimple.spark.fieldrw.FieldTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.spark.internal.SparkNativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable arrayElementOfImpl(soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.spark.internal.SparkNativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable cloneObjectImpl(soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.spark.internal.SparkNativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable newInstanceOfImpl(soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.spark.internal.SparkNativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable staticFieldImpl(java.lang.String,java.lang.String)>
<soot.jimple.spark.internal.SparkNativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable tempFieldImpl(java.lang.String)>
<soot.jimple.spark.internal.SparkNativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable tempLocalVariableImpl(soot.SootMethod)>
<soot.jimple.spark.internal.SparkNativeHelper: void <init>(soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.internal.SparkNativeHelper: void assignImpl(soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.spark.internal.SparkNativeHelper: void assignObjectToImpl(soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.AbstractObject)>
<soot.jimple.spark.internal.SparkNativeHelper: void throwExceptionImpl(soot.jimple.toolkits.pointer.representations.AbstractObject)>
<soot.jimple.spark.internal.TypeManager: boolean castNeverFails(soot.Type,soot.Type)>
<soot.jimple.spark.internal.TypeManager: boolean isUnresolved(soot.Type)>
<soot.jimple.spark.internal.TypeManager: soot.FastHierarchy getFastHierarchy()>
<soot.jimple.spark.internal.TypeManager: soot.util.BitVector get(soot.Type)>
<soot.jimple.spark.internal.TypeManager: void <init>(soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.internal.TypeManager: void makeTypeMask()>
<soot.jimple.spark.internal.TypeManager: void setFastHierarchy(soot.FastHierarchy)>
<soot.jimple.spark.pag.AllocDotField: void <init>(soot.jimple.spark.pag.PAG,soot.jimple.spark.pag.AllocNode,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.AllocNode: soot.jimple.spark.pag.AllocDotField dot(soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.AllocNode: void <init>(soot.jimple.spark.pag.PAG,java.lang.Object,soot.Type,soot.SootMethod)>
<soot.jimple.spark.pag.AllocNode: void addField(soot.jimple.spark.pag.AllocDotField,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.ArrayElement: soot.jimple.spark.pag.ArrayElement v()>
<soot.jimple.spark.pag.ArrayElement: void <init>(soot.Singletons$Global)>
<soot.jimple.spark.pag.ClassConstantNode: void <init>(soot.jimple.spark.pag.PAG,soot.jimple.ClassConstant)>
<soot.jimple.spark.pag.FieldRefNode: soot.jimple.spark.pag.Node getReplacement()>
<soot.jimple.spark.pag.FieldRefNode: soot.jimple.spark.pag.SparkField getField()>
<soot.jimple.spark.pag.FieldRefNode: soot.jimple.spark.pag.VarNode getBase()>
<soot.jimple.spark.pag.FieldRefNode: void <init>(soot.jimple.spark.pag.PAG,soot.jimple.spark.pag.VarNode,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.GlobalVarNode: void <init>(soot.jimple.spark.pag.PAG,java.lang.Object,soot.Type)>
<soot.jimple.spark.pag.LocalVarNode: soot.SootMethod getMethod()>
<soot.jimple.spark.pag.LocalVarNode: void <init>(soot.jimple.spark.pag.PAG,java.lang.Object,soot.Type,soot.SootMethod)>
<soot.jimple.spark.pag.MethodPAG: soot.SootMethod getMethod()>
<soot.jimple.spark.pag.MethodPAG: soot.jimple.spark.builder.MethodNodeFactory nodeFactory()>
<soot.jimple.spark.pag.MethodPAG: soot.jimple.spark.pag.MethodPAG v(soot.jimple.spark.pag.PAG,soot.SootMethod)>
<soot.jimple.spark.pag.MethodPAG: soot.jimple.spark.pag.Node parameterize(soot.jimple.spark.pag.Node,soot.Context)>
<soot.jimple.spark.pag.MethodPAG: soot.jimple.spark.pag.PAG pag()>
<soot.jimple.spark.pag.MethodPAG: void <init>(soot.jimple.spark.pag.PAG,soot.SootMethod)>
<soot.jimple.spark.pag.MethodPAG: void addInEdge(soot.jimple.spark.pag.Node,soot.jimple.spark.pag.Node)>
<soot.jimple.spark.pag.MethodPAG: void addInternalEdge(soot.jimple.spark.pag.Node,soot.jimple.spark.pag.Node)>
<soot.jimple.spark.pag.MethodPAG: void addMiscEdges()>
<soot.jimple.spark.pag.MethodPAG: void addOutEdge(soot.jimple.spark.pag.Node,soot.jimple.spark.pag.Node)>
<soot.jimple.spark.pag.MethodPAG: void addToPAG(soot.Context)>
<soot.jimple.spark.pag.MethodPAG: void build()>
<soot.jimple.spark.pag.MethodPAG: void buildNative()>
<soot.jimple.spark.pag.MethodPAG: void buildNormal()>
<soot.jimple.spark.pag.Node: boolean equals(java.lang.Object)>
<soot.jimple.spark.pag.Node: int getNumber()>
<soot.jimple.spark.pag.Node: int hashCode()>
<soot.jimple.spark.pag.Node: soot.Type getType()>
<soot.jimple.spark.pag.Node: soot.jimple.spark.pag.Node getReplacement()>
<soot.jimple.spark.pag.Node: soot.jimple.spark.sets.PointsToSetInternal getP2Set()>
<soot.jimple.spark.pag.Node: soot.jimple.spark.sets.PointsToSetInternal makeP2Set()>
<soot.jimple.spark.pag.Node: void <init>(soot.jimple.spark.pag.PAG,soot.Type)>
<soot.jimple.spark.pag.Node: void setNumber(int)>
<soot.jimple.spark.pag.PAG: boolean addAllocEdge(soot.jimple.spark.pag.AllocNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: boolean addEdge(soot.jimple.spark.pag.Node,soot.jimple.spark.pag.Node)>
<soot.jimple.spark.pag.PAG: boolean addLoadEdge(soot.jimple.spark.pag.FieldRefNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: boolean addSimpleEdge(soot.jimple.spark.pag.VarNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: boolean addStoreEdge(soot.jimple.spark.pag.VarNode,soot.jimple.spark.pag.FieldRefNode)>
<soot.jimple.spark.pag.PAG: boolean addToMap(java.util.Map,soot.jimple.spark.pag.Node,soot.jimple.spark.pag.Node)>
<soot.jimple.spark.pag.PAG: boolean doAddAllocEdge(soot.jimple.spark.pag.AllocNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: boolean doAddLoadEdge(soot.jimple.spark.pag.FieldRefNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: boolean doAddSimpleEdge(soot.jimple.spark.pag.VarNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: boolean doAddStoreEdge(soot.jimple.spark.pag.VarNode,soot.jimple.spark.pag.FieldRefNode)>
<soot.jimple.spark.pag.PAG: java.util.Set allocSources()>
<soot.jimple.spark.pag.PAG: java.util.Set loadSources()>
<soot.jimple.spark.pag.PAG: java.util.Set storeSources()>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.builder.GlobalNodeFactory nodeFactory()>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.internal.TypeManager getTypeManager()>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.AllocDotField findAllocDotField(soot.jimple.spark.pag.AllocNode,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.AllocDotField makeAllocDotField(soot.jimple.spark.pag.AllocNode,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.AllocNode makeAllocNode(java.lang.Object,soot.Type,soot.SootMethod)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.AllocNode makeClassConstantNode(soot.jimple.ClassConstant)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.AllocNode makeStringConstantNode(java.lang.String)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.FieldRefNode makeFieldRefNode(soot.jimple.spark.pag.VarNode,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.FieldRefNode makeLocalFieldRefNode(java.lang.Object,soot.Type,soot.jimple.spark.pag.SparkField,soot.SootMethod)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.GlobalVarNode makeGlobalVarNode(java.lang.Object,soot.Type)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.LocalVarNode makeLocalVarNode(java.lang.Object,soot.Type,soot.SootMethod)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.Node[] allocLookup(soot.jimple.spark.pag.AllocNode)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.Node[] loadLookup(soot.jimple.spark.pag.FieldRefNode)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.Node[] lookup(java.util.Map,java.lang.Object)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.Node[] simpleLookup(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.Node[] storeInvLookup(soot.jimple.spark.pag.FieldRefNode)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.pag.Node[] storeLookup(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.sets.P2SetFactory getSetFactory()>
<soot.jimple.spark.pag.PAG: soot.jimple.spark.solver.OnFlyCallGraph getOnFlyCallGraph()>
<soot.jimple.spark.pag.PAG: soot.options.SparkOptions getOpts()>
<soot.jimple.spark.pag.PAG: soot.util.ArrayNumberer getAllocDotFieldNodeNumberer()>
<soot.jimple.spark.pag.PAG: soot.util.ArrayNumberer getAllocNodeNumberer()>
<soot.jimple.spark.pag.PAG: soot.util.ArrayNumberer getFieldRefNodeNumberer()>
<soot.jimple.spark.pag.PAG: soot.util.ArrayNumberer getVarNodeNumberer()>
<soot.jimple.spark.pag.PAG: soot.util.queue.QueueReader allocNodeListener()>
<soot.jimple.spark.pag.PAG: soot.util.queue.QueueReader edgeReader()>
<soot.jimple.spark.pag.PAG: void <clinit>()>
<soot.jimple.spark.pag.PAG: void <init>(soot.options.SparkOptions)>
<soot.jimple.spark.pag.PAG: void addCallTarget(soot.jimple.spark.pag.MethodPAG,soot.jimple.spark.pag.MethodPAG,soot.jimple.Stmt,soot.Context,soot.Context)>
<soot.jimple.spark.pag.PAG: void addCallTarget(soot.jimple.toolkits.callgraph.Edge)>
<soot.jimple.spark.pag.PAG: void addDereference(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.pag.PAG: void addNodeTag(soot.jimple.spark.pag.Node,soot.SootMethod)>
<soot.jimple.spark.pag.PAG: void cleanUpMerges()>
<soot.jimple.spark.pag.PAG: void setOnFlyCallGraph(soot.jimple.spark.solver.OnFlyCallGraph)>
<soot.jimple.spark.pag.Parm: int getNumber()>
<soot.jimple.spark.pag.Parm: soot.jimple.spark.pag.Parm v(soot.SootMethod,int)>
<soot.jimple.spark.pag.Parm: void <init>(soot.SootMethod,int)>
<soot.jimple.spark.pag.Parm: void setNumber(int)>
<soot.jimple.spark.pag.StringConstantNode: java.lang.String getString()>
<soot.jimple.spark.pag.StringConstantNode: void <init>(soot.jimple.spark.pag.PAG,java.lang.String)>
<soot.jimple.spark.pag.ValNode: void <init>(soot.jimple.spark.pag.PAG,soot.Type)>
<soot.jimple.spark.pag.VarNode: int compareTo(java.lang.Object)>
<soot.jimple.spark.pag.VarNode: java.lang.Object getVariable()>
<soot.jimple.spark.pag.VarNode: java.util.Collection getAllFieldRefs()>
<soot.jimple.spark.pag.VarNode: soot.Context context()>
<soot.jimple.spark.pag.VarNode: soot.jimple.spark.pag.FieldRefNode dot(soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.VarNode: void <init>(soot.jimple.spark.pag.PAG,java.lang.Object,soot.Type)>
<soot.jimple.spark.pag.VarNode: void addField(soot.jimple.spark.pag.FieldRefNode,soot.jimple.spark.pag.SparkField)>
<soot.jimple.spark.pag.VarNode: void setFinishingNumber(int)>
<soot.jimple.spark.pag.VarNode: void setInterProcSource()>
<soot.jimple.spark.pag.VarNode: void setInterProcTarget()>
<soot.jimple.spark.sets.DoublePointsToSet$2: soot.jimple.spark.sets.PointsToSetInternal newSet(soot.Type,soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.sets.DoublePointsToSet$2: void <init>()>
<soot.jimple.spark.sets.DoublePointsToSet: boolean add(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.sets.DoublePointsToSet: boolean addAll(soot.jimple.spark.sets.PointsToSetInternal,soot.jimple.spark.sets.PointsToSetInternal)>
<soot.jimple.spark.sets.DoublePointsToSet: boolean forall(soot.jimple.spark.sets.P2SetVisitor)>
<soot.jimple.spark.sets.DoublePointsToSet: soot.jimple.spark.sets.P2SetFactory getFactory(soot.jimple.spark.sets.P2SetFactory,soot.jimple.spark.sets.P2SetFactory)>
<soot.jimple.spark.sets.DoublePointsToSet: soot.jimple.spark.sets.PointsToSetInternal getNewSet()>
<soot.jimple.spark.sets.DoublePointsToSet: soot.jimple.spark.sets.PointsToSetInternal getOldSet()>
<soot.jimple.spark.sets.DoublePointsToSet: void <init>(soot.Type,soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.sets.DoublePointsToSet: void flushNew()>
<soot.jimple.spark.sets.EmptyPointsToSet: boolean forall(soot.jimple.spark.sets.P2SetVisitor)>
<soot.jimple.spark.sets.EmptyPointsToSet: soot.jimple.spark.sets.EmptyPointsToSet v()>
<soot.jimple.spark.sets.EmptyPointsToSet: void <init>(soot.Singletons$Global)>
<soot.jimple.spark.sets.HybridPointsToSet$1: soot.jimple.spark.sets.PointsToSetInternal newSet(soot.Type,soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.sets.HybridPointsToSet$1: void <init>()>
<soot.jimple.spark.sets.HybridPointsToSet: boolean add(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.sets.HybridPointsToSet: boolean addAll(soot.jimple.spark.sets.PointsToSetInternal,soot.jimple.spark.sets.PointsToSetInternal)>
<soot.jimple.spark.sets.HybridPointsToSet: boolean contains(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.sets.HybridPointsToSet: boolean fastAdd(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.sets.HybridPointsToSet: boolean forall(soot.jimple.spark.sets.P2SetVisitor)>
<soot.jimple.spark.sets.HybridPointsToSet: boolean isEmpty()>
<soot.jimple.spark.sets.HybridPointsToSet: boolean nativeAddAll(soot.jimple.spark.sets.HybridPointsToSet,soot.jimple.spark.sets.HybridPointsToSet)>
<soot.jimple.spark.sets.HybridPointsToSet: boolean superAddAll(soot.jimple.spark.sets.PointsToSetInternal,soot.jimple.spark.sets.PointsToSetInternal)>
<soot.jimple.spark.sets.HybridPointsToSet: soot.jimple.spark.sets.P2SetFactory getFactory()>
<soot.jimple.spark.sets.HybridPointsToSet: void <init>(soot.Type,soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.sets.HybridPointsToSet: void convertToBits()>
<soot.jimple.spark.sets.P2SetFactory: void <init>()>
<soot.jimple.spark.sets.P2SetVisitor: boolean getReturnValue()>
<soot.jimple.spark.sets.P2SetVisitor: void <init>()>
<soot.jimple.spark.sets.PointsToSetInternal: boolean addAll(soot.jimple.spark.sets.PointsToSetInternal,soot.jimple.spark.sets.PointsToSetInternal)>
<soot.jimple.spark.sets.PointsToSetInternal: soot.Type getType()>
<soot.jimple.spark.sets.PointsToSetInternal: void <init>(soot.Type)>
<soot.jimple.spark.solver.OnFlyCallGraph$1: void <init>(soot.jimple.spark.solver.OnFlyCallGraph,soot.Local,soot.Context)>
<soot.jimple.spark.solver.OnFlyCallGraph$1: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.OnFlyCallGraph$2: void <init>(soot.jimple.spark.solver.OnFlyCallGraph,soot.Local,soot.Context)>
<soot.jimple.spark.solver.OnFlyCallGraph$2: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.OnFlyCallGraph: soot.jimple.toolkits.callgraph.CallGraph callGraph()>
<soot.jimple.spark.solver.OnFlyCallGraph: soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder access$000(soot.jimple.spark.solver.OnFlyCallGraph)>
<soot.jimple.spark.solver.OnFlyCallGraph: soot.jimple.toolkits.callgraph.ReachableMethods reachableMethods()>
<soot.jimple.spark.solver.OnFlyCallGraph: void <init>(soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.solver.OnFlyCallGraph: void build()>
<soot.jimple.spark.solver.OnFlyCallGraph: void processCallEdges()>
<soot.jimple.spark.solver.OnFlyCallGraph: void processReachables()>
<soot.jimple.spark.solver.OnFlyCallGraph: void updatedNode(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.solver.PropWorklist$1: void <init>(soot.jimple.spark.solver.PropWorklist,soot.jimple.spark.pag.FieldRefNode,soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.solver.PropWorklist$1: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.PropWorklist$2: void <init>(soot.jimple.spark.solver.PropWorklist,soot.jimple.spark.pag.SparkField,soot.jimple.spark.sets.PointsToSetInternal)>
<soot.jimple.spark.solver.PropWorklist$2: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.PropWorklist$3: void <init>(soot.jimple.spark.solver.PropWorklist,soot.jimple.spark.pag.SparkField,soot.jimple.spark.pag.Node[],java.util.HashSet)>
<soot.jimple.spark.solver.PropWorklist$3: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.PropWorklist$4: void <init>(soot.jimple.spark.solver.PropWorklist,soot.jimple.spark.pag.SparkField,soot.jimple.spark.pag.Node[],java.util.HashSet)>
<soot.jimple.spark.solver.PropWorklist$4: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.PropWorklist$5: void <init>(soot.jimple.spark.solver.PropWorklist,soot.jimple.spark.pag.SparkField,soot.jimple.spark.pag.Node[],java.util.HashSet)>
<soot.jimple.spark.solver.PropWorklist$5: void visit(soot.jimple.spark.pag.Node)>
<soot.jimple.spark.solver.PropWorklist: boolean handleAllocNode(soot.jimple.spark.pag.AllocNode)>
<soot.jimple.spark.solver.PropWorklist: boolean handleVarNode(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.solver.PropWorklist: void <init>(soot.jimple.spark.pag.PAG)>
<soot.jimple.spark.solver.PropWorklist: void handleFieldRefNode(soot.jimple.spark.pag.FieldRefNode,java.util.HashSet)>
<soot.jimple.spark.solver.PropWorklist: void propagate()>
<soot.jimple.spark.solver.Propagator: void <init>()>
<soot.jimple.spark.solver.TopoSorter: void <init>(soot.jimple.spark.pag.PAG,boolean)>
<soot.jimple.spark.solver.TopoSorter: void dfsVisit(soot.jimple.spark.pag.VarNode)>
<soot.jimple.spark.solver.TopoSorter: void sort()>
<soot.jimple.toolkits.annotation.AvailExprTagger: soot.jimple.toolkits.annotation.AvailExprTagger v()>
<soot.jimple.toolkits.annotation.AvailExprTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.DominatorsTagger: soot.jimple.toolkits.annotation.DominatorsTagger v()>
<soot.jimple.toolkits.annotation.DominatorsTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.arraycheck.ArrayBoundsChecker: soot.jimple.toolkits.annotation.arraycheck.ArrayBoundsChecker v()>
<soot.jimple.toolkits.annotation.arraycheck.ArrayBoundsChecker: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.arraycheck.ExtendedHashMutableDirectedGraph: void <init>()>
<soot.jimple.toolkits.annotation.arraycheck.RectangularArrayFinder: soot.jimple.toolkits.annotation.arraycheck.RectangularArrayFinder v()>
<soot.jimple.toolkits.annotation.arraycheck.RectangularArrayFinder: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.callgraph.CallGraphGrapher: soot.jimple.toolkits.annotation.callgraph.CallGraphGrapher v()>
<soot.jimple.toolkits.annotation.callgraph.CallGraphGrapher: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.callgraph.CallGraphTagger: soot.jimple.toolkits.annotation.callgraph.CallGraphTagger v()>
<soot.jimple.toolkits.annotation.callgraph.CallGraphTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.defs.ReachingDefsTagger: soot.jimple.toolkits.annotation.defs.ReachingDefsTagger v()>
<soot.jimple.toolkits.annotation.defs.ReachingDefsTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.fields.UnreachableFieldsTagger: soot.jimple.toolkits.annotation.fields.UnreachableFieldsTagger v()>
<soot.jimple.toolkits.annotation.fields.UnreachableFieldsTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.liveness.LiveVarsTagger: soot.jimple.toolkits.annotation.liveness.LiveVarsTagger v()>
<soot.jimple.toolkits.annotation.liveness.LiveVarsTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.logic.LoopInvariantFinder: soot.jimple.toolkits.annotation.logic.LoopInvariantFinder v()>
<soot.jimple.toolkits.annotation.logic.LoopInvariantFinder: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.methods.UnreachableMethodsTagger: soot.jimple.toolkits.annotation.methods.UnreachableMethodsTagger v()>
<soot.jimple.toolkits.annotation.methods.UnreachableMethodsTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.nullcheck.NullCheckEliminator$AnalysisFactory: void <init>()>
<soot.jimple.toolkits.annotation.nullcheck.NullCheckEliminator: void <init>()>
<soot.jimple.toolkits.annotation.nullcheck.NullCheckEliminator: void <init>(soot.jimple.toolkits.annotation.nullcheck.NullCheckEliminator$AnalysisFactory)>
<soot.jimple.toolkits.annotation.nullcheck.NullPointerChecker: soot.jimple.toolkits.annotation.nullcheck.NullPointerChecker v()>
<soot.jimple.toolkits.annotation.nullcheck.NullPointerChecker: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.nullcheck.NullPointerColorer: soot.jimple.toolkits.annotation.nullcheck.NullPointerColorer v()>
<soot.jimple.toolkits.annotation.nullcheck.NullPointerColorer: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.parity.ParityTagger: soot.jimple.toolkits.annotation.parity.ParityTagger v()>
<soot.jimple.toolkits.annotation.parity.ParityTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.profiling.ProfilingGenerator: soot.jimple.toolkits.annotation.profiling.ProfilingGenerator v()>
<soot.jimple.toolkits.annotation.profiling.ProfilingGenerator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.purity.PurityAnalysis: soot.jimple.toolkits.annotation.purity.PurityAnalysis v()>
<soot.jimple.toolkits.annotation.purity.PurityAnalysis: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.qualifiers.TightestQualifiersTagger: soot.jimple.toolkits.annotation.qualifiers.TightestQualifiersTagger v()>
<soot.jimple.toolkits.annotation.qualifiers.TightestQualifiersTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.annotation.tags.ArrayNullTagAggregator: soot.jimple.toolkits.annotation.tags.ArrayNullTagAggregator v()>
<soot.jimple.toolkits.annotation.tags.ArrayNullTagAggregator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.base.Aggregator: boolean internalAggregate(soot.jimple.StmtBody,java.util.Map,boolean)>
<soot.jimple.toolkits.base.Aggregator: boolean isSimpleCopy(soot.Unit)>
<soot.jimple.toolkits.base.Aggregator: soot.jimple.toolkits.base.Aggregator v()>
<soot.jimple.toolkits.base.Aggregator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.base.Aggregator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.base.Zonation: soot.jimple.toolkits.base.Zone getZoneOf(soot.Unit)>
<soot.jimple.toolkits.base.Zonation: void <init>(soot.jimple.StmtBody)>
<soot.jimple.toolkits.base.Zone: void <init>(java.lang.String)>
<soot.jimple.toolkits.callgraph.CHATransformer: soot.jimple.toolkits.callgraph.CHATransformer v()>
<soot.jimple.toolkits.callgraph.CHATransformer: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfMethodIterator: boolean hasNext()>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfMethodIterator: java.lang.Object next()>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfMethodIterator: soot.jimple.toolkits.callgraph.Edge next()>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfMethodIterator: void <init>(soot.jimple.toolkits.callgraph.CallGraph,soot.MethodOrMethodContext)>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfUnitIterator: boolean hasNext()>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfUnitIterator: java.lang.Object next()>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfUnitIterator: soot.jimple.toolkits.callgraph.Edge next()>
<soot.jimple.toolkits.callgraph.CallGraph$TargetsOfUnitIterator: void <init>(soot.jimple.toolkits.callgraph.CallGraph,soot.Unit)>
<soot.jimple.toolkits.callgraph.CallGraph: boolean addEdge(soot.jimple.toolkits.callgraph.Edge)>
<soot.jimple.toolkits.callgraph.CallGraph: boolean removeEdge(soot.jimple.toolkits.callgraph.Edge)>
<soot.jimple.toolkits.callgraph.CallGraph: java.util.Iterator edgesOutOf(soot.MethodOrMethodContext)>
<soot.jimple.toolkits.callgraph.CallGraph: java.util.Iterator edgesOutOf(soot.Unit)>
<soot.jimple.toolkits.callgraph.CallGraph: soot.util.queue.QueueReader listener()>
<soot.jimple.toolkits.callgraph.CallGraph: void <init>()>
<soot.jimple.toolkits.callgraph.CallGraphBuilder: soot.jimple.toolkits.callgraph.ContextManager makeContextManager(soot.jimple.toolkits.callgraph.CallGraph)>
<soot.jimple.toolkits.callgraph.CallGraphPack: void <init>(java.lang.String)>
<soot.jimple.toolkits.callgraph.CallGraphPack: void internalApply()>
<soot.jimple.toolkits.callgraph.ClinitElimAnalysis: java.lang.Object entryInitialFlow()>
<soot.jimple.toolkits.callgraph.ClinitElimAnalysis: java.lang.Object newInitialFlow()>
<soot.jimple.toolkits.callgraph.ClinitElimAnalysis: void <init>(soot.toolkits.graph.UnitGraph)>
<soot.jimple.toolkits.callgraph.ClinitElimAnalysis: void copy(java.lang.Object,java.lang.Object)>
<soot.jimple.toolkits.callgraph.ClinitElimAnalysis: void flowThrough(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.jimple.toolkits.callgraph.ClinitElimAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.jimple.toolkits.callgraph.ClinitElimTransformer: void <init>()>
<soot.jimple.toolkits.callgraph.ClinitElimTransformer: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.callgraph.ContextInsensitiveContextManager: soot.jimple.toolkits.callgraph.CallGraph callGraph()>
<soot.jimple.toolkits.callgraph.ContextInsensitiveContextManager: void <init>(soot.jimple.toolkits.callgraph.CallGraph)>
<soot.jimple.toolkits.callgraph.ContextInsensitiveContextManager: void addStaticEdge(soot.MethodOrMethodContext,soot.Unit,soot.SootMethod,soot.Kind)>
<soot.jimple.toolkits.callgraph.ContextInsensitiveContextManager: void addVirtualEdge(soot.MethodOrMethodContext,soot.Unit,soot.SootMethod,soot.Kind,soot.Context)>
<soot.jimple.toolkits.callgraph.Edge: boolean equals(java.lang.Object)>
<soot.jimple.toolkits.callgraph.Edge: boolean isClinit()>
<soot.jimple.toolkits.callgraph.Edge: boolean isExplicit()>
<soot.jimple.toolkits.callgraph.Edge: boolean passesParameters()>
<soot.jimple.toolkits.callgraph.Edge: int hashCode()>
<soot.jimple.toolkits.callgraph.Edge: soot.Context srcCtxt()>
<soot.jimple.toolkits.callgraph.Edge: soot.Context tgtCtxt()>
<soot.jimple.toolkits.callgraph.Edge: soot.Kind ieToKind(soot.jimple.InvokeExpr)>
<soot.jimple.toolkits.callgraph.Edge: soot.Kind kind()>
<soot.jimple.toolkits.callgraph.Edge: soot.MethodOrMethodContext getSrc()>
<soot.jimple.toolkits.callgraph.Edge: soot.MethodOrMethodContext getTgt()>
<soot.jimple.toolkits.callgraph.Edge: soot.SootMethod src()>
<soot.jimple.toolkits.callgraph.Edge: soot.SootMethod tgt()>
<soot.jimple.toolkits.callgraph.Edge: soot.Unit srcUnit()>
<soot.jimple.toolkits.callgraph.Edge: soot.jimple.Stmt srcStmt()>
<soot.jimple.toolkits.callgraph.Edge: soot.jimple.toolkits.callgraph.Edge nextBySrc()>
<soot.jimple.toolkits.callgraph.Edge: soot.jimple.toolkits.callgraph.Edge nextByTgt()>
<soot.jimple.toolkits.callgraph.Edge: soot.jimple.toolkits.callgraph.Edge nextByUnit()>
<soot.jimple.toolkits.callgraph.Edge: void <init>(soot.MethodOrMethodContext,soot.Unit,soot.MethodOrMethodContext,soot.Kind)>
<soot.jimple.toolkits.callgraph.Edge: void insertAfterBySrc(soot.jimple.toolkits.callgraph.Edge)>
<soot.jimple.toolkits.callgraph.Edge: void insertAfterByTgt(soot.jimple.toolkits.callgraph.Edge)>
<soot.jimple.toolkits.callgraph.Edge: void insertAfterByUnit(soot.jimple.toolkits.callgraph.Edge)>
<soot.jimple.toolkits.callgraph.Edge: void remove()>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: boolean wantStringConstants(soot.Local)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: boolean wantTypes(soot.Local)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void <init>(soot.jimple.toolkits.callgraph.ContextManager,soot.jimple.toolkits.callgraph.ReachableMethods)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void addEdge(soot.SootMethod,soot.jimple.Stmt,soot.SootClass,soot.util.NumberedString,soot.Kind)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void addEdge(soot.SootMethod,soot.jimple.Stmt,soot.SootMethod)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void addEdge(soot.SootMethod,soot.jimple.Stmt,soot.SootMethod,soot.Kind)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void addStringConstant(soot.Local,soot.Context,java.lang.String)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void addType(soot.Local,soot.Context,soot.Type,soot.Context)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void addVirtualCallSite(soot.jimple.Stmt,soot.SootMethod,soot.Local,soot.jimple.InstanceInvokeExpr,soot.util.NumberedString,soot.Kind)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void constantForName(java.lang.String,soot.SootMethod,soot.jimple.Stmt)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void findReceivers(soot.SootMethod,soot.Body)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void getImplicitTargets(soot.SootMethod)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void handleInit(soot.SootMethod,soot.SootClass)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void processNewMethod(soot.SootMethod)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void processNewMethodContext(soot.MethodOrMethodContext)>
<soot.jimple.toolkits.callgraph.OnFlyCallGraphBuilder: void processReachables()>
<soot.jimple.toolkits.callgraph.ReachableMethods: boolean contains(soot.MethodOrMethodContext)>
<soot.jimple.toolkits.callgraph.ReachableMethods: soot.util.queue.QueueReader listener()>
<soot.jimple.toolkits.callgraph.ReachableMethods: void <init>(soot.jimple.toolkits.callgraph.CallGraph,java.util.Collection)>
<soot.jimple.toolkits.callgraph.ReachableMethods: void <init>(soot.jimple.toolkits.callgraph.CallGraph,java.util.Iterator)>
<soot.jimple.toolkits.callgraph.ReachableMethods: void <init>(soot.jimple.toolkits.callgraph.CallGraph,java.util.Iterator,soot.jimple.toolkits.callgraph.Filter)>
<soot.jimple.toolkits.callgraph.ReachableMethods: void addMethod(soot.MethodOrMethodContext)>
<soot.jimple.toolkits.callgraph.ReachableMethods: void addMethods(java.util.Iterator)>
<soot.jimple.toolkits.callgraph.ReachableMethods: void update()>
<soot.jimple.toolkits.callgraph.Targets: boolean hasNext()>
<soot.jimple.toolkits.callgraph.Targets: void <init>(java.util.Iterator)>
<soot.jimple.toolkits.callgraph.UnreachableMethodTransformer: void <init>()>
<soot.jimple.toolkits.callgraph.VirtualCallSite: soot.Kind kind()>
<soot.jimple.toolkits.callgraph.VirtualCallSite: soot.SootMethod container()>
<soot.jimple.toolkits.callgraph.VirtualCallSite: soot.jimple.InstanceInvokeExpr iie()>
<soot.jimple.toolkits.callgraph.VirtualCallSite: soot.jimple.Stmt stmt()>
<soot.jimple.toolkits.callgraph.VirtualCallSite: soot.util.NumberedString subSig()>
<soot.jimple.toolkits.callgraph.VirtualCallSite: void <init>(soot.jimple.Stmt,soot.SootMethod,soot.jimple.InstanceInvokeExpr,soot.util.NumberedString,soot.Kind)>
<soot.jimple.toolkits.callgraph.VirtualCalls: soot.SootMethod resolveNonSpecial(soot.RefType,soot.util.NumberedString)>
<soot.jimple.toolkits.callgraph.VirtualCalls: soot.SootMethod resolveSpecial(soot.jimple.SpecialInvokeExpr,soot.util.NumberedString,soot.SootMethod)>
<soot.jimple.toolkits.callgraph.VirtualCalls: soot.jimple.toolkits.callgraph.VirtualCalls v()>
<soot.jimple.toolkits.callgraph.VirtualCalls: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.callgraph.VirtualCalls: void resolve(soot.Type,soot.Type,soot.Type,soot.util.NumberedString,soot.SootMethod,soot.util.queue.ChunkedQueue)>
<soot.jimple.toolkits.callgraph.VirtualCalls: void resolve(soot.Type,soot.Type,soot.util.NumberedString,soot.SootMethod,soot.util.queue.ChunkedQueue)>
<soot.jimple.toolkits.invoke.StaticInliner: soot.jimple.toolkits.invoke.StaticInliner v()>
<soot.jimple.toolkits.invoke.StaticInliner: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.invoke.StaticMethodBinder: soot.jimple.toolkits.invoke.StaticMethodBinder v()>
<soot.jimple.toolkits.invoke.StaticMethodBinder: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.CastCheckEliminatorDumper: soot.jimple.toolkits.pointer.CastCheckEliminatorDumper v()>
<soot.jimple.toolkits.pointer.CastCheckEliminatorDumper: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.DependenceTagAggregator: soot.jimple.toolkits.pointer.DependenceTagAggregator v()>
<soot.jimple.toolkits.pointer.DependenceTagAggregator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.ParameterAliasTagger: soot.jimple.toolkits.pointer.ParameterAliasTagger v()>
<soot.jimple.toolkits.pointer.ParameterAliasTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.SideEffectTagger: soot.jimple.toolkits.pointer.SideEffectTagger v()>
<soot.jimple.toolkits.pointer.SideEffectTagger: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileDescriptorNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileDescriptorNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileInputStreamNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileInputStreamNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileOutputStreamNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileOutputStreamNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileSystemNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileSystemNative: void java_io_FileSystem_getFileSystem(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoFileSystemNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoObjectInputStreamNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoObjectOutputStreamNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoObjectStreamClassNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaIoObjectStreamClassNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassLoaderNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassLoaderNative: void java_lang_ClassLoader_findBootstrapClass(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassLoaderNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassLoaderNativeLibraryNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassLoaderNativeLibraryNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_forName0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getClassLoader0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getComponentType(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getDeclaredConstructors0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getDeclaringClass(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getInterfaces(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getPrimitiveClass(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getProtectionDomain0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getSigners(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void java_lang_Class_getSuperclass(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangClassNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangDoubleNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangDoubleNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangFloatNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangFloatNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangObjectNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangObjectNative: void java_lang_Object_clone(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangObjectNative: void java_lang_Object_getClass(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangObjectNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangPackageNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangPackageNative: void java_lang_Package_getSystemPackage0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangPackageNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectArrayNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectArrayNative: void java_lang_reflect_Array_newArray(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectArrayNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectConstructorNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectFieldNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectMethodNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangReflectProxyNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangRuntimeNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangRuntimeNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSecurityManagerNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSecurityManagerNative: void java_lang_SecurityManager_getClassContext(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSecurityManagerNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangShutdownNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangShutdownNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangStrictMathNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangStringNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangStringNative: void java_lang_String_intern(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangStringNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void java_lang_System_arraycopy(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void java_lang_System_initProperties(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void java_lang_System_mapLibraryName(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void java_lang_System_setErr0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void java_lang_System_setIn0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void java_lang_System_setOut0(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangSystemNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangThreadNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangThreadNative: void java_lang_Thread_currentThread(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangThreadNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangThrowableNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangThrowableNative: void java_lang_Throwable_fillInStackTrace(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaLangThrowableNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaNetInetAddressImplNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaNetInetAddressNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaNetInetAddressNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaSecurityAccessControllerNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaSecurityAccessControllerNative: void java_security_AccessController_doPrivileged(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaSecurityAccessControllerNative: void java_security_AccessController_getInheritedAccessControlContext(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaSecurityAccessControllerNative: void java_security_AccessController_getStackAccessControlContext(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaSecurityAccessControllerNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilJarJarFileNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilJarJarFileNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilResourceBundleNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilResourceBundleNative: void java_util_ResourceBundle_getClassContext(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilResourceBundleNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilTimeZoneNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilTimeZoneNative: void java_util_TimeZone_getSystemTimeZoneID(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilTimeZoneNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipCRC32Native: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipCRC32Native: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipInflaterNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipInflaterNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipZipEntryNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipZipEntryNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipZipFileNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.JavaUtilZipZipFileNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.NativeMethodClass: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.NativeMethodClass: void defaultMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.NativeMethodNotSupportedException: void <init>(soot.SootMethod)>
<soot.jimple.toolkits.pointer.nativemethods.SunMiscSignalHandlerNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.SunMiscSignalNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.SunMiscSignalNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.SunMiscUnsafeNative: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.pointer.nativemethods.SunMiscUnsafeNative: void simulateMethod(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.nativemethods.SunMiscUnsafeNative: void sun_misc_Unsafe_allocateInstance(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.representations.ConstantObject: void <init>()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getClassLoaderObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getClassObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getConstructorObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getFileSystemObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getLeastArrayObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getLeastObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getPrivilegedActionExceptionObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getStringObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.ConstantObject getThreadObject()>
<soot.jimple.toolkits.pointer.representations.Environment: soot.jimple.toolkits.pointer.representations.Environment v()>
<soot.jimple.toolkits.pointer.representations.Environment: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.representations.GeneralConstObject: soot.Type getType()>
<soot.jimple.toolkits.pointer.representations.GeneralConstObject: void <init>(soot.Type,java.lang.String)>
<soot.jimple.toolkits.pointer.representations.TypeConstants: soot.jimple.toolkits.pointer.representations.TypeConstants v()>
<soot.jimple.toolkits.pointer.representations.TypeConstants: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.pointer.util.NativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable arrayElementOf(soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.toolkits.pointer.util.NativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable cloneObject(soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.toolkits.pointer.util.NativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable newInstanceOf(soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.toolkits.pointer.util.NativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable staticField(java.lang.String,java.lang.String)>
<soot.jimple.toolkits.pointer.util.NativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable tempField(java.lang.String)>
<soot.jimple.toolkits.pointer.util.NativeHelper: soot.jimple.toolkits.pointer.representations.ReferenceVariable tempLocalVariable(soot.SootMethod)>
<soot.jimple.toolkits.pointer.util.NativeHelper: void <init>()>
<soot.jimple.toolkits.pointer.util.NativeHelper: void assign(soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable)>
<soot.jimple.toolkits.pointer.util.NativeHelper: void assignObjectTo(soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.AbstractObject)>
<soot.jimple.toolkits.pointer.util.NativeHelper: void throwException(soot.jimple.toolkits.pointer.representations.AbstractObject)>
<soot.jimple.toolkits.pointer.util.NativeMethodDriver: boolean process(soot.SootMethod,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable,soot.jimple.toolkits.pointer.representations.ReferenceVariable[])>
<soot.jimple.toolkits.pointer.util.NativeMethodDriver: void <init>(soot.jimple.toolkits.pointer.util.NativeHelper)>
<soot.jimple.toolkits.scalar.CommonSubexpressionEliminator: soot.jimple.toolkits.scalar.CommonSubexpressionEliminator v()>
<soot.jimple.toolkits.scalar.CommonSubexpressionEliminator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.ConditionalBranchFolder: soot.jimple.toolkits.scalar.ConditionalBranchFolder v()>
<soot.jimple.toolkits.scalar.ConditionalBranchFolder: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.ConstantPropagatorAndFolder: soot.jimple.toolkits.scalar.ConstantPropagatorAndFolder v()>
<soot.jimple.toolkits.scalar.ConstantPropagatorAndFolder: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.CopyPropagator: soot.jimple.toolkits.scalar.CopyPropagator v()>
<soot.jimple.toolkits.scalar.CopyPropagator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.CopyPropagator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.scalar.DeadAssignmentEliminator: soot.jimple.toolkits.scalar.DeadAssignmentEliminator v()>
<soot.jimple.toolkits.scalar.DeadAssignmentEliminator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.DeadAssignmentEliminator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.scalar.LocalNameStandardizer: soot.jimple.toolkits.scalar.LocalNameStandardizer v()>
<soot.jimple.toolkits.scalar.LocalNameStandardizer: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.LocalNameStandardizer: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.scalar.NopEliminator: soot.jimple.toolkits.scalar.NopEliminator v()>
<soot.jimple.toolkits.scalar.NopEliminator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.NopEliminator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.scalar.UnconditionalBranchFolder: soot.jimple.toolkits.scalar.UnconditionalBranchFolder v()>
<soot.jimple.toolkits.scalar.UnconditionalBranchFolder: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.UnreachableCodeEliminator$Instance: void <init>(soot.jimple.toolkits.scalar.UnreachableCodeEliminator)>
<soot.jimple.toolkits.scalar.UnreachableCodeEliminator$Instance: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.scalar.UnreachableCodeEliminator$Instance: void visitStmts(java.util.LinkedList)>
<soot.jimple.toolkits.scalar.UnreachableCodeEliminator: soot.jimple.toolkits.scalar.UnreachableCodeEliminator v()>
<soot.jimple.toolkits.scalar.UnreachableCodeEliminator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.UnreachableCodeEliminator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.scalar.pre.BusyCodeMotion: soot.jimple.toolkits.scalar.pre.BusyCodeMotion v()>
<soot.jimple.toolkits.scalar.pre.BusyCodeMotion: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.scalar.pre.LazyCodeMotion: soot.jimple.toolkits.scalar.pre.LazyCodeMotion v()>
<soot.jimple.toolkits.scalar.pre.LazyCodeMotion: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.thread.synchronization.LockAllocator: soot.jimple.toolkits.thread.synchronization.LockAllocator v()>
<soot.jimple.toolkits.thread.synchronization.LockAllocator: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.typing.TypeAssigner: boolean typingFailed(soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.TypeAssigner: soot.jimple.toolkits.typing.TypeAssigner v()>
<soot.jimple.toolkits.typing.TypeAssigner: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.typing.TypeAssigner: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.jimple.toolkits.typing.fast.AugEvalFunction: java.util.Collection eval(soot.jimple.toolkits.typing.fast.Typing,soot.Value,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.fast.AugEvalFunction: soot.Type eval_(soot.jimple.toolkits.typing.fast.Typing,soot.Value,soot.jimple.Stmt,soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.fast.AugEvalFunction: void <init>(soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.fast.AugHierarchy: boolean ancestor_(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.AugHierarchy: java.util.Collection lcas(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.AugHierarchy: java.util.Collection lcas_(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.AugHierarchy: void <init>()>
<soot.jimple.toolkits.typing.fast.BottomType: boolean equals(java.lang.Object)>
<soot.jimple.toolkits.typing.fast.BottomType: soot.jimple.toolkits.typing.fast.BottomType v()>
<soot.jimple.toolkits.typing.fast.BottomType: void <clinit>()>
<soot.jimple.toolkits.typing.fast.BottomType: void <init>()>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy$AncestryTreeNode: void <init>(soot.jimple.toolkits.typing.fast.BytecodeHierarchy$AncestryTreeNode,soot.RefType)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: boolean ancestor(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: boolean ancestor_(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: java.util.Collection buildAncestryTree(soot.RefType)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: java.util.Collection lcas(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: java.util.Collection lcas_(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: java.util.LinkedList superclassPath(soot.RefType)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: soot.RefType lcsc(soot.RefType,soot.RefType)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: soot.RefType leastCommonNode(soot.jimple.toolkits.typing.fast.BytecodeHierarchy$AncestryTreeNode,soot.jimple.toolkits.typing.fast.BytecodeHierarchy$AncestryTreeNode)>
<soot.jimple.toolkits.typing.fast.BytecodeHierarchy: void <init>()>
<soot.jimple.toolkits.typing.fast.Integer127Type: boolean equals(java.lang.Object)>
<soot.jimple.toolkits.typing.fast.Integer127Type: soot.jimple.toolkits.typing.fast.Integer127Type v()>
<soot.jimple.toolkits.typing.fast.Integer127Type: void <clinit>()>
<soot.jimple.toolkits.typing.fast.Integer127Type: void <init>()>
<soot.jimple.toolkits.typing.fast.Integer1Type: boolean equals(java.lang.Object)>
<soot.jimple.toolkits.typing.fast.Integer1Type: soot.jimple.toolkits.typing.fast.Integer1Type v()>
<soot.jimple.toolkits.typing.fast.Integer1Type: void <clinit>()>
<soot.jimple.toolkits.typing.fast.Integer1Type: void <init>()>
<soot.jimple.toolkits.typing.fast.Integer32767Type: boolean equals(java.lang.Object)>
<soot.jimple.toolkits.typing.fast.Integer32767Type: soot.jimple.toolkits.typing.fast.Integer32767Type v()>
<soot.jimple.toolkits.typing.fast.Integer32767Type: void <clinit>()>
<soot.jimple.toolkits.typing.fast.Integer32767Type: void <init>()>
<soot.jimple.toolkits.typing.fast.QueuedSet: boolean addLast(java.lang.Object)>
<soot.jimple.toolkits.typing.fast.QueuedSet: boolean isEmpty()>
<soot.jimple.toolkits.typing.fast.QueuedSet: int addLast(java.util.List)>
<soot.jimple.toolkits.typing.fast.QueuedSet: java.lang.Object removeFirst()>
<soot.jimple.toolkits.typing.fast.QueuedSet: void <init>()>
<soot.jimple.toolkits.typing.fast.QueuedSet: void <init>(java.util.List)>
<soot.jimple.toolkits.typing.fast.QueuedSet: void <init>(soot.jimple.toolkits.typing.fast.QueuedSet)>
<soot.jimple.toolkits.typing.fast.SingletonList: int size()>
<soot.jimple.toolkits.typing.fast.SingletonList: java.lang.Object get(int)>
<soot.jimple.toolkits.typing.fast.SingletonList: void <init>(java.lang.Object)>
<soot.jimple.toolkits.typing.fast.TypeResolver$CastInsertionUseVisitor: boolean finish()>
<soot.jimple.toolkits.typing.fast.TypeResolver$CastInsertionUseVisitor: int getCount()>
<soot.jimple.toolkits.typing.fast.TypeResolver$CastInsertionUseVisitor: soot.Value visit(soot.Value,soot.Type,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.fast.TypeResolver$CastInsertionUseVisitor: void <init>(soot.jimple.toolkits.typing.fast.TypeResolver,boolean,soot.jimple.JimpleBody,soot.jimple.toolkits.typing.fast.Typing,soot.jimple.toolkits.typing.fast.IHierarchy)>
<soot.jimple.toolkits.typing.fast.TypeResolver$TypePromotionUseVisitor: boolean finish()>
<soot.jimple.toolkits.typing.fast.TypeResolver$TypePromotionUseVisitor: soot.Type promote(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.TypeResolver$TypePromotionUseVisitor: soot.Value visit(soot.Value,soot.Type,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.fast.TypeResolver$TypePromotionUseVisitor: void <init>(soot.jimple.toolkits.typing.fast.TypeResolver,soot.jimple.JimpleBody,soot.jimple.toolkits.typing.fast.Typing)>
<soot.jimple.toolkits.typing.fast.TypeResolver: boolean typesEqual(soot.Type,soot.Type)>
<soot.jimple.toolkits.typing.fast.TypeResolver: int insertCasts(soot.jimple.toolkits.typing.fast.Typing,soot.jimple.toolkits.typing.fast.IHierarchy,boolean)>
<soot.jimple.toolkits.typing.fast.TypeResolver: java.util.Collection applyAssignmentConstraints(soot.jimple.toolkits.typing.fast.Typing,soot.jimple.toolkits.typing.fast.IEvalFunction,soot.jimple.toolkits.typing.fast.IHierarchy)>
<soot.jimple.toolkits.typing.fast.TypeResolver: soot.jimple.toolkits.typing.fast.Typing minCasts(java.util.Collection,soot.jimple.toolkits.typing.fast.IHierarchy,int[])>
<soot.jimple.toolkits.typing.fast.TypeResolver: soot.jimple.toolkits.typing.fast.Typing typePromotion(soot.jimple.toolkits.typing.fast.Typing)>
<soot.jimple.toolkits.typing.fast.TypeResolver: void <init>(soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.fast.TypeResolver: void addDepend(soot.Local,soot.jimple.DefinitionStmt)>
<soot.jimple.toolkits.typing.fast.TypeResolver: void addLocal(soot.Local)>
<soot.jimple.toolkits.typing.fast.TypeResolver: void inferTypes()>
<soot.jimple.toolkits.typing.fast.TypeResolver: void initAssignment(soot.jimple.DefinitionStmt)>
<soot.jimple.toolkits.typing.fast.TypeResolver: void initAssignments()>
<soot.jimple.toolkits.typing.fast.TypeResolver: void split_new()>
<soot.jimple.toolkits.typing.fast.Typing: int compare(soot.jimple.toolkits.typing.fast.Typing,soot.jimple.toolkits.typing.fast.Typing,soot.jimple.toolkits.typing.fast.IHierarchy)>
<soot.jimple.toolkits.typing.fast.Typing: soot.Type get(soot.Local)>
<soot.jimple.toolkits.typing.fast.Typing: soot.Type set(soot.Local,soot.Type)>
<soot.jimple.toolkits.typing.fast.Typing: void <init>(java.util.Collection)>
<soot.jimple.toolkits.typing.fast.Typing: void <init>(soot.jimple.toolkits.typing.fast.Typing)>
<soot.jimple.toolkits.typing.fast.Typing: void minimize(java.util.List,soot.jimple.toolkits.typing.fast.IHierarchy)>
<soot.jimple.toolkits.typing.fast.UseChecker: void <init>(soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseAssignStmt(soot.jimple.AssignStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseEnterMonitorStmt(soot.jimple.EnterMonitorStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseExitMonitorStmt(soot.jimple.ExitMonitorStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseGotoStmt(soot.jimple.GotoStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseIdentityStmt(soot.jimple.IdentityStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseIfStmt(soot.jimple.IfStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseInvokeStmt(soot.jimple.InvokeStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseLookupSwitchStmt(soot.jimple.LookupSwitchStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseNopStmt(soot.jimple.NopStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseReturnStmt(soot.jimple.ReturnStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseReturnVoidStmt(soot.jimple.ReturnVoidStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseTableSwitchStmt(soot.jimple.TableSwitchStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void caseThrowStmt(soot.jimple.ThrowStmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void check(soot.jimple.toolkits.typing.fast.Typing,soot.jimple.toolkits.typing.fast.IUseVisitor)>
<soot.jimple.toolkits.typing.fast.UseChecker: void handleArrayRef(soot.jimple.ArrayRef,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void handleBinopExpr(soot.jimple.BinopExpr,soot.jimple.Stmt,soot.Type)>
<soot.jimple.toolkits.typing.fast.UseChecker: void handleInstanceFieldRef(soot.jimple.InstanceFieldRef,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.fast.UseChecker: void handleInvokeExpr(soot.jimple.InvokeExpr,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: boolean hasAncestor_1(int,int)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: int convert(int)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: soot.jimple.toolkits.typing.integer.ClassHierarchy v()>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: soot.jimple.toolkits.typing.integer.TypeNode gcd_2(int,int)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: soot.jimple.toolkits.typing.integer.TypeNode lca_1(int,int)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: soot.jimple.toolkits.typing.integer.TypeNode lca_2(int,int)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: soot.jimple.toolkits.typing.integer.TypeNode typeNode(soot.Type)>
<soot.jimple.toolkits.typing.integer.ClassHierarchy: void <init>(soot.Singletons$Global)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void <init>(soot.jimple.toolkits.typing.integer.TypeResolver,boolean)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseAssignStmt(soot.jimple.AssignStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseGotoStmt(soot.jimple.GotoStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseIdentityStmt(soot.jimple.IdentityStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseIfStmt(soot.jimple.IfStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseInvokeStmt(soot.jimple.InvokeStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseNopStmt(soot.jimple.NopStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseReturnStmt(soot.jimple.ReturnStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseTableSwitchStmt(soot.jimple.TableSwitchStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void caseThrowStmt(soot.jimple.ThrowStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void check(soot.jimple.Stmt,soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.integer.ConstraintChecker: void handleInvokeExpr(soot.jimple.InvokeExpr,soot.jimple.Stmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void <init>(soot.jimple.toolkits.typing.integer.TypeResolver,boolean)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseAssignStmt(soot.jimple.AssignStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseGotoStmt(soot.jimple.GotoStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseIdentityStmt(soot.jimple.IdentityStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseIfStmt(soot.jimple.IfStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseInvokeStmt(soot.jimple.InvokeStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseNopStmt(soot.jimple.NopStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseReturnStmt(soot.jimple.ReturnStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseTableSwitchStmt(soot.jimple.TableSwitchStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void caseThrowStmt(soot.jimple.ThrowStmt)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void collect(soot.jimple.Stmt,soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.integer.ConstraintCollector: void handleInvokeExpr(soot.jimple.InvokeExpr)>
<soot.jimple.toolkits.typing.integer.StronglyConnectedComponents: void <init>(java.util.List)>
<soot.jimple.toolkits.typing.integer.StronglyConnectedComponents: void dfsg_visit(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.StronglyConnectedComponents: void dfsgt_visit(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.StronglyConnectedComponents: void merge(java.util.List)>
<soot.jimple.toolkits.typing.integer.TypeNode: boolean hasAncestor_1(soot.jimple.toolkits.typing.integer.TypeNode)>
<soot.jimple.toolkits.typing.integer.TypeNode: soot.Type type()>
<soot.jimple.toolkits.typing.integer.TypeNode: soot.jimple.toolkits.typing.integer.TypeNode gcd_2(soot.jimple.toolkits.typing.integer.TypeNode)>
<soot.jimple.toolkits.typing.integer.TypeNode: soot.jimple.toolkits.typing.integer.TypeNode lca_1(soot.jimple.toolkits.typing.integer.TypeNode)>
<soot.jimple.toolkits.typing.integer.TypeNode: soot.jimple.toolkits.typing.integer.TypeNode lca_2(soot.jimple.toolkits.typing.integer.TypeNode)>
<soot.jimple.toolkits.typing.integer.TypeNode: void <init>(int,soot.Type)>
<soot.jimple.toolkits.typing.integer.TypeResolver: soot.jimple.toolkits.typing.integer.TypeVariable typeVariable()>
<soot.jimple.toolkits.typing.integer.TypeResolver: soot.jimple.toolkits.typing.integer.TypeVariable typeVariable(soot.Local)>
<soot.jimple.toolkits.typing.integer.TypeResolver: soot.jimple.toolkits.typing.integer.TypeVariable typeVariable(soot.Type)>
<soot.jimple.toolkits.typing.integer.TypeResolver: soot.jimple.toolkits.typing.integer.TypeVariable typeVariable(soot.jimple.toolkits.typing.integer.TypeNode)>
<soot.jimple.toolkits.typing.integer.TypeResolver: void <init>(soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.integer.TypeResolver: void assign_types_1()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void check_constraints()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void collect_constraints_1()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void compute_approximate_types()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void compute_solved()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void debug_vars(java.lang.String)>
<soot.jimple.toolkits.typing.integer.TypeResolver: void merge_connected_components()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void merge_single_constraints()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void refresh_solved()>
<soot.jimple.toolkits.typing.integer.TypeResolver: void resolve(soot.jimple.JimpleBody)>
<soot.jimple.toolkits.typing.integer.TypeResolver: void resolve_step_1()>
<soot.jimple.toolkits.typing.integer.TypeVariable: int compareTo(java.lang.Object)>
<soot.jimple.toolkits.typing.integer.TypeVariable: java.util.List children()>
<soot.jimple.toolkits.typing.integer.TypeVariable: java.util.List parents()>
<soot.jimple.toolkits.typing.integer.TypeVariable: soot.jimple.toolkits.typing.integer.TypeNode approx()>
<soot.jimple.toolkits.typing.integer.TypeVariable: soot.jimple.toolkits.typing.integer.TypeNode inv_approx()>
<soot.jimple.toolkits.typing.integer.TypeVariable: soot.jimple.toolkits.typing.integer.TypeNode type()>
<soot.jimple.toolkits.typing.integer.TypeVariable: soot.jimple.toolkits.typing.integer.TypeVariable ecr()>
<soot.jimple.toolkits.typing.integer.TypeVariable: soot.jimple.toolkits.typing.integer.TypeVariable union(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void <init>(int,soot.jimple.toolkits.typing.integer.TypeResolver)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void <init>(int,soot.jimple.toolkits.typing.integer.TypeResolver,soot.jimple.toolkits.typing.integer.TypeNode)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void addChild(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void addParent(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void clear()>
<soot.jimple.toolkits.typing.integer.TypeVariable: void computeApprox(java.util.TreeSet)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void computeInvApprox(java.util.TreeSet)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void fixApprox(java.util.TreeSet)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void fixChildren()>
<soot.jimple.toolkits.typing.integer.TypeVariable: void fixInvApprox(java.util.TreeSet)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void fixParents()>
<soot.jimple.toolkits.typing.integer.TypeVariable: void merge(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void removeChild(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.jimple.toolkits.typing.integer.TypeVariable: void removeParent(soot.jimple.toolkits.typing.integer.TypeVariable)>
<soot.options.CGOptions: boolean all_reachable()>
<soot.options.CGOptions: boolean implicit_entry()>
<soot.options.CGOptions: boolean safe_forname()>
<soot.options.CGOptions: boolean safe_newinstance()>
<soot.options.CGOptions: boolean trim_clinit()>
<soot.options.CGOptions: boolean verbose()>
<soot.options.CGOptions: int jdkver()>
<soot.options.CGOptions: void <init>(java.util.Map)>
<soot.options.CPOptions: boolean only_regular_locals()>
<soot.options.CPOptions: boolean only_stack_locals()>
<soot.options.CPOptions: void <init>(java.util.Map)>
<soot.options.JBOptions: boolean use_original_names()>
<soot.options.JBOptions: void <init>(java.util.Map)>
<soot.options.JBTROptions: boolean compare_type_assigners()>
<soot.options.JBTROptions: boolean use_older_type_assigner()>
<soot.options.JBTROptions: void <init>(java.util.Map)>
<soot.options.Options: boolean allow_phantom_refs()>
<soot.options.Options: boolean app()>
<soot.options.Options: boolean ast_metrics()>
<soot.options.Options: boolean debug()>
<soot.options.Options: boolean debug_resolver()>
<soot.options.Options: boolean gzip()>
<soot.options.Options: boolean help()>
<soot.options.Options: boolean include_all()>
<soot.options.Options: boolean interactive_mode()>
<soot.options.Options: boolean j2me()>
<soot.options.Options: boolean keep_line_number()>
<soot.options.Options: boolean keep_offset()>
<soot.options.Options: boolean no_output_source_file_attribute()>
<soot.options.Options: boolean omit_excepting_unit_edges()>
<soot.options.Options: boolean output_jar()>
<soot.options.Options: boolean parse(java.lang.String[])>
<soot.options.Options: boolean phase_list()>
<soot.options.Options: boolean prepend_classpath()>
<soot.options.Options: boolean subtract_gc()>
<soot.options.Options: boolean time()>
<soot.options.Options: boolean validate()>
<soot.options.Options: boolean verbose()>
<soot.options.Options: boolean version()>
<soot.options.Options: boolean via_grimp()>
<soot.options.Options: boolean via_shimple()>
<soot.options.Options: boolean whole_program()>
<soot.options.Options: boolean whole_shimple()>
<soot.options.Options: boolean xml_attributes()>
<soot.options.Options: int output_format()>
<soot.options.Options: int src_prec()>
<soot.options.Options: int throw_analysis()>
<soot.options.Options: java.lang.String getDeclaredOptionsForPhase(java.lang.String)>
<soot.options.Options: java.lang.String getDefaultOptionsForPhase(java.lang.String)>
<soot.options.Options: java.lang.String main_class()>
<soot.options.Options: java.lang.String output_dir()>
<soot.options.Options: java.lang.String soot_classpath()>
<soot.options.Options: java.util.List dump_body()>
<soot.options.Options: java.util.List dump_cfg()>
<soot.options.Options: java.util.List dynamic_class()>
<soot.options.Options: java.util.List dynamic_dir()>
<soot.options.Options: java.util.List dynamic_package()>
<soot.options.Options: java.util.List exclude()>
<soot.options.Options: java.util.List include()>
<soot.options.Options: java.util.List phase_help()>
<soot.options.Options: java.util.List process_dir()>
<soot.options.Options: soot.options.Options v()>
<soot.options.Options: void <init>(soot.Singletons$Global)>
<soot.options.Options: void warnForeignPhase(java.lang.String)>
<soot.options.Options: void warnNonexistentPhase()>
<soot.options.OptionsBase: boolean hasMoreOptions()>
<soot.options.OptionsBase: boolean setPhaseOption(java.lang.String,java.lang.String)>
<soot.options.OptionsBase: java.lang.String nextOption()>
<soot.options.OptionsBase: java.util.LinkedList classes()>
<soot.options.OptionsBase: void <init>()>
<soot.options.OptionsBase: void pushOptions(java.lang.String)>
<soot.options.SparkOptions: boolean add_tags()>
<soot.options.SparkOptions: boolean cs_demand()>
<soot.options.SparkOptions: boolean dump_answer()>
<soot.options.SparkOptions: boolean dump_html()>
<soot.options.SparkOptions: boolean dump_pag()>
<soot.options.SparkOptions: boolean dump_solution()>
<soot.options.SparkOptions: boolean empties_as_allocs()>
<soot.options.SparkOptions: boolean field_based()>
<soot.options.SparkOptions: boolean force_gc()>
<soot.options.SparkOptions: boolean ignore_types()>
<soot.options.SparkOptions: boolean merge_stringbuffer()>
<soot.options.SparkOptions: boolean on_fly_cg()>
<soot.options.SparkOptions: boolean pre_jimplify()>
<soot.options.SparkOptions: boolean rta()>
<soot.options.SparkOptions: boolean set_mass()>
<soot.options.SparkOptions: boolean simple_edges_bidirectional()>
<soot.options.SparkOptions: boolean simplify_offline()>
<soot.options.SparkOptions: boolean simplify_sccs()>
<soot.options.SparkOptions: boolean simulate_natives()>
<soot.options.SparkOptions: boolean string_constants()>
<soot.options.SparkOptions: boolean types_for_sites()>
<soot.options.SparkOptions: boolean verbose()>
<soot.options.SparkOptions: boolean vta()>
<soot.options.SparkOptions: int double_set_new()>
<soot.options.SparkOptions: int double_set_old()>
<soot.options.SparkOptions: int propagator()>
<soot.options.SparkOptions: int set_impl()>
<soot.options.SparkOptions: void <init>(java.util.Map)>
<soot.shimple.AbstractShimpleValueSwitch: void <init>()>
<soot.shimple.DefaultShimpleFactory: void <init>()>
<soot.shimple.toolkits.scalar.SConstantPropagatorAndFolder: soot.shimple.toolkits.scalar.SConstantPropagatorAndFolder v()>
<soot.shimple.toolkits.scalar.SConstantPropagatorAndFolder: void <init>(soot.Singletons$Global)>
<soot.tagkit.AbstractHost: boolean hasTag(java.lang.String)>
<soot.tagkit.AbstractHost: int searchForTag(java.lang.String)>
<soot.tagkit.AbstractHost: java.util.List getTags()>
<soot.tagkit.AbstractHost: soot.tagkit.Tag getTag(java.lang.String)>
<soot.tagkit.AbstractHost: void <clinit>()>
<soot.tagkit.AbstractHost: void <init>()>
<soot.tagkit.AbstractHost: void addAllTagsOf(soot.tagkit.Host)>
<soot.tagkit.AbstractHost: void addTag(soot.tagkit.Tag)>
<soot.tagkit.AnnotationArrayElem: void <init>(java.util.ArrayList,char,java.lang.String)>
<soot.tagkit.AnnotationElem: void <init>(char,java.lang.String)>
<soot.tagkit.AnnotationEnumElem: void <init>(java.lang.String,java.lang.String,char,java.lang.String)>
<soot.tagkit.AnnotationTag: void <init>(java.lang.String,int)>
<soot.tagkit.AnnotationTag: void setElems(java.util.ArrayList)>
<soot.tagkit.ConstantValueTag: void <init>()>
<soot.tagkit.DeprecatedTag: void <init>()>
<soot.tagkit.DoubleConstantValueTag: void <init>(double)>
<soot.tagkit.EnclosingMethodTag: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<soot.tagkit.FirstTagAggregator: void <init>()>
<soot.tagkit.FloatConstantValueTag: void <init>(float)>
<soot.tagkit.ImportantTagAggregator: void <init>()>
<soot.tagkit.InnerClassTag: void <init>(java.lang.String,java.lang.String,java.lang.String,int)>
<soot.tagkit.InnerClassTagAggregator: soot.tagkit.InnerClassTagAggregator v()>
<soot.tagkit.InnerClassTagAggregator: void <init>(soot.Singletons$Global)>
<soot.tagkit.InnerClassTagAggregator: void internalTransform(java.lang.String,java.util.Map)>
<soot.tagkit.IntegerConstantValueTag: void <init>(int)>
<soot.tagkit.LineNumberTagAggregator: soot.tagkit.LineNumberTagAggregator v()>
<soot.tagkit.LineNumberTagAggregator: void <init>(soot.Singletons$Global)>
<soot.tagkit.LongConstantValueTag: void <init>(long)>
<soot.tagkit.SignatureTag: void <init>(java.lang.String)>
<soot.tagkit.SourceFileTag: java.lang.String getName()>
<soot.tagkit.SourceFileTag: java.lang.String getSourceFile()>
<soot.tagkit.SourceFileTag: void <init>(java.lang.String)>
<soot.tagkit.StringConstantValueTag: void <init>(java.lang.String)>
<soot.tagkit.TagAggregator: void <init>()>
<soot.tagkit.TagAggregator: void fini()>
<soot.tagkit.TagAggregator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.tagkit.VisibilityAnnotationTag: void <init>(int)>
<soot.tagkit.VisibilityAnnotationTag: void addAnnotation(soot.tagkit.AnnotationTag)>
<soot.toolkits.exceptions.AbstractThrowAnalysis: soot.toolkits.exceptions.ThrowableSet mightThrowExplicitly(soot.jimple.ThrowStmt)>
<soot.toolkits.exceptions.AbstractThrowAnalysis: void <init>()>
<soot.toolkits.exceptions.PedanticThrowAnalysis: soot.toolkits.exceptions.PedanticThrowAnalysis v()>
<soot.toolkits.exceptions.PedanticThrowAnalysis: soot.toolkits.exceptions.ThrowableSet mightThrow(soot.Unit)>
<soot.toolkits.exceptions.PedanticThrowAnalysis: soot.toolkits.exceptions.ThrowableSet mightThrowImplicitly(soot.jimple.ThrowStmt)>
<soot.toolkits.exceptions.PedanticThrowAnalysis: void <init>(soot.Singletons$Global)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$1008(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$1308(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$1408(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$1608(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$1708(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$508(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$608(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: int access$708(soot.toolkits.exceptions.ThrowableSet$Manager)>
<soot.toolkits.exceptions.ThrowableSet$Manager: soot.toolkits.exceptions.ThrowableSet access$900(soot.toolkits.exceptions.ThrowableSet$Manager,java.util.Set,java.util.Set)>
<soot.toolkits.exceptions.ThrowableSet$Manager: soot.toolkits.exceptions.ThrowableSet registerSetIfNew(java.util.Set,java.util.Set)>
<soot.toolkits.exceptions.ThrowableSet$Manager: soot.toolkits.exceptions.ThrowableSet$Manager v()>
<soot.toolkits.exceptions.ThrowableSet$Manager: void <init>(soot.Singletons$Global)>
<soot.toolkits.exceptions.ThrowableSet$Pair: soot.toolkits.exceptions.ThrowableSet getCaught()>
<soot.toolkits.exceptions.ThrowableSet$Pair: soot.toolkits.exceptions.ThrowableSet getUncaught()>
<soot.toolkits.exceptions.ThrowableSet$Pair: void <init>(soot.toolkits.exceptions.ThrowableSet,soot.toolkits.exceptions.ThrowableSet)>
<soot.toolkits.exceptions.ThrowableSet: boolean catchableAs(soot.RefType)>
<soot.toolkits.exceptions.ThrowableSet: java.util.Set access$000(soot.toolkits.exceptions.ThrowableSet)>
<soot.toolkits.exceptions.ThrowableSet: java.util.Set access$100(soot.toolkits.exceptions.ThrowableSet)>
<soot.toolkits.exceptions.ThrowableSet: java.util.Set addExceptionToSet(soot.RefLikeType,java.util.Set)>
<soot.toolkits.exceptions.ThrowableSet: soot.toolkits.exceptions.ThrowableSet add(soot.AnySubType)>
<soot.toolkits.exceptions.ThrowableSet: soot.toolkits.exceptions.ThrowableSet getMemoizedAdds(java.lang.Object)>
<soot.toolkits.exceptions.ThrowableSet: soot.toolkits.exceptions.ThrowableSet$Pair whichCatchableAs(soot.RefType)>
<soot.toolkits.exceptions.ThrowableSet: void <init>(java.util.Set,java.util.Set)>
<soot.toolkits.exceptions.ThrowableSet: void <init>(java.util.Set,java.util.Set,soot.toolkits.exceptions.ThrowableSet$1)>
<soot.toolkits.exceptions.TrapTightener: soot.toolkits.exceptions.TrapTightener v()>
<soot.toolkits.exceptions.TrapTightener: void <init>(soot.Singletons$Global)>
<soot.toolkits.graph.Block: boolean remove(soot.Unit)>
<soot.toolkits.graph.Block: java.util.Iterator iterator()>
<soot.toolkits.graph.Block: java.util.List getSuccs()>
<soot.toolkits.graph.Block: soot.Unit getHead()>
<soot.toolkits.graph.Block: soot.Unit getTail()>
<soot.toolkits.graph.Block: void <init>(soot.Unit,soot.Unit,soot.Body,int,int,soot.toolkits.graph.BlockGraph)>
<soot.toolkits.graph.Block: void setPreds(java.util.List)>
<soot.toolkits.graph.Block: void setSuccs(java.util.List)>
<soot.toolkits.graph.BlockGraph: java.util.List getBlocks()>
<soot.toolkits.graph.BlockGraph: java.util.List getHeads()>
<soot.toolkits.graph.BlockGraph: java.util.Map buildBlocks(java.util.Set,soot.toolkits.graph.UnitGraph)>
<soot.toolkits.graph.BlockGraph: java.util.Set computeLeaders(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.graph.BlockGraph: void <init>(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.graph.BlockGraph: void addBlock(soot.Unit,soot.Unit,int,int,java.util.List,java.util.Map)>
<soot.toolkits.graph.BriefBlockGraph: void <init>(soot.Body)>
<soot.toolkits.graph.BriefBlockGraph: void <init>(soot.toolkits.graph.BriefUnitGraph)>
<soot.toolkits.graph.BriefUnitGraph: void <init>(soot.Body)>
<soot.toolkits.graph.ExceptionalUnitGraph$1CFGEdge: void <init>(soot.toolkits.graph.ExceptionalUnitGraph,soot.Unit,soot.Unit)>
<soot.toolkits.graph.ExceptionalUnitGraph$ExceptionDest: soot.Trap getTrap()>
<soot.toolkits.graph.ExceptionalUnitGraph$ExceptionDest: void <init>(soot.Trap,soot.toolkits.exceptions.ThrowableSet)>
<soot.toolkits.graph.ExceptionalUnitGraph: boolean mightThrowToIntraproceduralCatcher(soot.Unit)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.Collection getExceptionDests(soot.Unit)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.List getExceptionalPredsOf(soot.Unit)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.List getExceptionalSuccsOf(soot.Unit)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.List getUnexceptionalPredsOf(soot.Unit)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.Map addDestToMap(java.util.Map,soot.Unit,soot.Trap,soot.toolkits.exceptions.ThrowableSet)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.Map buildExceptionDests(soot.toolkits.exceptions.ThrowAnalysis)>
<soot.toolkits.graph.ExceptionalUnitGraph: java.util.Set buildExceptionalEdges(soot.toolkits.exceptions.ThrowAnalysis,java.util.Map,java.util.Map,java.util.Map,boolean)>
<soot.toolkits.graph.ExceptionalUnitGraph: void <init>(soot.Body)>
<soot.toolkits.graph.ExceptionalUnitGraph: void <init>(soot.Body,soot.toolkits.exceptions.ThrowAnalysis,boolean)>
<soot.toolkits.graph.ExceptionalUnitGraph: void buildHeadsAndTails(java.util.Set)>
<soot.toolkits.graph.ExceptionalUnitGraph: void initialize(soot.toolkits.exceptions.ThrowAnalysis,boolean)>
<soot.toolkits.graph.HashMutableDirectedGraph: void <init>()>
<soot.toolkits.graph.PseudoTopologicalOrderer: java.util.List computeOrder(soot.toolkits.graph.DirectedGraph)>
<soot.toolkits.graph.PseudoTopologicalOrderer: java.util.List newList(soot.toolkits.graph.DirectedGraph,boolean)>
<soot.toolkits.graph.PseudoTopologicalOrderer: void <clinit>()>
<soot.toolkits.graph.PseudoTopologicalOrderer: void <init>()>
<soot.toolkits.graph.PseudoTopologicalOrderer: void visitNode(java.lang.Object)>
<soot.toolkits.graph.UnitGraph: int size()>
<soot.toolkits.graph.UnitGraph: java.util.Iterator iterator()>
<soot.toolkits.graph.UnitGraph: java.util.List getExtendedBasicBlockPathBetween(soot.Unit,soot.Unit)>
<soot.toolkits.graph.UnitGraph: java.util.List getHeads()>
<soot.toolkits.graph.UnitGraph: java.util.List getPredsOf(java.lang.Object)>
<soot.toolkits.graph.UnitGraph: java.util.List getPredsOf(soot.Unit)>
<soot.toolkits.graph.UnitGraph: java.util.List getSuccsOf(java.lang.Object)>
<soot.toolkits.graph.UnitGraph: java.util.List getSuccsOf(soot.Unit)>
<soot.toolkits.graph.UnitGraph: java.util.List getTails()>
<soot.toolkits.graph.UnitGraph: java.util.Map combineMapValues(java.util.Map,java.util.Map)>
<soot.toolkits.graph.UnitGraph: soot.Body getBody()>
<soot.toolkits.graph.UnitGraph: void <init>(soot.Body)>
<soot.toolkits.graph.UnitGraph: void addEdge(java.util.Map,java.util.Map,soot.Unit,soot.Unit)>
<soot.toolkits.graph.UnitGraph: void buildHeadsAndTails()>
<soot.toolkits.graph.UnitGraph: void buildUnexceptionalEdges(java.util.Map,java.util.Map)>
<soot.toolkits.graph.UnitGraph: void makeMappedListsUnmodifiable(java.util.Map)>
<soot.toolkits.graph.ZonedBlockGraph: java.util.Set computeLeaders(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.graph.ZonedBlockGraph: void <init>(soot.Body)>
<soot.toolkits.graph.ZonedBlockGraph: void <init>(soot.toolkits.graph.BriefUnitGraph)>
<soot.toolkits.scalar.AbstractBoundedFlowSet: void <init>()>
<soot.toolkits.scalar.AbstractFlowAnalysis: java.lang.Object getFlowBefore(java.lang.Object)>
<soot.toolkits.scalar.AbstractFlowAnalysis: void <init>(soot.toolkits.graph.DirectedGraph)>
<soot.toolkits.scalar.AbstractFlowAnalysis: void merge(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.AbstractFlowSet: void <init>()>
<soot.toolkits.scalar.AbstractFlowSet: void add(java.lang.Object,soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArrayFlowUniverse: int size()>
<soot.toolkits.scalar.ArrayFlowUniverse: java.util.Iterator iterator()>
<soot.toolkits.scalar.ArrayFlowUniverse: void <init>(java.lang.Object[])>
<soot.toolkits.scalar.ArrayPackedSet: boolean equals(java.lang.Object)>
<soot.toolkits.scalar.ArrayPackedSet: boolean sameType(java.lang.Object)>
<soot.toolkits.scalar.ArrayPackedSet: java.util.List toList(int,int)>
<soot.toolkits.scalar.ArrayPackedSet: soot.toolkits.scalar.ArrayPackedSet clone()>
<soot.toolkits.scalar.ArrayPackedSet: soot.toolkits.scalar.FlowSet clone()>
<soot.toolkits.scalar.ArrayPackedSet: void <init>(soot.toolkits.scalar.FlowUniverse)>
<soot.toolkits.scalar.ArrayPackedSet: void <init>(soot.toolkits.scalar.ObjectIntMapper)>
<soot.toolkits.scalar.ArrayPackedSet: void <init>(soot.toolkits.scalar.ObjectIntMapper,int[])>
<soot.toolkits.scalar.ArrayPackedSet: void add(java.lang.Object)>
<soot.toolkits.scalar.ArrayPackedSet: void complement(soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArrayPackedSet: void copy(soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArrayPackedSet: void intersection(soot.toolkits.scalar.FlowSet,soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArrayPackedSet: void union(soot.toolkits.scalar.FlowSet,soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArraySparseSet: boolean contains(java.lang.Object)>
<soot.toolkits.scalar.ArraySparseSet: boolean equals(java.lang.Object)>
<soot.toolkits.scalar.ArraySparseSet: boolean sameType(java.lang.Object)>
<soot.toolkits.scalar.ArraySparseSet: java.util.List toList()>
<soot.toolkits.scalar.ArraySparseSet: soot.toolkits.scalar.ArraySparseSet clone()>
<soot.toolkits.scalar.ArraySparseSet: soot.toolkits.scalar.FlowSet clone()>
<soot.toolkits.scalar.ArraySparseSet: void <init>()>
<soot.toolkits.scalar.ArraySparseSet: void <init>(soot.toolkits.scalar.ArraySparseSet)>
<soot.toolkits.scalar.ArraySparseSet: void add(java.lang.Object)>
<soot.toolkits.scalar.ArraySparseSet: void clear()>
<soot.toolkits.scalar.ArraySparseSet: void copy(soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArraySparseSet: void difference(soot.toolkits.scalar.FlowSet,soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArraySparseSet: void doubleCapacity()>
<soot.toolkits.scalar.ArraySparseSet: void intersection(soot.toolkits.scalar.FlowSet,soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.ArraySparseSet: void union(soot.toolkits.scalar.FlowSet,soot.toolkits.scalar.FlowSet)>
<soot.toolkits.scalar.BackwardFlowAnalysis$1: int compare(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.BackwardFlowAnalysis$1: void <init>(soot.toolkits.scalar.BackwardFlowAnalysis,java.util.Map)>
<soot.toolkits.scalar.BackwardFlowAnalysis: java.util.Collection constructWorklist(java.util.Map)>
<soot.toolkits.scalar.BackwardFlowAnalysis: void <init>(soot.toolkits.graph.DirectedGraph)>
<soot.toolkits.scalar.BackwardFlowAnalysis: void doAnalysis()>
<soot.toolkits.scalar.FastColorer$UnitInterferenceGraph: java.util.List getLocals()>
<soot.toolkits.scalar.FastColorer$UnitInterferenceGraph: void <init>(soot.Body,java.util.Map,soot.toolkits.scalar.LiveLocals)>
<soot.toolkits.scalar.FastColorer$UnitInterferenceGraph: void setInterference(soot.Local,soot.Local)>
<soot.toolkits.scalar.FastColorer: void assignColorsToLocals(soot.Body,java.util.Map,java.util.Map,java.util.Map)>
<soot.toolkits.scalar.FlowAnalysis: java.lang.Object getFlowAfter(java.lang.Object)>
<soot.toolkits.scalar.FlowAnalysis: soot.toolkits.graph.Orderer constructOrderer()>
<soot.toolkits.scalar.FlowAnalysis: void <init>(soot.toolkits.graph.DirectedGraph)>
<soot.toolkits.scalar.ForwardFlowAnalysis$1: int compare(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.ForwardFlowAnalysis$1: void <init>(soot.toolkits.scalar.ForwardFlowAnalysis,java.util.Map)>
<soot.toolkits.scalar.ForwardFlowAnalysis: java.util.Collection constructWorklist(java.util.Map)>
<soot.toolkits.scalar.ForwardFlowAnalysis: void <init>(soot.toolkits.graph.DirectedGraph)>
<soot.toolkits.scalar.ForwardFlowAnalysis: void doAnalysis()>
<soot.toolkits.scalar.IntPair: void <init>(int,int)>
<soot.toolkits.scalar.LocalDefsFlowAnalysis: java.lang.Object entryInitialFlow()>
<soot.toolkits.scalar.LocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>
<soot.toolkits.scalar.LocalDefsFlowAnalysis: void <init>(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.scalar.LocalDefsFlowAnalysis: void copy(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.LocalDefsFlowAnalysis: void flowThrough(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.LocalDefsFlowAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.LocalPacker: soot.toolkits.scalar.LocalPacker v()>
<soot.toolkits.scalar.LocalPacker: void <init>(soot.Singletons$Global)>
<soot.toolkits.scalar.LocalPacker: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.toolkits.scalar.LocalSplitter: soot.toolkits.scalar.LocalSplitter v()>
<soot.toolkits.scalar.LocalSplitter: void <init>(soot.Singletons$Global)>
<soot.toolkits.scalar.LocalSplitter: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.toolkits.scalar.LocalUnitPair: boolean equals(java.lang.Object)>
<soot.toolkits.scalar.LocalUnitPair: int hashCode()>
<soot.toolkits.scalar.LocalUnitPair: void <init>(soot.Local,soot.Unit)>
<soot.toolkits.scalar.ObjectIntMapper: int add(java.lang.Object)>
<soot.toolkits.scalar.ObjectIntMapper: int getInt(java.lang.Object)>
<soot.toolkits.scalar.ObjectIntMapper: int size()>
<soot.toolkits.scalar.ObjectIntMapper: java.lang.Object getObject(int)>
<soot.toolkits.scalar.ObjectIntMapper: void <init>(java.util.Iterator,int)>
<soot.toolkits.scalar.ObjectIntMapper: void <init>(soot.toolkits.scalar.FlowUniverse)>
<soot.toolkits.scalar.Pair: boolean equals(java.lang.Object)>
<soot.toolkits.scalar.Pair: int hashCode()>
<soot.toolkits.scalar.Pair: void <init>(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SimpleLiveLocals: java.util.List getLiveLocalsAfter(soot.Unit)>
<soot.toolkits.scalar.SimpleLiveLocals: void <init>(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.scalar.SimpleLiveLocalsAnalysis: java.lang.Object entryInitialFlow()>
<soot.toolkits.scalar.SimpleLiveLocalsAnalysis: java.lang.Object newInitialFlow()>
<soot.toolkits.scalar.SimpleLiveLocalsAnalysis: void <init>(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.scalar.SimpleLiveLocalsAnalysis: void copy(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SimpleLiveLocalsAnalysis: void flowThrough(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SimpleLiveLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SimpleLocalDefs: java.util.List getDefsOfAt(soot.Local,soot.Unit)>
<soot.toolkits.scalar.SimpleLocalDefs: void <init>(soot.toolkits.graph.UnitGraph)>
<soot.toolkits.scalar.SimpleLocalUses: java.util.List getUsesOf(soot.Unit)>
<soot.toolkits.scalar.SimpleLocalUses: void <init>(soot.Body,soot.toolkits.scalar.LocalDefs)>
<soot.toolkits.scalar.SimpleLocalUses: void <init>(soot.toolkits.graph.UnitGraph,soot.toolkits.scalar.LocalDefs)>
<soot.toolkits.scalar.SmartLocalDefs$LocalDefsAnalysis: java.lang.Object entryInitialFlow()>
<soot.toolkits.scalar.SmartLocalDefs$LocalDefsAnalysis: java.lang.Object newInitialFlow()>
<soot.toolkits.scalar.SmartLocalDefs$LocalDefsAnalysis: void <init>(soot.toolkits.scalar.SmartLocalDefs,soot.toolkits.graph.UnitGraph)>
<soot.toolkits.scalar.SmartLocalDefs$LocalDefsAnalysis: void copy(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SmartLocalDefs$LocalDefsAnalysis: void flowThrough(java.lang.Object,java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SmartLocalDefs$LocalDefsAnalysis: void merge(java.lang.Object,java.lang.Object)>
<soot.toolkits.scalar.SmartLocalDefs: java.util.HashSet access$200(soot.toolkits.scalar.SmartLocalDefs,soot.Local)>
<soot.toolkits.scalar.SmartLocalDefs: java.util.HashSet defsOf(soot.Local)>
<soot.toolkits.scalar.SmartLocalDefs: java.util.List getDefsOfAt(soot.Local,soot.Unit)>
<soot.toolkits.scalar.SmartLocalDefs: java.util.Map access$000(soot.toolkits.scalar.SmartLocalDefs)>
<soot.toolkits.scalar.SmartLocalDefs: soot.Local access$100(soot.toolkits.scalar.SmartLocalDefs,soot.Unit)>
<soot.toolkits.scalar.SmartLocalDefs: soot.Local localDef(soot.Unit)>
<soot.toolkits.scalar.SmartLocalDefs: void <init>(soot.toolkits.graph.UnitGraph,soot.toolkits.scalar.LiveLocals)>
<soot.toolkits.scalar.UnitValueBoxPair: soot.Unit getUnit()>
<soot.toolkits.scalar.UnitValueBoxPair: soot.ValueBox getValueBox()>
<soot.toolkits.scalar.UnitValueBoxPair: void <init>(soot.Unit,soot.ValueBox)>
<soot.toolkits.scalar.UnusedLocalEliminator: soot.toolkits.scalar.UnusedLocalEliminator v()>
<soot.toolkits.scalar.UnusedLocalEliminator: void <init>(soot.Singletons$Global)>
<soot.toolkits.scalar.UnusedLocalEliminator: void internalTransform(soot.Body,java.lang.String,java.util.Map)>
<soot.util.ArrayNumberer$NumbererIterator: boolean hasNext()>
<soot.util.ArrayNumberer$NumbererIterator: java.lang.Object next()>
<soot.util.ArrayNumberer$NumbererIterator: void <init>(soot.util.ArrayNumberer)>
<soot.util.ArrayNumberer: int size()>
<soot.util.ArrayNumberer: java.lang.Object get(long)>
<soot.util.ArrayNumberer: java.util.Iterator iterator()>
<soot.util.ArrayNumberer: void <init>()>
<soot.util.ArrayNumberer: void add(java.lang.Object)>
<soot.util.ArraySet$ArrayIterator: boolean hasNext()>
<soot.util.ArraySet$ArrayIterator: java.lang.Object next()>
<soot.util.ArraySet$ArrayIterator: void <init>(soot.util.ArraySet)>
<soot.util.ArraySet: boolean add(java.lang.Object)>
<soot.util.ArraySet: boolean contains(java.lang.Object)>
<soot.util.ArraySet: int access$000(soot.util.ArraySet)>
<soot.util.ArraySet: int size()>
<soot.util.ArraySet: java.lang.Object[] access$100(soot.util.ArraySet)>
<soot.util.ArraySet: java.lang.Object[] toArray()>
<soot.util.ArraySet: java.util.Iterator iterator()>
<soot.util.ArraySet: void <init>()>
<soot.util.ArraySet: void <init>(int)>
<soot.util.ArraySet: void doubleCapacity()>
<soot.util.BitSetIterator: boolean hasNext()>
<soot.util.BitSetIterator: int next()>
<soot.util.BitSetIterator: void <clinit>()>
<soot.util.BitSetIterator: void <init>(long[])>
<soot.util.BitVector: boolean get(int)>
<soot.util.BitVector: boolean orAndAndNot(soot.util.BitVector,soot.util.BitVector,soot.util.BitVector)>
<soot.util.BitVector: boolean set(int)>
<soot.util.BitVector: int indexOf(int)>
<soot.util.BitVector: long mask(int)>
<soot.util.BitVector: soot.util.BitSetIterator iterator()>
<soot.util.BitVector: void <init>()>
<soot.util.BitVector: void <init>(int)>
<soot.util.BitVector: void expand(int)>
<soot.util.Cons: boolean equals(java.lang.Object)>
<soot.util.Cons: int hashCode()>
<soot.util.Cons: void <init>(java.lang.Object,java.lang.Object)>
<soot.util.DeterministicHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<soot.util.DeterministicHashMap: void <init>(int,float)>
<soot.util.HashChain$Link: java.lang.Object getItem()>
<soot.util.HashChain$Link: soot.util.HashChain$Link getNext()>
<soot.util.HashChain$Link: soot.util.HashChain$Link getPrevious()>
<soot.util.HashChain$Link: soot.util.HashChain$Link insertAfter(java.lang.Object)>
<soot.util.HashChain$Link: soot.util.HashChain$Link insertBefore(java.lang.Object)>
<soot.util.HashChain$Link: void <init>(soot.util.HashChain,java.lang.Object)>
<soot.util.HashChain$Link: void bind(soot.util.HashChain$Link,soot.util.HashChain$Link)>
<soot.util.HashChain$Link: void setNext(soot.util.HashChain$Link)>
<soot.util.HashChain$Link: void setPrevious(soot.util.HashChain$Link)>
<soot.util.HashChain$Link: void unlinkSelf()>
<soot.util.HashChain$LinkIterator: boolean hasNext()>
<soot.util.HashChain$LinkIterator: java.lang.Object next()>
<soot.util.HashChain$LinkIterator: void <init>(soot.util.HashChain,java.lang.Object)>
<soot.util.HashChain$LinkIterator: void <init>(soot.util.HashChain,java.lang.Object,java.lang.Object)>
<soot.util.HashChain$LinkIterator: void remove()>
<soot.util.HashChain: boolean add(java.lang.Object)>
<soot.util.HashChain: boolean contains(java.lang.Object)>
<soot.util.HashChain: boolean remove(java.lang.Object)>
<soot.util.HashChain: int size()>
<soot.util.HashChain: java.lang.Object access$002(soot.util.HashChain,java.lang.Object)>
<soot.util.HashChain: java.lang.Object access$102(soot.util.HashChain,java.lang.Object)>
<soot.util.HashChain: java.lang.Object getFirst()>
<soot.util.HashChain: java.lang.Object getLast()>
<soot.util.HashChain: java.lang.Object getPredOf(java.lang.Object)>
<soot.util.HashChain: java.lang.Object getSuccOf(java.lang.Object)>
<soot.util.HashChain: java.util.HashMap access$200(soot.util.HashChain)>
<soot.util.HashChain: java.util.Iterator iterator()>
<soot.util.HashChain: java.util.Iterator iterator(java.lang.Object)>
<soot.util.HashChain: java.util.Iterator iterator(java.lang.Object,java.lang.Object)>
<soot.util.HashChain: long access$300(soot.util.HashChain)>
<soot.util.HashChain: long access$308(soot.util.HashChain)>
<soot.util.HashChain: void <init>()>
<soot.util.HashChain: void addLast(java.lang.Object)>
<soot.util.HashChain: void clear()>
<soot.util.HashChain: void insertAfter(java.lang.Object,java.lang.Object)>
<soot.util.HashChain: void insertBefore(java.lang.Object,java.lang.Object)>
<soot.util.HashMultiMap: boolean containsKey(java.lang.Object)>
<soot.util.HashMultiMap: boolean put(java.lang.Object,java.lang.Object)>
<soot.util.HashMultiMap: boolean putAll(java.lang.Object,java.util.Set)>
<soot.util.HashMultiMap: java.util.Set findSet(java.lang.Object)>
<soot.util.HashMultiMap: java.util.Set get(java.lang.Object)>
<soot.util.HashMultiMap: java.util.Set newSet()>
<soot.util.HashMultiMap: void <init>()>
<soot.util.IdentityHashSet: boolean add(java.lang.Object)>
<soot.util.IdentityHashSet: java.util.Iterator iterator()>
<soot.util.IdentityHashSet: void <init>()>
<soot.util.JasminOutputStream: void <init>(java.io.OutputStream)>
<soot.util.JasminOutputStream: void flush()>
<soot.util.LargeNumberedMap: boolean put(soot.util.Numberable,java.lang.Object)>
<soot.util.LargeNumberedMap: java.lang.Object get(soot.util.Numberable)>
<soot.util.LargeNumberedMap: void <init>(soot.util.ArrayNumberer)>
<soot.util.MapNumberer: void <init>()>
<soot.util.NumberedString: int getNumber()>
<soot.util.NumberedString: void <init>(java.lang.String)>
<soot.util.NumberedString: void setNumber(int)>
<soot.util.PhaseDumper$PhaseStack: java.lang.String currentPhase()>
<soot.util.PhaseDumper$PhaseStack: java.lang.String pop()>
<soot.util.PhaseDumper$PhaseStack: java.lang.String push(java.lang.String)>
<soot.util.PhaseDumper$PhaseStack: void <init>(soot.util.PhaseDumper)>
<soot.util.PhaseDumper: boolean isBodyDumpingPhase(java.lang.String)>
<soot.util.PhaseDumper: boolean isCFGDumpingPhase(java.lang.String)>
<soot.util.PhaseDumper: soot.util.PhaseDumper v()>
<soot.util.PhaseDumper: void <init>(soot.Singletons$Global)>
<soot.util.PhaseDumper: void dumpAfter(java.lang.String)>
<soot.util.PhaseDumper: void dumpAfter(soot.Body,java.lang.String)>
<soot.util.PhaseDumper: void dumpBefore(java.lang.String)>
<soot.util.PhaseDumper: void dumpBefore(soot.Body,java.lang.String)>
<soot.util.PhaseDumper: void dumpGraph(soot.toolkits.graph.DirectedGraph,soot.Body)>
<soot.util.PhaseDumper: void dumpGraph(soot.toolkits.graph.ExceptionalGraph)>
<soot.util.SingletonList: int size()>
<soot.util.SingletonList: java.lang.Object get(int)>
<soot.util.SingletonList: void <init>(java.lang.Object)>
<soot.util.SmallNumberedMap: boolean put(soot.util.Numberable,java.lang.Object)>
<soot.util.SmallNumberedMap: int findPosition(soot.util.Numberable)>
<soot.util.SmallNumberedMap: java.lang.Object get(soot.util.Numberable)>
<soot.util.SmallNumberedMap: void <init>(soot.util.ArrayNumberer)>
<soot.util.SmallNumberedMap: void doubleSize()>
<soot.util.StringNumberer: soot.util.NumberedString findOrAdd(java.lang.String)>
<soot.util.StringNumberer: void <init>()>
<soot.util.StringTools: java.lang.String getEscapedStringOf(java.lang.String)>
<soot.util.StringTools: java.lang.String getQuotedStringOf(java.lang.String)>
<soot.util.StringTools: void <clinit>()>
<soot.util.TrustingMonotonicArraySet: boolean add(java.lang.Object)>
<soot.util.TrustingMonotonicArraySet: void <init>()>
<soot.util.queue.ChunkedQueue: soot.util.queue.QueueReader reader()>
<soot.util.queue.ChunkedQueue: void <clinit>()>
<soot.util.queue.ChunkedQueue: void <init>()>
<soot.util.queue.ChunkedQueue: void add(java.lang.Object)>
<soot.util.queue.QueueReader: boolean hasNext()>
<soot.util.queue.QueueReader: java.lang.Object next()>
<soot.util.queue.QueueReader: soot.util.queue.QueueReader clone()>
<soot.util.queue.QueueReader: void <init>(java.lang.Object[],int)>
<soot.xml.TagCollector: void <init>()>
<sun.jkernel.DownloadManager: boolean isJREComplete()>
<sun.jkernel.DownloadManager: java.io.File[] getAdditionalBootStrapPaths()>
<sun.jkernel.DownloadManager: java.lang.String getBootClassPathEntryForClass(java.lang.String)>
<sun.jkernel.DownloadManager: java.lang.String getBootClassPathEntryForResource(java.lang.String)>
<sun.misc.ASCIICaseInsensitiveComparator: boolean isUpper(int)>
<sun.misc.ASCIICaseInsensitiveComparator: int lowerCaseHashCode(java.lang.String)>
<sun.misc.ASCIICaseInsensitiveComparator: int toLower(int)>
<sun.misc.ASCIICaseInsensitiveComparator: void <clinit>()>
<sun.misc.ASCIICaseInsensitiveComparator: void <init>()>
<sun.misc.BASE64Decoder: void <clinit>()>
<sun.misc.BASE64Decoder: void <init>()>
<sun.misc.CharacterDecoder: void <init>()>
<sun.misc.CompoundEnumeration: boolean hasMoreElements()>
<sun.misc.CompoundEnumeration: boolean next()>
<sun.misc.CompoundEnumeration: void <init>(java.util.Enumeration[])>
<sun.misc.ExtensionDependency: boolean checkExtensionsDependencies(java.util.jar.JarFile)>
<sun.misc.FileURLMapper: boolean exists()>
<sun.misc.FileURLMapper: java.lang.String getPath()>
<sun.misc.FileURLMapper: void <init>(java.net.URL)>
<sun.misc.IOUtils: byte[] readFully(java.io.InputStream,int,boolean)>
<sun.misc.JarIndex: sun.misc.JarIndex getJarIndex(java.util.jar.JarFile,sun.misc.MetaIndex)>
<sun.misc.JarIndex: void <clinit>()>
<sun.misc.Launcher$1: java.lang.Object run()>
<sun.misc.Launcher$1: void <init>(java.lang.String)>
<sun.misc.Launcher$2: java.lang.Object run()>
<sun.misc.Launcher$2: void <init>(java.io.File[])>
<sun.misc.Launcher$AppClassLoader: java.lang.Class loadClass(java.lang.String,boolean)>
<sun.misc.Launcher$AppClassLoader: java.security.PermissionCollection getPermissions(java.security.CodeSource)>
<sun.misc.Launcher$ExtClassLoader: java.lang.Class findClass(java.lang.String)>
<sun.misc.Launcher$Factory: java.net.URLStreamHandler createURLStreamHandler(java.lang.String)>
<sun.misc.Launcher: java.io.File[] access$200(java.lang.String)>
<sun.misc.Launcher: java.io.File[] getClassPath(java.lang.String)>
<sun.misc.Launcher: java.net.URL getFileURL(java.io.File)>
<sun.misc.Launcher: java.net.URL[] access$300(java.io.File[])>
<sun.misc.Launcher: java.net.URL[] pathToURLs(java.io.File[])>
<sun.misc.Launcher: sun.misc.URLClassPath getBootstrapClassPath()>
<sun.misc.MetaIndex: boolean mayContain(java.lang.String)>
<sun.misc.MetaIndex: java.util.Map getJarMap()>
<sun.misc.MetaIndex: sun.misc.MetaIndex forJar(java.io.File)>
<sun.misc.MetaIndex: void <init>(java.util.List,boolean)>
<sun.misc.MetaIndex: void registerDirectory(java.io.File)>
<sun.misc.PostVMInitHook: void run()>
<sun.misc.PostVMInitHook: void trackJavaUsage()>
<sun.misc.Resource: byte[] getBytes()>
<sun.misc.Resource: java.io.InputStream cachedInputStream()>
<sun.misc.Resource: java.nio.ByteBuffer getByteBuffer()>
<sun.misc.Resource: void <init>()>
<sun.misc.SharedSecrets: sun.misc.JavaAWTAccess getJavaAWTAccess()>
<sun.misc.SharedSecrets: sun.misc.JavaUtilJarAccess javaUtilJarAccess()>
<sun.misc.SharedSecrets: void setJavaSecurityProtectionDomainAccess(sun.misc.JavaSecurityProtectionDomainAccess)>
<sun.misc.SharedSecrets: void setJavaUtilJarAccess(sun.misc.JavaUtilJarAccess)>
<sun.misc.URLClassPath$1: boolean hasMoreElements()>
<sun.misc.URLClassPath$1: boolean next()>
<sun.misc.URLClassPath$1: void <init>(sun.misc.URLClassPath,java.lang.String,boolean)>
<sun.misc.URLClassPath$2: boolean hasMoreElements()>
<sun.misc.URLClassPath$2: boolean next()>
<sun.misc.URLClassPath$2: void <init>(sun.misc.URLClassPath,java.lang.String,boolean)>
<sun.misc.URLClassPath$3: java.lang.Object run()>
<sun.misc.URLClassPath$3: void <init>(sun.misc.URLClassPath,java.net.URL)>
<sun.misc.URLClassPath$JarLoader$1: java.lang.Object run()>
<sun.misc.URLClassPath$JarLoader$1: void <init>(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader$2: int getContentLength()>
<sun.misc.URLClassPath$JarLoader$2: java.io.InputStream getInputStream()>
<sun.misc.URLClassPath$JarLoader$2: java.net.URL getCodeSourceURL()>
<sun.misc.URLClassPath$JarLoader$2: java.net.URL getURL()>
<sun.misc.URLClassPath$JarLoader$2: java.security.CodeSigner[] getCodeSigners()>
<sun.misc.URLClassPath$JarLoader$2: java.util.jar.Manifest getManifest()>
<sun.misc.URLClassPath$JarLoader$2: void <init>(sun.misc.URLClassPath$JarLoader,java.lang.String,java.net.URL,java.util.jar.JarEntry)>
<sun.misc.URLClassPath$JarLoader: boolean isOptimizable(java.net.URL)>
<sun.misc.URLClassPath$JarLoader: java.net.URL access$400(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: java.net.URL findResource(java.lang.String,boolean)>
<sun.misc.URLClassPath$JarLoader: java.net.URL[] getClassPath()>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile access$500(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile access$502(sun.misc.URLClassPath$JarLoader,java.util.jar.JarFile)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile access$600(sun.misc.URLClassPath$JarLoader,java.net.URL)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile getJarFile(java.net.URL)>
<sun.misc.URLClassPath$JarLoader: sun.misc.JarIndex access$700(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: sun.misc.JarIndex access$702(sun.misc.URLClassPath$JarLoader,sun.misc.JarIndex)>
<sun.misc.URLClassPath$JarLoader: sun.misc.MetaIndex access$800(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: sun.misc.Resource checkResource(java.lang.String,boolean,java.util.jar.JarEntry)>
<sun.misc.URLClassPath$JarLoader: sun.misc.Resource getResource(java.lang.String,boolean)>
<sun.misc.URLClassPath$JarLoader: void <init>(java.net.URL,java.net.URLStreamHandler,java.util.HashMap)>
<sun.misc.URLClassPath$JarLoader: void ensureOpen()>
<sun.misc.URLClassPath$JarLoader: void parseExtensionsDependencies()>
<sun.misc.URLClassPath$Loader: java.net.URL getBaseURL()>
<sun.misc.URLClassPath$Loader: void <init>(java.net.URL)>
<sun.misc.URLClassPath: boolean access$300()>
<sun.misc.URLClassPath: java.net.URL checkURL(java.net.URL)>
<sun.misc.URLClassPath: java.net.URL findResource(java.lang.String,boolean)>
<sun.misc.URLClassPath: java.net.URLStreamHandler access$100(sun.misc.URLClassPath)>
<sun.misc.URLClassPath: java.util.Enumeration findResources(java.lang.String,boolean)>
<sun.misc.URLClassPath: java.util.Enumeration getResources(java.lang.String)>
<sun.misc.URLClassPath: java.util.Enumeration getResources(java.lang.String,boolean)>
<sun.misc.URLClassPath: sun.misc.Resource getResource(java.lang.String)>
<sun.misc.URLClassPath: sun.misc.Resource getResource(java.lang.String,boolean)>
<sun.misc.URLClassPath: sun.misc.URLClassPath$Loader access$000(sun.misc.URLClassPath,int)>
<sun.misc.URLClassPath: sun.misc.URLClassPath$Loader getLoader(int)>
<sun.misc.URLClassPath: sun.misc.URLClassPath$Loader getLoader(java.net.URL)>
<sun.misc.URLClassPath: void <init>(java.net.URL[],java.net.URLStreamHandlerFactory)>
<sun.misc.URLClassPath: void check(java.net.URL)>
<sun.misc.URLClassPath: void push(java.net.URL[])>
<sun.misc.Unsafe: sun.misc.Unsafe getUnsafe()>
<sun.misc.VM: boolean allowArraySyntax()>
<sun.misc.VM: void addFinalRefCount(int)>
<sun.net.util.URLUtil: java.lang.String urlNoFragString(java.net.URL)>
<sun.net.www.MessageHeader: void <init>()>
<sun.net.www.MessageHeader: void grow()>
<sun.net.www.ParseUtil: java.lang.String canonizeString(java.lang.String)>
<sun.net.www.ParseUtil: java.lang.String decode(java.lang.String)>
<sun.net.www.ParseUtil: java.lang.String encodePath(java.lang.String)>
<sun.net.www.ParseUtil: java.lang.String encodePath(java.lang.String,boolean)>
<sun.net.www.ParseUtil: java.net.URL fileToEncodedURL(java.io.File)>
<sun.net.www.ParseUtil: void <init>()>
<sun.net.www.URLConnection: void <clinit>()>
<sun.net.www.URLConnection: void <init>(java.net.URL)>
<sun.net.www.protocol.file.FileURLConnection: java.security.Permission getPermission()>
<sun.net.www.protocol.file.FileURLConnection: void <clinit>()>
<sun.net.www.protocol.file.FileURLConnection: void <init>(java.net.URL,java.io.File)>
<sun.net.www.protocol.file.Handler: boolean hostsEqual(java.net.URL,java.net.URL)>
<sun.net.www.protocol.file.Handler: java.net.URLConnection createFileURLConnection(java.net.URL,java.io.File)>
<sun.net.www.protocol.file.Handler: java.net.URLConnection openConnection(java.net.URL)>
<sun.net.www.protocol.file.Handler: java.net.URLConnection openConnection(java.net.URL,java.net.Proxy)>
<sun.net.www.protocol.file.Handler: void parseURL(java.net.URL,java.lang.String,int,int)>
<sun.net.www.protocol.jar.Handler: int indexOfBangSlash(java.lang.String)>
<sun.net.www.protocol.jar.Handler: java.lang.String parseContextSpec(java.net.URL,java.lang.String)>
<sun.net.www.protocol.jar.Handler: java.net.URLConnection openConnection(java.net.URL)>
<sun.net.www.protocol.jar.Handler: void <init>()>
<sun.net.www.protocol.jar.Handler: void parseURL(java.net.URL,java.lang.String,int,int)>
<sun.net.www.protocol.jar.JarFileFactory: java.net.URLConnection getConnection(java.util.jar.JarFile)>
<sun.net.www.protocol.jar.JarFileFactory: java.security.Permission getPermission(java.util.jar.JarFile)>
<sun.net.www.protocol.jar.JarFileFactory: java.util.jar.JarFile get(java.net.URL,boolean)>
<sun.net.www.protocol.jar.JarFileFactory: java.util.jar.JarFile getCachedJarFile(java.net.URL)>
<sun.net.www.protocol.jar.JarFileFactory: void <clinit>()>
<sun.net.www.protocol.jar.JarFileFactory: void <init>()>
<sun.net.www.protocol.jar.JarURLConnection$JarURLInputStream: void <init>(sun.net.www.protocol.jar.JarURLConnection,java.io.InputStream)>
<sun.net.www.protocol.jar.JarURLConnection$JarURLInputStream: void close()>
<sun.net.www.protocol.jar.JarURLConnection: boolean getUseCaches()>
<sun.net.www.protocol.jar.JarURLConnection: java.io.InputStream getInputStream()>
<sun.net.www.protocol.jar.JarURLConnection: void <clinit>()>
<sun.net.www.protocol.jar.JarURLConnection: void <init>(java.net.URL,sun.net.www.protocol.jar.Handler)>
<sun.net.www.protocol.jar.JarURLConnection: void connect()>
<sun.net.www.protocol.jar.URLJarFile$URLJarFileEntry: void <init>(sun.net.www.protocol.jar.URLJarFile,java.util.jar.JarEntry)>
<sun.net.www.protocol.jar.URLJarFile: boolean isFileURL(java.net.URL)>
<sun.net.www.protocol.jar.URLJarFile: java.util.jar.JarFile getJarFile(java.net.URL,sun.net.www.protocol.jar.URLJarFile$URLJarFileCloseController)>
<sun.net.www.protocol.jar.URLJarFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
<sun.net.www.protocol.jar.URLJarFile: void <clinit>()>
<sun.net.www.protocol.jar.URLJarFile: void <init>(java.net.URL,sun.net.www.protocol.jar.URLJarFile$URLJarFileCloseController)>
<sun.nio.cs.StreamDecoder: boolean inReady()>
<sun.nio.cs.StreamDecoder: int implRead(char[],int,int)>
<sun.nio.cs.StreamDecoder: int read(char[],int,int)>
<sun.nio.cs.StreamDecoder: int readBytes()>
<sun.nio.cs.StreamDecoder: sun.nio.cs.StreamDecoder forInputStreamReader(java.io.InputStream,java.lang.Object,java.lang.String)>
<sun.nio.cs.StreamDecoder: void <init>(java.io.InputStream,java.lang.Object,java.nio.charset.Charset)>
<sun.nio.cs.StreamDecoder: void <init>(java.io.InputStream,java.lang.Object,java.nio.charset.CharsetDecoder)>
<sun.nio.cs.StreamDecoder: void close()>
<sun.nio.cs.StreamDecoder: void ensureOpen()>
<sun.nio.cs.StreamDecoder: void implClose()>
<sun.nio.cs.StreamEncoder: boolean isOpen()>
<sun.nio.cs.StreamEncoder: sun.nio.cs.StreamEncoder forOutputStreamWriter(java.io.OutputStream,java.lang.Object,java.lang.String)>
<sun.nio.cs.StreamEncoder: void <init>(java.io.OutputStream,java.lang.Object,java.nio.charset.Charset)>
<sun.nio.cs.StreamEncoder: void <init>(java.io.OutputStream,java.lang.Object,java.nio.charset.CharsetEncoder)>
<sun.nio.cs.StreamEncoder: void ensureOpen()>
<sun.nio.cs.StreamEncoder: void flush()>
<sun.nio.cs.StreamEncoder: void flushBuffer()>
<sun.nio.cs.StreamEncoder: void implFlush()>
<sun.nio.cs.StreamEncoder: void implFlushBuffer()>
<sun.nio.cs.StreamEncoder: void implWrite(char[],int,int)>
<sun.nio.cs.StreamEncoder: void write(char[],int,int)>
<sun.nio.cs.StreamEncoder: void write(java.lang.String,int,int)>
<sun.nio.cs.StreamEncoder: void writeBytes()>
<sun.nio.cs.UTF_8$Decoder: java.nio.charset.CoderResult decodeArrayLoop(java.nio.ByteBuffer,java.nio.CharBuffer)>
<sun.nio.cs.UTF_8$Decoder: java.nio.charset.CoderResult decodeLoop(java.nio.ByteBuffer,java.nio.CharBuffer)>
<sun.nio.cs.UTF_8$Decoder: java.nio.charset.CoderResult xflow(java.nio.Buffer,int,int,java.nio.Buffer,int,int)>
<sun.nio.cs.UTF_8$Decoder: void <init>(java.nio.charset.Charset)>
<sun.nio.cs.UTF_8$Decoder: void <init>(java.nio.charset.Charset,sun.nio.cs.UTF_8$1)>
<sun.nio.cs.UTF_8$Encoder: boolean isLegalReplacement(byte[])>
<sun.nio.cs.UTF_8$Encoder: java.nio.charset.CoderResult encodeArrayLoop(java.nio.CharBuffer,java.nio.ByteBuffer)>
<sun.nio.cs.UTF_8$Encoder: java.nio.charset.CoderResult encodeLoop(java.nio.CharBuffer,java.nio.ByteBuffer)>
<sun.nio.cs.UTF_8$Encoder: void <init>(java.nio.charset.Charset)>
<sun.nio.cs.UTF_8$Encoder: void <init>(java.nio.charset.Charset,sun.nio.cs.UTF_8$1)>
<sun.nio.cs.UTF_8: java.lang.String historicalName()>
<sun.nio.cs.UTF_8: java.nio.charset.CharsetDecoder newDecoder()>
<sun.nio.cs.UTF_8: java.nio.charset.CharsetEncoder newEncoder()>
<sun.nio.cs.UTF_8: void updatePositions(java.nio.Buffer,int,java.nio.Buffer,int)>
<sun.reflect.ConstructorAccessorImpl: void <init>()>
<sun.reflect.DelegatingConstructorAccessorImpl: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.DelegatingConstructorAccessorImpl: void <init>(sun.reflect.ConstructorAccessorImpl)>
<sun.reflect.DelegatingConstructorAccessorImpl: void setDelegate(sun.reflect.ConstructorAccessorImpl)>
<sun.reflect.MagicAccessorImpl: void <init>()>
<sun.reflect.NativeConstructorAccessorImpl: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.NativeConstructorAccessorImpl: void <init>(java.lang.reflect.Constructor)>
<sun.reflect.NativeConstructorAccessorImpl: void setParent(sun.reflect.DelegatingConstructorAccessorImpl)>
<sun.reflect.Reflection: boolean isSubclassOf(java.lang.Class,java.lang.Class)>
<sun.reflect.Reflection: boolean quickCheckMemberAccess(java.lang.Class,int)>
<sun.reflect.Reflection: java.lang.reflect.Field[] filterFields(java.lang.Class,java.lang.reflect.Field[])>
<sun.reflect.ReflectionFactory: int inflationThreshold()>
<sun.reflect.ReflectionFactory: java.lang.reflect.Constructor copyConstructor(java.lang.reflect.Constructor)>
<sun.reflect.ReflectionFactory: java.lang.reflect.Field copyField(java.lang.reflect.Field)>
<sun.reflect.ReflectionFactory: sun.reflect.ConstructorAccessor newConstructorAccessor(java.lang.reflect.Constructor)>
<sun.reflect.ReflectionFactory: sun.reflect.LangReflectAccess langReflectAccess()>
<sun.reflect.ReflectionFactory: void checkInitted()>
<sun.security.action.GetPropertyAction: java.lang.Object run()>
<sun.security.action.GetPropertyAction: java.lang.String run()>
<sun.security.action.GetPropertyAction: void <init>(java.lang.String)>
<sun.security.action.GetPropertyAction: void <init>(java.lang.String,java.lang.String)>
<sun.security.provider.PolicyFile: java.lang.String canonPath(java.lang.String)>
<sun.security.provider.PolicyFile: void <clinit>()>
<sun.security.util.Debug: boolean isOn(java.lang.String)>
<sun.security.util.Debug: sun.security.util.Debug getInstance(java.lang.String)>
<sun.security.util.Debug: sun.security.util.Debug getInstance(java.lang.String,java.lang.String)>
<sun.security.util.ManifestEntryVerifier: java.util.jar.JarEntry getEntry()>
<sun.security.util.ManifestEntryVerifier: void <clinit>()>
<sun.security.util.ManifestEntryVerifier: void <init>(java.util.jar.Manifest)>
<sun.security.util.ManifestEntryVerifier: void update(byte[],int,int)>
<sun.security.util.SignatureFileVerifier: boolean isBlockOrSF(java.lang.String)>
<sun.security.util.SignatureFileVerifier: void <clinit>()>
<sun.util.LocaleDataMetaInfo: java.lang.String getSupportedLocaleString(java.lang.String)>
<sun.util.LocaleDataMetaInfo: void <clinit>()>
<sun.util.LocaleServiceProviderPool$1: java.lang.Object run()>
<sun.util.LocaleServiceProviderPool$1: void <init>(sun.util.LocaleServiceProviderPool,java.lang.Class)>
<sun.util.LocaleServiceProviderPool: boolean hasProviders()>
<sun.util.LocaleServiceProviderPool: sun.util.LocaleServiceProviderPool getPool(java.lang.Class)>
<sun.util.LocaleServiceProviderPool: void <clinit>()>
<sun.util.LocaleServiceProviderPool: void <init>(java.lang.Class)>
<sun.util.TimeZoneNameUtility: java.lang.String[] retrieveDisplayNames(java.lang.String,java.util.Locale)>
<sun.util.TimeZoneNameUtility: java.lang.String[] retrieveDisplayNames(sun.util.resources.OpenListResourceBundle,java.lang.String,java.util.Locale)>
<sun.util.TimeZoneNameUtility: sun.util.resources.OpenListResourceBundle getBundle(java.util.Locale)>
<sun.util.TimeZoneNameUtility: void <clinit>()>
<sun.util.calendar.AbstractCalendar: sun.util.calendar.CalendarDate getCalendarDate(long,sun.util.calendar.CalendarDate)>
<sun.util.calendar.AbstractCalendar: sun.util.calendar.CalendarDate setTimeOfDay(sun.util.calendar.CalendarDate,int)>
<sun.util.calendar.AbstractCalendar: void <init>()>
<sun.util.calendar.BaseCalendar$Date: boolean hit(long)>
<sun.util.calendar.BaseCalendar$Date: void <init>(java.util.TimeZone)>
<sun.util.calendar.BaseCalendar$Date: void setCache(int,long,int)>
<sun.util.calendar.BaseCalendar: boolean isLeapYear(int)>
<sun.util.calendar.BaseCalendar: boolean isLeapYear(sun.util.calendar.CalendarDate)>
<sun.util.calendar.BaseCalendar: int getDayOfWeekFromFixedDate(long)>
<sun.util.calendar.BaseCalendar: int getGregorianYearFromFixedDate(long)>
<sun.util.calendar.BaseCalendar: long getFixedDate(int,int,int,sun.util.calendar.BaseCalendar$Date)>
<sun.util.calendar.BaseCalendar: void <clinit>()>
<sun.util.calendar.BaseCalendar: void <init>()>
<sun.util.calendar.BaseCalendar: void getCalendarDateFromFixedDate(sun.util.calendar.CalendarDate,long)>
<sun.util.calendar.CalendarDate: boolean isDaylightTime()>
<sun.util.calendar.CalendarDate: boolean isNormalized()>
<sun.util.calendar.CalendarDate: boolean isStandardTime()>
<sun.util.calendar.CalendarDate: int getDayOfMonth()>
<sun.util.calendar.CalendarDate: int getDayOfWeek()>
<sun.util.calendar.CalendarDate: int getHours()>
<sun.util.calendar.CalendarDate: int getMinutes()>
<sun.util.calendar.CalendarDate: int getMonth()>
<sun.util.calendar.CalendarDate: int getSeconds()>
<sun.util.calendar.CalendarDate: int getYear()>
<sun.util.calendar.CalendarDate: java.util.TimeZone getZone()>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setDayOfMonth(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setHours(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setMillis(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setMinutes(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setMonth(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setSeconds(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setYear(int)>
<sun.util.calendar.CalendarDate: void <init>(java.util.TimeZone)>
<sun.util.calendar.CalendarDate: void setDayOfWeek(int)>
<sun.util.calendar.CalendarDate: void setDaylightSaving(int)>
<sun.util.calendar.CalendarDate: void setLeapYear(boolean)>
<sun.util.calendar.CalendarDate: void setNormalized(boolean)>
<sun.util.calendar.CalendarDate: void setTimeOfDay(long)>
<sun.util.calendar.CalendarDate: void setZoneOffset(int)>
<sun.util.calendar.CalendarSystem: sun.util.calendar.Gregorian getGregorianCalendar()>
<sun.util.calendar.CalendarSystem: void <clinit>()>
<sun.util.calendar.CalendarSystem: void <init>()>
<sun.util.calendar.CalendarUtils: boolean isGregorianLeapYear(int)>
<sun.util.calendar.CalendarUtils: java.lang.StringBuilder sprintf0d(java.lang.StringBuilder,int,int)>
<sun.util.calendar.Gregorian$Date: int getNormalizedYear()>
<sun.util.calendar.Gregorian$Date: void <init>(java.util.TimeZone)>
<sun.util.calendar.Gregorian$Date: void setNormalizedYear(int)>
<sun.util.calendar.Gregorian: sun.util.calendar.CalendarDate getCalendarDate(long,java.util.TimeZone)>
<sun.util.calendar.Gregorian: sun.util.calendar.Gregorian$Date getCalendarDate(long,java.util.TimeZone)>
<sun.util.calendar.Gregorian: sun.util.calendar.Gregorian$Date getCalendarDate(long,sun.util.calendar.CalendarDate)>
<sun.util.calendar.Gregorian: sun.util.calendar.Gregorian$Date newCalendarDate(java.util.TimeZone)>
<sun.util.calendar.Gregorian: void <init>()>
<sun.util.calendar.ZoneInfo: int getOffsets(long,int[])>
<sun.util.calendar.ZoneInfo: int getOffsets(long,int[],int)>
<sun.util.calendar.ZoneInfo: int getTransitionIndex(long,int)>
<sun.util.calendar.ZoneInfo: java.lang.Object clone()>
<sun.util.calendar.ZoneInfo: java.util.Map getCachedAliasTable()>
<sun.util.calendar.ZoneInfo: java.util.TimeZone getTimeZone(java.lang.String)>
<sun.util.calendar.ZoneInfo: void <clinit>()>
<sun.util.calendar.ZoneInfo: void <init>(java.lang.String,int)>
<sun.util.calendar.ZoneInfo: void <init>(java.lang.String,int,int,int,long[],int[],int[],boolean)>
<sun.util.calendar.ZoneInfoFile$1: java.lang.Object run()>
<sun.util.calendar.ZoneInfoFile$1: void <init>()>
<sun.util.calendar.ZoneInfoFile$2: byte[] run()>
<sun.util.calendar.ZoneInfoFile$2: java.lang.Object run()>
<sun.util.calendar.ZoneInfoFile$2: void <init>(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: byte[] readZoneInfoFile(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: java.lang.String access$000()>
<sun.util.calendar.ZoneInfoFile: java.lang.String getFileName(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo addToCache(java.lang.String,sun.util.calendar.ZoneInfo)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo createZoneInfo(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo getFromCache(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo getZoneInfo(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: void <clinit>()>
<sun.util.resources.LocaleData$1: java.lang.Object run()>
<sun.util.resources.LocaleData$1: void <init>(java.lang.String,java.util.Locale)>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: java.util.List getCandidateLocales(java.lang.String,java.util.Locale)>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: sun.util.resources.LocaleData$LocaleDataResourceBundleControl getRBControlInstance()>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: void <clinit>()>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: void <init>()>
<sun.util.resources.LocaleData: java.util.ResourceBundle getBundle(java.lang.String,java.util.Locale)>
<sun.util.resources.LocaleData: sun.util.resources.OpenListResourceBundle getTimeZoneNames(java.util.Locale)>
<sun.util.resources.OpenListResourceBundle: java.lang.Object handleGetObject(java.lang.String)>
<sun.util.resources.OpenListResourceBundle: void <init>()>
<sun.util.resources.OpenListResourceBundle: void loadLookup()>
<sun.util.resources.OpenListResourceBundle: void loadLookupTablesIfNecessary()>
<sun.util.resources.TimeZoneNames: java.lang.Object[][] getContents()>
<sun.util.resources.TimeZoneNames: void <init>()>
<sun.util.resources.TimeZoneNamesBundle: java.lang.Object handleGetObject(java.lang.String)>
<sun.util.resources.TimeZoneNamesBundle: java.util.Map createMap(int)>
<sun.util.resources.TimeZoneNamesBundle: void <init>()>
<sun.util.resources.TimeZoneNames_en: java.lang.Object[][] getContents()>
<sun.util.resources.TimeZoneNames_en: void <init>()>
