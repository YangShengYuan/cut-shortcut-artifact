<Harness: void main(java.lang.String[])>
<dacapo.Benchmark: boolean run(dacapo.Callback,java.lang.String,boolean)>
<dacapo.Benchmark: java.lang.Class class$(java.lang.String)>
<dacapo.Benchmark: java.lang.String fileInScratch(java.lang.String)>
<dacapo.Benchmark: java.net.URL getURL(java.lang.String)>
<dacapo.Benchmark: void <clinit>()>
<dacapo.Benchmark: void <init>(dacapo.parser.Config,java.io.File)>
<dacapo.Benchmark: void preIteration(java.lang.String)>
<dacapo.Benchmark: void prepare()>
<dacapo.Benchmark: void startIteration()>
<dacapo.Benchmark: void unpackZipFile(java.lang.String,java.io.File)>
<dacapo.Benchmark: void unpackZipFileResource(java.lang.String,java.io.File)>
<dacapo.Benchmark: void unpackZipStream(java.io.BufferedInputStream,java.io.File)>
<dacapo.Callback: void <init>()>
<dacapo.Callback: void start(java.lang.String)>
<dacapo.Callback: void start(java.lang.String,boolean)>
<dacapo.TeeOutputStream: void <init>(java.io.OutputStream,java.io.File)>
<dacapo.TeeOutputStream: void newLog()>
<dacapo.TeeOutputStream: void openLog()>
<dacapo.TeeOutputStream: void write(int)>
<dacapo.TeePrintStream: void <init>(java.io.OutputStream,java.io.File)>
<dacapo.TeePrintStream: void openLog()>
<dacapo.TestHarness: java.lang.Class class$(java.lang.String)>
<dacapo.TestHarness: java.lang.Class findClass()>
<dacapo.TestHarness: java.text.DecimalFormat twoDecimalPlaces()>
<dacapo.TestHarness: void <clinit>()>
<dacapo.TestHarness: void <init>(java.io.InputStream)>
<dacapo.TestHarness: void main(java.lang.String[])>
<dacapo.TestHarness: void rmdir(java.io.File)>
<dacapo.TestHarness: void runBenchmark(java.io.File,java.lang.String,dacapo.TestHarness)>
<dacapo.eclipse.DaCapoPlugin: void <init>()>
<dacapo.eclipse.DaCapoPlugin: void start(org.osgi.framework.BundleContext)>
<dacapo.eclipse.EclipseASTTests: void <init>()>
<dacapo.eclipse.EclipseASTTests: void doTests(int)>
<dacapo.eclipse.EclipseASTTests: void domAstCreationJLS3()>
<dacapo.eclipse.EclipseBuildTests: java.util.Hashtable warningOptions(int)>
<dacapo.eclipse.EclipseBuildTests: void <clinit>()>
<dacapo.eclipse.EclipseBuildTests: void <init>()>
<dacapo.eclipse.EclipseBuildTests: void buildDefault(org.eclipse.jdt.core.IJavaProject)>
<dacapo.eclipse.EclipseBuildTests: void doTests(int)>
<dacapo.eclipse.EclipseBuildTests: void startBuild(org.eclipse.jdt.core.IJavaProject,java.util.Hashtable,boolean)>
<dacapo.eclipse.EclipseHarness: void <clinit>()>
<dacapo.eclipse.EclipseHarness: void <init>(dacapo.parser.Config,java.io.File)>
<dacapo.eclipse.EclipseHarness: void iterate(java.lang.String)>
<dacapo.eclipse.EclipseHarness: void preIteration(java.lang.String)>
<dacapo.eclipse.EclipseHarness: void setJavaHomeIfRequired()>
<dacapo.eclipse.EclipseHarness: void startup(java.lang.String)>
<dacapo.eclipse.EclipseTests$1: void <init>(java.lang.String,org.eclipse.core.resources.IWorkspaceRoot)>
<dacapo.eclipse.EclipseTests$1: void run(org.eclipse.core.runtime.IProgressMonitor)>
<dacapo.eclipse.EclipseTests: org.eclipse.jdt.core.ICompilationUnit getCompilationUnit(java.lang.String,java.lang.String,java.lang.String)>
<dacapo.eclipse.EclipseTests: org.eclipse.jdt.core.IJavaProject getProject(java.lang.String)>
<dacapo.eclipse.EclipseTests: void <clinit>()>
<dacapo.eclipse.EclipseTests: void <init>()>
<dacapo.eclipse.EclipseTests: void createWorkspaceProjects(org.eclipse.core.resources.IWorkspace,org.eclipse.core.resources.IWorkspaceRoot)>
<dacapo.eclipse.EclipseTests: void initialize()>
<dacapo.eclipse.EclipseTests: void runtests(java.lang.String[])>
<dacapo.eclipse.EclipseTests: void setUpFullSourceWorkspace()>
<dacapo.eclipse.HarnessRunner: boolean validJavaHome()>
<dacapo.eclipse.HarnessRunner: java.lang.Object run(java.lang.Object)>
<dacapo.eclipse.HarnessRunner: void <init>()>
<dacapo.parser.Config$OutputFile: void <init>(dacapo.parser.Config,java.lang.String)>
<dacapo.parser.Config$Size: dacapo.parser.Config$OutputFile getOutputFile(java.lang.String)>
<dacapo.parser.Config$Size: void <init>(dacapo.parser.Config,java.lang.String,java.util.Vector)>
<dacapo.parser.Config$Size: void addOutputFile(java.lang.String)>
<dacapo.parser.Config: dacapo.parser.Config parse(java.io.InputStream)>
<dacapo.parser.Config: dacapo.parser.Config$Size getSize(java.lang.String)>
<dacapo.parser.Config: java.lang.String[] getArgs(java.lang.String)>
<dacapo.parser.Config: void <init>(java.lang.String)>
<dacapo.parser.Config: void addDesc(java.lang.String,java.lang.String)>
<dacapo.parser.Config: void addOutputFile(java.lang.String,java.lang.String)>
<dacapo.parser.Config: void addSize(java.lang.String,java.util.Vector)>
<dacapo.parser.Config: void setClass(java.lang.String)>
<dacapo.parser.Config: void setDigest(java.lang.String,java.lang.String,java.lang.String)>
<dacapo.parser.Config: void setFilterScratch(java.lang.String,java.lang.String,boolean)>
<dacapo.parser.Config: void setTextFile(java.lang.String,java.lang.String,boolean)>
<dacapo.parser.ConfigFile: dacapo.parser.Config config()>
<dacapo.parser.ConfigFile: dacapo.parser.Config configFile()>
<dacapo.parser.ConfigFile: dacapo.parser.Token jj_consume_token(int)>
<dacapo.parser.ConfigFile: int jj_ntk()>
<dacapo.parser.ConfigFile: java.lang.String descId()>
<dacapo.parser.ConfigFile: java.lang.String hex()>
<dacapo.parser.ConfigFile: java.lang.String string()>
<dacapo.parser.ConfigFile: java.lang.String unHex(dacapo.parser.Token)>
<dacapo.parser.ConfigFile: java.lang.String unQuote(dacapo.parser.Token)>
<dacapo.parser.ConfigFile: void <clinit>()>
<dacapo.parser.ConfigFile: void <init>(java.io.InputStream)>
<dacapo.parser.ConfigFile: void descElement(dacapo.parser.Config)>
<dacapo.parser.ConfigFile: void description(dacapo.parser.Config)>
<dacapo.parser.ConfigFile: void jj_la1_0()>
<dacapo.parser.ConfigFile: void jj_la1_1()>
<dacapo.parser.ConfigFile: void outputClause(dacapo.parser.Config,java.lang.String,java.lang.String)>
<dacapo.parser.ConfigFile: void outputFile(dacapo.parser.Config,java.lang.String)>
<dacapo.parser.ConfigFile: void sizeClause(dacapo.parser.Config,java.lang.String)>
<dacapo.parser.ConfigFile: void sizeSpec(dacapo.parser.Config)>
<dacapo.parser.ConfigFileTokenManager: dacapo.parser.Token getNextToken()>
<dacapo.parser.ConfigFileTokenManager: dacapo.parser.Token jjFillToken()>
<dacapo.parser.ConfigFileTokenManager: int jjMoveNfa_0(int,int)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa0_0()>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa10_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa1_0(long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa2_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa3_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa4_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa5_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa6_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa7_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa8_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjMoveStringLiteralDfa9_0(long,long)>
<dacapo.parser.ConfigFileTokenManager: int jjStartNfaWithStates_0(int,int,int)>
<dacapo.parser.ConfigFileTokenManager: int jjStartNfa_0(int,long)>
<dacapo.parser.ConfigFileTokenManager: int jjStopAtPos(int,int)>
<dacapo.parser.ConfigFileTokenManager: int jjStopStringLiteralDfa_0(int,long)>
<dacapo.parser.ConfigFileTokenManager: void <clinit>()>
<dacapo.parser.ConfigFileTokenManager: void <init>(dacapo.parser.SimpleCharStream)>
<dacapo.parser.ConfigFileTokenManager: void jjCheckNAdd(int)>
<dacapo.parser.ConfigFileTokenManager: void jjCheckNAddStates(int,int)>
<dacapo.parser.SimpleCharStream: char BeginToken()>
<dacapo.parser.SimpleCharStream: char readChar()>
<dacapo.parser.SimpleCharStream: int getBeginColumn()>
<dacapo.parser.SimpleCharStream: int getBeginLine()>
<dacapo.parser.SimpleCharStream: int getEndColumn()>
<dacapo.parser.SimpleCharStream: int getEndLine()>
<dacapo.parser.SimpleCharStream: java.lang.String GetImage()>
<dacapo.parser.SimpleCharStream: void <init>(java.io.InputStream,int,int)>
<dacapo.parser.SimpleCharStream: void <init>(java.io.InputStream,int,int,int)>
<dacapo.parser.SimpleCharStream: void <init>(java.io.Reader,int,int,int)>
<dacapo.parser.SimpleCharStream: void FillBuff()>
<dacapo.parser.SimpleCharStream: void UpdateLineColumn(char)>
<dacapo.parser.SimpleCharStream: void backup(int)>
<dacapo.parser.Token: dacapo.parser.Token newToken(int)>
<dacapo.parser.Token: void <init>()>
<java.io.BufferedInputStream: byte[] getBufIfOpen()>
<java.io.BufferedInputStream: int available()>
<java.io.BufferedInputStream: int read()>
<java.io.BufferedInputStream: int read(byte[],int,int)>
<java.io.BufferedInputStream: int read1(byte[],int,int)>
<java.io.BufferedInputStream: java.io.InputStream getInIfOpen()>
<java.io.BufferedInputStream: void <init>(java.io.InputStream)>
<java.io.BufferedInputStream: void <init>(java.io.InputStream,int)>
<java.io.BufferedInputStream: void close()>
<java.io.BufferedInputStream: void fill()>
<java.io.BufferedOutputStream: void <init>(java.io.OutputStream)>
<java.io.BufferedOutputStream: void <init>(java.io.OutputStream,int)>
<java.io.BufferedOutputStream: void flush()>
<java.io.BufferedOutputStream: void flushBuffer()>
<java.io.BufferedOutputStream: void write(byte[],int,int)>
<java.io.BufferedOutputStream: void write(int)>
<java.io.BufferedReader: java.lang.String readLine()>
<java.io.BufferedReader: java.lang.String readLine(boolean)>
<java.io.BufferedReader: void <init>(java.io.Reader)>
<java.io.BufferedReader: void <init>(java.io.Reader,int)>
<java.io.BufferedReader: void close()>
<java.io.BufferedReader: void ensureOpen()>
<java.io.BufferedReader: void fill()>
<java.io.BufferedWriter: int min(int,int)>
<java.io.BufferedWriter: void <init>(java.io.Writer)>
<java.io.BufferedWriter: void <init>(java.io.Writer,int)>
<java.io.BufferedWriter: void close()>
<java.io.BufferedWriter: void ensureOpen()>
<java.io.BufferedWriter: void flush()>
<java.io.BufferedWriter: void flushBuffer()>
<java.io.BufferedWriter: void newLine()>
<java.io.BufferedWriter: void write(int)>
<java.io.BufferedWriter: void write(java.lang.String,int,int)>
<java.io.ByteArrayInputStream: int available()>
<java.io.ByteArrayInputStream: int read(byte[],int,int)>
<java.io.ByteArrayInputStream: void <init>(byte[])>
<java.io.ByteArrayInputStream: void close()>
<java.io.ByteArrayOutputStream: java.lang.String toString(java.lang.String)>
<java.io.ByteArrayOutputStream: void <init>()>
<java.io.ByteArrayOutputStream: void <init>(int)>
<java.io.ByteArrayOutputStream: void write(int)>
<java.io.DataInputStream: byte readByte()>
<java.io.DataInputStream: int readInt()>
<java.io.DataInputStream: int readUnsignedShort()>
<java.io.DataInputStream: java.lang.String readUTF()>
<java.io.DataInputStream: java.lang.String readUTF(java.io.DataInput)>
<java.io.DataInputStream: void <init>(java.io.InputStream)>
<java.io.DataInputStream: void readFully(byte[],int,int)>
<java.io.DataOutputStream: int size()>
<java.io.DataOutputStream: int writeUTF(java.lang.String,java.io.DataOutput)>
<java.io.DataOutputStream: void <init>(java.io.OutputStream)>
<java.io.DataOutputStream: void flush()>
<java.io.DataOutputStream: void incCount(int)>
<java.io.DataOutputStream: void write(byte[],int,int)>
<java.io.DataOutputStream: void write(int)>
<java.io.DataOutputStream: void writeByte(int)>
<java.io.DataOutputStream: void writeInt(int)>
<java.io.DataOutputStream: void writeLong(long)>
<java.io.DataOutputStream: void writeShort(int)>
<java.io.DataOutputStream: void writeUTF(java.lang.String)>
<java.io.DeleteOnExitHook$1: void <init>()>
<java.io.DeleteOnExitHook: void <clinit>()>
<java.io.DeleteOnExitHook: void add(java.lang.String)>
<java.io.EOFException: void <init>()>
<java.io.ExpiringCache$1: boolean removeEldestEntry(java.util.Map$Entry)>
<java.io.ExpiringCache$Entry: java.lang.String val()>
<java.io.ExpiringCache$Entry: long timestamp()>
<java.io.ExpiringCache$Entry: void <init>(long,java.lang.String)>
<java.io.ExpiringCache: int access$000(java.io.ExpiringCache)>
<java.io.ExpiringCache: java.io.ExpiringCache$Entry entryFor(java.lang.String)>
<java.io.ExpiringCache: java.lang.String get(java.lang.String)>
<java.io.ExpiringCache: void clear()>
<java.io.ExpiringCache: void put(java.lang.String,java.lang.String)>
<java.io.File$LazyInitialization: java.lang.String temporaryDirectory()>
<java.io.File$LazyInitialization: void <clinit>()>
<java.io.File: boolean canWrite()>
<java.io.File: boolean checkAndCreate(java.lang.String,java.lang.SecurityManager,boolean)>
<java.io.File: boolean createNewFile()>
<java.io.File: boolean delete()>
<java.io.File: boolean equals(java.lang.Object)>
<java.io.File: boolean exists()>
<java.io.File: boolean isAbsolute()>
<java.io.File: boolean isDirectory()>
<java.io.File: boolean isFile()>
<java.io.File: boolean mkdir()>
<java.io.File: boolean mkdirs()>
<java.io.File: boolean renameTo(java.io.File)>
<java.io.File: boolean setLastModified(long)>
<java.io.File: int compareTo(java.io.File)>
<java.io.File: int getPrefixLength()>
<java.io.File: int hashCode()>
<java.io.File: java.io.File createTempFile(java.lang.String,java.lang.String,java.io.File)>
<java.io.File: java.io.File createTempFile0(java.lang.String,java.lang.String,java.io.File,boolean)>
<java.io.File: java.io.File generateFile(java.lang.String,java.lang.String,java.io.File)>
<java.io.File: java.io.File getCanonicalFile()>
<java.io.File: java.io.File getParentFile()>
<java.io.File: java.io.FileSystem access$000()>
<java.io.File: java.io.File[] listFiles()>
<java.io.File: java.io.File[] listFiles(java.io.FileFilter)>
<java.io.File: java.lang.String getAbsolutePath()>
<java.io.File: java.lang.String getCanonicalPath()>
<java.io.File: java.lang.String getName()>
<java.io.File: java.lang.String getParent()>
<java.io.File: java.lang.String getPath()>
<java.io.File: java.lang.String slashify(java.lang.String,boolean)>
<java.io.File: java.lang.String toString()>
<java.io.File: java.lang.String[] list()>
<java.io.File: java.net.URL toURL()>
<java.io.File: long lastModified()>
<java.io.File: long length()>
<java.io.File: void <init>(java.io.File,java.lang.String)>
<java.io.File: void <init>(java.lang.String)>
<java.io.File: void <init>(java.lang.String,int)>
<java.io.File: void <init>(java.lang.String,java.io.File)>
<java.io.File: void <init>(java.lang.String,java.lang.String)>
<java.io.File: void deleteOnExit()>
<java.io.FileDescriptor: int decrementAndGetUseCount()>
<java.io.FileDescriptor: int incrementAndGetUseCount()>
<java.io.FileDescriptor: void <init>()>
<java.io.FileInputStream: int read(byte[])>
<java.io.FileInputStream: int read(byte[],int,int)>
<java.io.FileInputStream: void <init>(java.io.File)>
<java.io.FileInputStream: void <init>(java.lang.String)>
<java.io.FileInputStream: void close()>
<java.io.FileInputStream: void finalize()>
<java.io.FileNotFoundException: void <init>(java.lang.String)>
<java.io.FileNotFoundException: void <init>(java.lang.String,java.lang.String)>
<java.io.FileOutputStream: java.io.FileDescriptor getFD()>
<java.io.FileOutputStream: java.nio.channels.FileChannel getChannel()>
<java.io.FileOutputStream: void <init>(java.io.File)>
<java.io.FileOutputStream: void <init>(java.io.File,boolean)>
<java.io.FileOutputStream: void <init>(java.lang.String)>
<java.io.FileOutputStream: void <init>(java.lang.String,boolean)>
<java.io.FileOutputStream: void close()>
<java.io.FileOutputStream: void finalize()>
<java.io.FileOutputStream: void write(byte[])>
<java.io.FileOutputStream: void write(byte[],int,int)>
<java.io.FilePermission$1: java.lang.Object run()>
<java.io.FilePermission$1: java.lang.String run()>
<java.io.FilePermission$1: void <init>(java.io.FilePermission)>
<java.io.FilePermission: int getMask(java.lang.String)>
<java.io.FilePermission: java.lang.String access$000(java.io.FilePermission)>
<java.io.FilePermission: java.security.PermissionCollection newPermissionCollection()>
<java.io.FilePermission: void <init>(java.lang.String,java.lang.String)>
<java.io.FilePermission: void init(int)>
<java.io.FilePermissionCollection: void <clinit>()>
<java.io.FilePermissionCollection: void <init>()>
<java.io.FilePermissionCollection: void add(java.security.Permission)>
<java.io.FileReader: void <init>(java.io.File)>
<java.io.FileWriter: void <init>(java.io.File)>
<java.io.FilterInputStream: int available()>
<java.io.FilterInputStream: int read(byte[])>
<java.io.FilterInputStream: int read(byte[],int,int)>
<java.io.FilterInputStream: void <init>(java.io.InputStream)>
<java.io.FilterInputStream: void close()>
<java.io.FilterOutputStream: void <init>(java.io.OutputStream)>
<java.io.FilterOutputStream: void close()>
<java.io.FilterOutputStream: void flush()>
<java.io.FilterOutputStream: void write(byte[])>
<java.io.FilterOutputStream: void write(byte[],int,int)>
<java.io.FilterOutputStream: void write(int)>
<java.io.IOException: void <init>()>
<java.io.IOException: void <init>(java.lang.String)>
<java.io.IOException: void <init>(java.lang.String,java.lang.Throwable)>
<java.io.InputStream: int read(byte[])>
<java.io.InputStream: void <init>()>
<java.io.InputStream: void close()>
<java.io.InputStreamReader: int read(char[],int,int)>
<java.io.InputStreamReader: void <init>(java.io.InputStream)>
<java.io.InputStreamReader: void <init>(java.io.InputStream,java.lang.String)>
<java.io.InputStreamReader: void close()>
<java.io.ObjectStreamClass: java.lang.String getClassSignature(java.lang.Class)>
<java.io.ObjectStreamField: void <init>(java.lang.String,java.lang.Class)>
<java.io.ObjectStreamField: void <init>(java.lang.String,java.lang.Class,boolean)>
<java.io.OutputStream: void <init>()>
<java.io.OutputStream: void flush()>
<java.io.OutputStreamWriter: void <init>(java.io.OutputStream)>
<java.io.OutputStreamWriter: void <init>(java.io.OutputStream,java.lang.String)>
<java.io.OutputStreamWriter: void close()>
<java.io.OutputStreamWriter: void flush()>
<java.io.OutputStreamWriter: void flushBuffer()>
<java.io.OutputStreamWriter: void write(char[],int,int)>
<java.io.PrintStream: void <init>(boolean,java.io.OutputStream)>
<java.io.PrintStream: void <init>(java.io.OutputStream)>
<java.io.PrintStream: void <init>(java.io.OutputStream,boolean)>
<java.io.PrintStream: void ensureOpen()>
<java.io.PrintStream: void flush()>
<java.io.PrintStream: void init(java.io.OutputStreamWriter)>
<java.io.PrintStream: void newLine()>
<java.io.PrintStream: void print(java.lang.String)>
<java.io.PrintStream: void println(java.lang.Object)>
<java.io.PrintStream: void println(java.lang.String)>
<java.io.PrintStream: void write(byte[],int,int)>
<java.io.PrintStream: void write(int)>
<java.io.PrintStream: void write(java.lang.String)>
<java.io.PrintWriter: void <init>(java.io.OutputStream,boolean)>
<java.io.PrintWriter: void <init>(java.io.Writer)>
<java.io.PrintWriter: void <init>(java.io.Writer,boolean)>
<java.io.PrintWriter: void ensureOpen()>
<java.io.PrintWriter: void newLine()>
<java.io.PrintWriter: void print(java.lang.String)>
<java.io.PrintWriter: void println()>
<java.io.PrintWriter: void println(java.lang.Object)>
<java.io.PrintWriter: void println(java.lang.String)>
<java.io.PrintWriter: void write(java.lang.String)>
<java.io.PrintWriter: void write(java.lang.String,int,int)>
<java.io.PushbackInputStream: int read(byte[],int,int)>
<java.io.PushbackInputStream: void <init>(java.io.InputStream,int)>
<java.io.PushbackInputStream: void close()>
<java.io.PushbackInputStream: void ensureOpen()>
<java.io.PushbackInputStream: void unread(byte[],int,int)>
<java.io.RandomAccessFile: java.nio.channels.FileChannel getChannel()>
<java.io.RandomAccessFile: void <clinit>()>
<java.io.RandomAccessFile: void <init>(java.io.File,java.lang.String)>
<java.io.RandomAccessFile: void <init>(java.lang.String,java.lang.String)>
<java.io.RandomAccessFile: void close()>
<java.io.RandomAccessFile: void write(byte[],int,int)>
<java.io.RandomAccessFile: void writeInt(int)>
<java.io.RandomAccessFile: void writeUTF(java.lang.String)>
<java.io.Reader: void <init>()>
<java.io.Reader: void <init>(java.lang.Object)>
<java.io.StringReader: int read(char[],int,int)>
<java.io.StringReader: void <init>(java.lang.String)>
<java.io.StringReader: void close()>
<java.io.StringReader: void ensureOpen()>
<java.io.StringWriter: java.lang.String toString()>
<java.io.StringWriter: void <init>()>
<java.io.StringWriter: void write(java.lang.String)>
<java.io.StringWriter: void write(java.lang.String,int,int)>
<java.io.UnixFileSystem: boolean delete(java.io.File)>
<java.io.UnixFileSystem: boolean isAbsolute(java.io.File)>
<java.io.UnixFileSystem: boolean rename(java.io.File,java.io.File)>
<java.io.UnixFileSystem: int compare(java.io.File,java.io.File)>
<java.io.UnixFileSystem: int getBooleanAttributes(java.io.File)>
<java.io.UnixFileSystem: int hashCode(java.io.File)>
<java.io.UnixFileSystem: int prefixLength(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String canonicalize(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String normalize(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String normalize(java.lang.String,int,int)>
<java.io.UnixFileSystem: java.lang.String parentOrNull(java.lang.String)>
<java.io.UnixFileSystem: java.lang.String resolve(java.io.File)>
<java.io.UnixFileSystem: java.lang.String resolve(java.lang.String,java.lang.String)>
<java.io.Writer: void <init>()>
<java.io.Writer: void <init>(java.lang.Object)>
<java.io.Writer: void write(java.lang.String)>
<java.lang.AbstractStringBuilder: int length()>
<java.lang.AbstractStringBuilder: int stringSizeOfInt(int)>
<java.lang.AbstractStringBuilder: int stringSizeOfLong(long)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(char)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(char[],int,int)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(int)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(java.lang.String)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder append(long)>
<java.lang.AbstractStringBuilder: java.lang.AbstractStringBuilder deleteCharAt(int)>
<java.lang.AbstractStringBuilder: void <init>(int)>
<java.lang.AbstractStringBuilder: void expandCapacity(int)>
<java.lang.AbstractStringBuilder: void getChars(int,int,char[],int)>
<java.lang.AbstractStringBuilder: void setLength(int)>
<java.lang.ApplicationShutdownHooks$1: void run()>
<java.lang.ApplicationShutdownHooks: void runHooks()>
<java.lang.ArrayIndexOutOfBoundsException: void <init>(java.lang.String)>
<java.lang.Boolean: boolean booleanValue()>
<java.lang.Boolean: boolean equals(java.lang.Object)>
<java.lang.Boolean: boolean getBoolean(java.lang.String)>
<java.lang.Boolean: boolean toBoolean(java.lang.String)>
<java.lang.Boolean: java.lang.Boolean valueOf(boolean)>
<java.lang.Boolean: java.lang.Boolean valueOf(java.lang.String)>
<java.lang.Boolean: java.lang.String toString()>
<java.lang.Boolean: void <init>(boolean)>
<java.lang.Byte: byte parseByte(java.lang.String)>
<java.lang.Byte: byte parseByte(java.lang.String,int)>
<java.lang.Byte: java.lang.String toString(byte)>
<java.lang.Character: boolean isDigit(char)>
<java.lang.Character: boolean isDigit(int)>
<java.lang.Character: boolean isLetter(char)>
<java.lang.Character: boolean isLetter(int)>
<java.lang.Character: boolean isLetterOrDigit(char)>
<java.lang.Character: boolean isLetterOrDigit(int)>
<java.lang.Character: boolean isUpperCase(char)>
<java.lang.Character: boolean isUpperCase(int)>
<java.lang.Character: boolean isWhitespace(char)>
<java.lang.Character: boolean isWhitespace(int)>
<java.lang.Character: char toLowerCase(char)>
<java.lang.Character: char toUpperCase(char)>
<java.lang.Character: int charCount(int)>
<java.lang.Character: int digit(char,int)>
<java.lang.Character: int digit(int,int)>
<java.lang.Character: int toLowerCase(int)>
<java.lang.Character: int toUpperCase(int)>
<java.lang.Character: int toUpperCaseEx(int)>
<java.lang.CharacterDataLatin1: boolean isDigit(int)>
<java.lang.CharacterDataLatin1: boolean isLetter(int)>
<java.lang.CharacterDataLatin1: boolean isLetterOrDigit(int)>
<java.lang.CharacterDataLatin1: boolean isUpperCase(int)>
<java.lang.CharacterDataLatin1: boolean isWhitespace(int)>
<java.lang.CharacterDataLatin1: int digit(int,int)>
<java.lang.CharacterDataLatin1: int getProperties(int)>
<java.lang.CharacterDataLatin1: int getType(int)>
<java.lang.CharacterDataLatin1: int toLowerCase(int)>
<java.lang.CharacterDataLatin1: int toUpperCase(int)>
<java.lang.CharacterDataLatin1: int toUpperCaseEx(int)>
<java.lang.Class$1: java.lang.Object run()>
<java.lang.Class$1: void <init>(java.lang.Class,java.lang.reflect.Constructor)>
<java.lang.Class: boolean arrayContentsEq(java.lang.Object[],java.lang.Object[])>
<java.lang.Class: boolean desiredAssertionStatus()>
<java.lang.Class: java.io.InputStream getResourceAsStream(java.lang.String)>
<java.lang.Class: java.lang.Class forName(java.lang.String)>
<java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)>
<java.lang.Class: java.lang.ClassLoader getClassLoader()>
<java.lang.Class: java.lang.Object newInstance()>
<java.lang.Class: java.lang.Object newInstance0()>
<java.lang.Class: java.lang.String argumentTypesToString(java.lang.Class[])>
<java.lang.Class: java.lang.String getName()>
<java.lang.Class: java.lang.String resolveName(java.lang.String)>
<java.lang.Class: java.lang.reflect.Constructor getConstructor(java.lang.Class[])>
<java.lang.Class: java.lang.reflect.Constructor getConstructor0(java.lang.Class[],int)>
<java.lang.Class: java.lang.reflect.Constructor[] privateGetDeclaredConstructors(boolean)>
<java.lang.Class: java.lang.reflect.Field getDeclaredField(java.lang.String)>
<java.lang.Class: java.lang.reflect.Field searchFields(java.lang.reflect.Field[],java.lang.String)>
<java.lang.Class: java.lang.reflect.Field[] copyFields(java.lang.reflect.Field[])>
<java.lang.Class: java.lang.reflect.Field[] getDeclaredFields()>
<java.lang.Class: java.lang.reflect.Field[] privateGetDeclaredFields(boolean)>
<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>
<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>
<java.lang.Class: java.lang.reflect.Method getMethod0(java.lang.String,java.lang.Class[])>
<java.lang.Class: java.lang.reflect.Method searchMethods(java.lang.reflect.Method[],java.lang.String,java.lang.Class[])>
<java.lang.Class: java.lang.reflect.Method[] privateGetDeclaredMethods(boolean)>
<java.lang.Class: java.net.URL getResource(java.lang.String)>
<java.lang.Class: sun.reflect.ReflectionFactory getReflectionFactory()>
<java.lang.Class: void checkInitted()>
<java.lang.Class: void checkMemberAccess(int,java.lang.ClassLoader,boolean)>
<java.lang.Class: void clearCachesOnClassRedefinition()>
<java.lang.ClassLoader$2: boolean hasMoreElements()>
<java.lang.ClassLoader$2: void <init>(java.util.Enumeration)>
<java.lang.ClassLoader$3: java.lang.Object run()>
<java.lang.ClassLoader$3: void <init>(java.io.File)>
<java.lang.ClassLoader$NativeLibrary: java.lang.Class getFromClass()>
<java.lang.ClassLoader$NativeLibrary: void <init>(java.lang.Class,java.lang.String)>
<java.lang.ClassLoader: boolean checkName(java.lang.String)>
<java.lang.ClassLoader: boolean compareCerts(java.security.cert.Certificate[],java.security.cert.Certificate[])>
<java.lang.ClassLoader: boolean loadLibrary0(java.lang.Class,java.io.File)>
<java.lang.ClassLoader: java.io.InputStream getResourceAsStream(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)>
<java.lang.ClassLoader: java.lang.Class defineClassCond(java.lang.String,byte[],int,int,java.security.ProtectionDomain,boolean)>
<java.lang.ClassLoader: java.lang.Class findBootstrapClassOrNull(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class findClass(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class findLoadedClass(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class loadClass(java.lang.String)>
<java.lang.ClassLoader: java.lang.Class loadClass(java.lang.String,boolean)>
<java.lang.ClassLoader: java.lang.ClassLoader getCallerClassLoader()>
<java.lang.ClassLoader: java.lang.ClassLoader getParent()>
<java.lang.ClassLoader: java.lang.ClassLoader getSystemClassLoader()>
<java.lang.ClassLoader: java.lang.Package definePackage(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL)>
<java.lang.ClassLoader: java.lang.Package getPackage(java.lang.String)>
<java.lang.ClassLoader: java.lang.String defineClassSourceLocation(java.security.ProtectionDomain)>
<java.lang.ClassLoader: java.lang.Void checkCreateClassLoader()>
<java.lang.ClassLoader: java.net.URL findResource(java.lang.String)>
<java.lang.ClassLoader: java.net.URL getBootstrapResource(java.lang.String)>
<java.lang.ClassLoader: java.net.URL getResource(java.lang.String)>
<java.lang.ClassLoader: java.security.ProtectionDomain preDefineClass(java.lang.String,java.security.ProtectionDomain)>
<java.lang.ClassLoader: java.util.Enumeration getBootstrapResources(java.lang.String)>
<java.lang.ClassLoader: java.util.Enumeration getResources(java.lang.String)>
<java.lang.ClassLoader: java.util.Stack access$100()>
<java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)>
<java.lang.ClassLoader: sun.misc.URLClassPath getBootstrapClassPath()>
<java.lang.ClassLoader: void <init>()>
<java.lang.ClassLoader: void <init>(java.lang.ClassLoader)>
<java.lang.ClassLoader: void <init>(java.lang.Void,java.lang.ClassLoader)>
<java.lang.ClassLoader: void addClass(java.lang.Class)>
<java.lang.ClassLoader: void checkCerts(java.lang.String,java.security.CodeSource)>
<java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)>
<java.lang.ClassLoader: void initSystemClassLoader()>
<java.lang.ClassLoader: void loadLibrary(java.lang.Class,java.lang.String,boolean)>
<java.lang.ClassLoader: void postDefineClass(java.lang.Class,java.security.ProtectionDomain)>
<java.lang.ClassNotFoundException: void <init>(java.lang.String)>
<java.lang.Double: double doubleValue()>
<java.lang.Double: java.lang.Double valueOf(double)>
<java.lang.Double: java.lang.String toString(double)>
<java.lang.Double: long doubleToLongBits(double)>
<java.lang.Double: void <init>(double)>
<java.lang.Enum: void <init>(java.lang.String,int)>
<java.lang.Error: void <init>(java.lang.String)>
<java.lang.Exception: void <init>()>
<java.lang.Exception: void <init>(java.lang.String)>
<java.lang.Exception: void <init>(java.lang.String,java.lang.Throwable)>
<java.lang.Exception: void <init>(java.lang.Throwable)>
<java.lang.Float: boolean isNaN(float)>
<java.lang.Float: float floatValue()>
<java.lang.Float: int floatToIntBits(float)>
<java.lang.Float: java.lang.Float valueOf(float)>
<java.lang.Float: void <init>(float)>
<java.lang.IllegalArgumentException: void <init>()>
<java.lang.IllegalArgumentException: void <init>(java.lang.String)>
<java.lang.IndexOutOfBoundsException: void <init>(java.lang.String)>
<java.lang.InheritableThreadLocal: void <init>()>
<java.lang.Integer: boolean equals(java.lang.Object)>
<java.lang.Integer: int compareTo(java.lang.Integer)>
<java.lang.Integer: int compareTo(java.lang.Object)>
<java.lang.Integer: int hashCode()>
<java.lang.Integer: int intValue()>
<java.lang.Integer: int parseInt(java.lang.String)>
<java.lang.Integer: int parseInt(java.lang.String,int)>
<java.lang.Integer: int reverseBytes(int)>
<java.lang.Integer: int stringSize(int)>
<java.lang.Integer: java.lang.Integer decode(java.lang.String)>
<java.lang.Integer: java.lang.Integer getInteger(java.lang.String)>
<java.lang.Integer: java.lang.Integer getInteger(java.lang.String,java.lang.Integer)>
<java.lang.Integer: java.lang.Integer valueOf(int)>
<java.lang.Integer: java.lang.Integer valueOf(java.lang.String)>
<java.lang.Integer: java.lang.Integer valueOf(java.lang.String,int)>
<java.lang.Integer: java.lang.String toString(int)>
<java.lang.Integer: java.lang.String toString(int,int)>
<java.lang.Integer: void <init>(int)>
<java.lang.Integer: void <init>(java.lang.String)>
<java.lang.Integer: void getChars(int,int,char[])>
<java.lang.LinkageError: void <init>(java.lang.String)>
<java.lang.Long: boolean equals(java.lang.Object)>
<java.lang.Long: int hashCode()>
<java.lang.Long: int stringSize(long)>
<java.lang.Long: java.lang.Long valueOf(long)>
<java.lang.Long: java.lang.String toHexString(long)>
<java.lang.Long: java.lang.String toString(long)>
<java.lang.Long: java.lang.String toString(long,int)>
<java.lang.Long: java.lang.String toUnsignedString(long,int)>
<java.lang.Long: long longValue()>
<java.lang.Long: long parseLong(java.lang.String)>
<java.lang.Long: long parseLong(java.lang.String,int)>
<java.lang.Long: void <init>(long)>
<java.lang.Long: void getChars(long,int,char[])>
<java.lang.Math: double floor(double)>
<java.lang.Math: double pow(double,double)>
<java.lang.Math: float min(float,float)>
<java.lang.Math: int abs(int)>
<java.lang.Math: int getExponent(double)>
<java.lang.Math: int max(int,int)>
<java.lang.Math: int min(int,int)>
<java.lang.Math: int round(float)>
<java.lang.Math: long abs(long)>
<java.lang.Math: long max(long,long)>
<java.lang.Math: long min(long,long)>
<java.lang.NoSuchMethodException: void <init>(java.lang.String)>
<java.lang.NullPointerException: void <init>()>
<java.lang.Number: void <init>()>
<java.lang.NumberFormatException: void <init>(java.lang.String)>
<java.lang.Package: boolean isSealed()>
<java.lang.Package: java.lang.Package getSystemPackage(java.lang.String)>
<java.lang.Package: void <clinit>()>
<java.lang.Package: void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL,java.lang.ClassLoader)>
<java.lang.Process: void <init>()>
<java.lang.ProcessBuilder: java.lang.Process start()>
<java.lang.ProcessBuilder: java.lang.ProcessBuilder directory(java.io.File)>
<java.lang.ProcessBuilder: java.lang.ProcessBuilder environment(java.lang.String[])>
<java.lang.ProcessBuilder: void <clinit>()>
<java.lang.ProcessBuilder: void <init>(java.lang.String[])>
<java.lang.ProcessEnvironment$ExternalData: byte[] getBytes()>
<java.lang.ProcessEnvironment$ExternalData: int hashCode()>
<java.lang.ProcessEnvironment$ExternalData: void <init>(java.lang.String,byte[])>
<java.lang.ProcessEnvironment$StringEnvironment: void <init>(java.util.Map)>
<java.lang.ProcessEnvironment$Value: java.lang.ProcessEnvironment$Value valueOf(byte[])>
<java.lang.ProcessEnvironment$Value: void <init>(java.lang.String,byte[])>
<java.lang.ProcessEnvironment$Variable: java.lang.ProcessEnvironment$Variable valueOf(byte[])>
<java.lang.ProcessEnvironment$Variable: void <init>(java.lang.String,byte[])>
<java.lang.ProcessEnvironment: byte[] toEnvironmentBlock(java.util.Map,int[])>
<java.lang.ProcessEnvironment: int access$100(byte[])>
<java.lang.ProcessEnvironment: int arrayHash(byte[])>
<java.lang.ProcessEnvironment: void <clinit>()>
<java.lang.ProcessImpl: byte[] toCString(java.lang.String)>
<java.lang.ProcessImpl: java.lang.Process start(java.lang.String[],java.util.Map,java.lang.String,boolean)>
<java.lang.ProcessImpl: void <clinit>()>
<java.lang.Runtime: java.lang.Process exec(java.lang.String[])>
<java.lang.Runtime: java.lang.Process exec(java.lang.String[],java.lang.String[],java.io.File)>
<java.lang.Runtime: java.lang.Runtime getRuntime()>
<java.lang.Runtime: void exit(int)>
<java.lang.Runtime: void loadLibrary0(java.lang.Class,java.lang.String)>
<java.lang.RuntimeException: void <init>()>
<java.lang.RuntimeException: void <init>(java.lang.String)>
<java.lang.RuntimePermission: void <init>(java.lang.String)>
<java.lang.SecurityManager: java.lang.ThreadGroup getRootGroup()>
<java.lang.SecurityManager: void <clinit>()>
<java.lang.SecurityManager: void <init>()>
<java.lang.Short: void <clinit>()>
<java.lang.Shutdown: void add(int,java.lang.Runnable)>
<java.lang.Shutdown: void exit(int)>
<java.lang.Shutdown: void runHooks()>
<java.lang.Shutdown: void sequence()>
<java.lang.Shutdown: void shutdown()>
<java.lang.StackTraceElement: boolean eq(java.lang.Object,java.lang.Object)>
<java.lang.StackTraceElement: boolean equals(java.lang.Object)>
<java.lang.StackTraceElement: boolean isNativeMethod()>
<java.lang.StackTraceElement: java.lang.String getClassName()>
<java.lang.StackTraceElement: java.lang.String toString()>
<java.lang.StrictMath: double floor(double)>
<java.lang.StrictMath: double floorOrCeil(double,double,double,double)>
<java.lang.StrictMath: void <clinit>()>
<java.lang.System$2: void blockedOn(java.lang.Thread,sun.nio.ch.Interruptible)>
<java.lang.System$2: void registerShutdownHook(int,java.lang.Runnable)>
<java.lang.System: java.lang.Class getCallerClass()>
<java.lang.System: java.lang.SecurityManager getSecurityManager()>
<java.lang.System: java.lang.String getProperty(java.lang.String)>
<java.lang.System: java.lang.String getProperty(java.lang.String,java.lang.String)>
<java.lang.System: java.lang.String setProperty(java.lang.String,java.lang.String)>
<java.lang.System: java.util.Properties getProperties()>
<java.lang.System: void checkIO()>
<java.lang.System: void checkKey(java.lang.String)>
<java.lang.System: void exit(int)>
<java.lang.System: void loadLibrary(java.lang.String)>
<java.lang.System: void setErr(java.io.PrintStream)>
<java.lang.System: void setOut(java.io.PrintStream)>
<java.lang.System: void setProperties(java.util.Properties)>
<java.lang.Terminator$1: void handle(sun.misc.Signal)>
<java.lang.Throwable: java.lang.StackTraceElement[] getOurStackTrace()>
<java.lang.Throwable: java.lang.String getLocalizedMessage()>
<java.lang.Throwable: java.lang.String getMessage()>
<java.lang.Throwable: java.lang.String toString()>
<java.lang.Throwable: java.lang.Throwable getCause()>
<java.lang.Throwable: void <init>()>
<java.lang.Throwable: void <init>(java.lang.String)>
<java.lang.Throwable: void <init>(java.lang.String,java.lang.Throwable)>
<java.lang.Throwable: void <init>(java.lang.Throwable)>
<java.lang.Throwable: void printStackTrace()>
<java.lang.Throwable: void printStackTrace(java.io.PrintStream)>
<java.lang.Throwable: void printStackTrace(java.io.PrintWriter)>
<java.lang.Throwable: void printStackTraceAsCause(java.io.PrintWriter,java.lang.StackTraceElement[])>
<java.lang.UNIXProcess$1$1: void <init>(java.lang.UNIXProcess$1,java.lang.String)>
<java.lang.UNIXProcess$1$1: void run()>
<java.lang.UNIXProcess$1: java.lang.Object run()>
<java.lang.UNIXProcess$1: void <init>(java.lang.UNIXProcess,byte[],byte[],int,byte[],int,byte[],boolean,java.lang.UNIXProcess$Gate)>
<java.lang.UNIXProcess$Gate: java.io.IOException getException()>
<java.lang.UNIXProcess$Gate: void <init>()>
<java.lang.UNIXProcess$Gate: void <init>(java.lang.UNIXProcess$1)>
<java.lang.UNIXProcess$Gate: void exit()>
<java.lang.UNIXProcess$Gate: void setException(java.io.IOException)>
<java.lang.UNIXProcess$Gate: void waitForExit()>
<java.lang.UNIXProcess: int access$500(java.lang.UNIXProcess,byte[],byte[],int,byte[],int,byte[],boolean,java.io.FileDescriptor,java.io.FileDescriptor,java.io.FileDescriptor)>
<java.lang.UNIXProcess: java.io.FileDescriptor access$200(java.lang.UNIXProcess)>
<java.lang.UNIXProcess: java.io.FileDescriptor access$300(java.lang.UNIXProcess)>
<java.lang.UNIXProcess: java.io.FileDescriptor access$400(java.lang.UNIXProcess)>
<java.lang.UNIXProcess: void <clinit>()>
<java.lang.UNIXProcess: void <init>(byte[],byte[],int,byte[],int,byte[],boolean)>
<java.lang.UnsatisfiedLinkError: void <init>(java.lang.String)>
<java.lang.Void: void <clinit>()>
<java.lang.ref.FinalReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.ref.Finalizer: boolean hasBeenFinalized()>
<java.lang.ref.Finalizer: java.lang.ref.ReferenceQueue access$000()>
<java.lang.ref.Finalizer: void <init>(java.lang.Object)>
<java.lang.ref.Finalizer: void access$100(java.lang.ref.Finalizer)>
<java.lang.ref.Finalizer: void add()>
<java.lang.ref.Finalizer: void register(java.lang.Object)>
<java.lang.ref.Finalizer: void remove()>
<java.lang.ref.Finalizer: void runFinalizer()>
<java.lang.ref.Reference: java.lang.Object get()>
<java.lang.ref.Reference: java.lang.ref.Reference access$200()>
<java.lang.ref.Reference: java.lang.ref.Reference access$202(java.lang.ref.Reference)>
<java.lang.ref.Reference: java.lang.ref.Reference$Lock access$100()>
<java.lang.ref.Reference: void <init>(java.lang.Object)>
<java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.ref.Reference: void clear()>
<java.lang.ref.ReferenceQueue$Lock: void <init>()>
<java.lang.ref.ReferenceQueue$Lock: void <init>(java.lang.ref.ReferenceQueue$1)>
<java.lang.ref.ReferenceQueue: boolean enqueue(java.lang.ref.Reference)>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference poll()>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference reallyPoll()>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference remove()>
<java.lang.ref.ReferenceQueue: java.lang.ref.Reference remove(long)>
<java.lang.ref.ReferenceQueue: void <init>()>
<java.lang.ref.SoftReference: java.lang.Object get()>
<java.lang.ref.SoftReference: void <init>(java.lang.Object)>
<java.lang.ref.SoftReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.ref.WeakReference: void <init>(java.lang.Object)>
<java.lang.ref.WeakReference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>
<java.lang.reflect.AccessibleObject: void <init>()>
<java.lang.reflect.AccessibleObject: void setAccessible(boolean)>
<java.lang.reflect.AccessibleObject: void setAccessible0(java.lang.reflect.AccessibleObject,boolean)>
<java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)>
<java.lang.reflect.Constructor: int getModifiers()>
<java.lang.reflect.Constructor: java.lang.Class getDeclaringClass()>
<java.lang.reflect.Constructor: java.lang.Class[] getExceptionTypes()>
<java.lang.reflect.Constructor: java.lang.Class[] getParameterTypes()>
<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>
<java.lang.reflect.Constructor: java.lang.reflect.Constructor copy()>
<java.lang.reflect.Constructor: sun.reflect.ConstructorAccessor getConstructorAccessor()>
<java.lang.reflect.Constructor: void <init>(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])>
<java.lang.reflect.Constructor: void acquireConstructorAccessor()>
<java.lang.reflect.Constructor: void setConstructorAccessor(sun.reflect.ConstructorAccessor)>
<java.lang.reflect.Field: int getModifiers()>
<java.lang.reflect.Field: java.lang.Class getDeclaringClass()>
<java.lang.reflect.Field: java.lang.Class getType()>
<java.lang.reflect.Field: java.lang.Object get(java.lang.Object)>
<java.lang.reflect.Field: java.lang.String getName()>
<java.lang.reflect.Field: java.lang.reflect.Field copy()>
<java.lang.reflect.Field: sun.reflect.FieldAccessor acquireFieldAccessor(boolean)>
<java.lang.reflect.Field: sun.reflect.FieldAccessor getFieldAccessor(boolean)>
<java.lang.reflect.Field: sun.reflect.FieldAccessor getFieldAccessor(java.lang.Object)>
<java.lang.reflect.Field: void <init>(java.lang.Class,java.lang.String,java.lang.Class,int,int,java.lang.String,byte[])>
<java.lang.reflect.Field: void doSecurityCheck(java.lang.Object)>
<java.lang.reflect.Field: void set(java.lang.Object,java.lang.Object)>
<java.lang.reflect.Field: void setFieldAccessor(sun.reflect.FieldAccessor,boolean)>
<java.lang.reflect.Method: int getModifiers()>
<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>
<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>
<java.lang.reflect.Method: java.lang.String getName()>
<java.lang.reflect.Method: java.lang.reflect.Method copy()>
<java.lang.reflect.Method: sun.reflect.MethodAccessor getMethodAccessor()>
<java.lang.reflect.Method: void <init>(java.lang.Class,java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class[],int,int,java.lang.String,byte[],byte[],byte[])>
<java.lang.reflect.Method: void acquireMethodAccessor()>
<java.lang.reflect.Method: void setMethodAccessor(sun.reflect.MethodAccessor)>
<java.lang.reflect.Modifier: boolean isAbstract(int)>
<java.lang.reflect.Modifier: boolean isFinal(int)>
<java.lang.reflect.Modifier: boolean isPrivate(int)>
<java.lang.reflect.Modifier: boolean isProtected(int)>
<java.lang.reflect.Modifier: boolean isPublic(int)>
<java.lang.reflect.Modifier: boolean isStatic(int)>
<java.lang.reflect.Modifier: boolean isVolatile(int)>
<java.lang.reflect.ReflectAccess: java.lang.reflect.Constructor copyConstructor(java.lang.reflect.Constructor)>
<java.lang.reflect.ReflectAccess: java.lang.reflect.Field copyField(java.lang.reflect.Field)>
<java.lang.reflect.ReflectAccess: java.lang.reflect.Method copyMethod(java.lang.reflect.Method)>
<java.math.RoundingMode: void <clinit>()>
<java.math.RoundingMode: void <init>(java.lang.String,int,int)>
<java.net.ContentHandler: void <init>()>
<java.net.Inet4Address: byte[] getAddress()>
<java.net.Inet4Address: java.lang.String getHostAddress()>
<java.net.Inet4Address: java.lang.String numericToTextFormat(byte[])>
<java.net.Inet4Address: void <clinit>()>
<java.net.Inet4Address: void <init>()>
<java.net.Inet4AddressImpl: java.net.InetAddress anyLocalAddress()>
<java.net.Inet4AddressImpl: void <init>()>
<java.net.Inet6Address: void <clinit>()>
<java.net.Inet6AddressImpl: java.net.InetAddress anyLocalAddress()>
<java.net.Inet6AddressImpl: void <init>()>
<java.net.InetAddress$1: java.net.InetAddress[] lookupAllHostAddr(java.lang.String)>
<java.net.InetAddress$1: void <init>()>
<java.net.InetAddress$Cache$Type: void <clinit>()>
<java.net.InetAddress$Cache$Type: void <init>(java.lang.String,int)>
<java.net.InetAddress$Cache: int getPolicy()>
<java.net.InetAddress$Cache: java.net.InetAddress$Cache put(java.lang.String,java.lang.Object)>
<java.net.InetAddress$Cache: void <init>(java.net.InetAddress$Cache$Type)>
<java.net.InetAddress$CacheEntry: void <init>(java.lang.Object,long)>
<java.net.InetAddress$InetAddressHolder: int getAddress()>
<java.net.InetAddress$InetAddressHolder: java.lang.String getHostName()>
<java.net.InetAddress$InetAddressHolder: void <init>()>
<java.net.InetAddress: java.lang.Object checkLookupTable(java.lang.String)>
<java.net.InetAddress: java.lang.Object getAddressFromNameService(java.lang.String,java.net.InetAddress)>
<java.net.InetAddress: java.lang.Object loadImpl(java.lang.String)>
<java.net.InetAddress: java.lang.String getHostName()>
<java.net.InetAddress: java.lang.String getHostName(boolean)>
<java.net.InetAddress: java.lang.String toString()>
<java.net.InetAddress: java.net.InetAddress getLocalHost()>
<java.net.InetAddress: java.net.InetAddress$InetAddressHolder holder()>
<java.net.InetAddress: void <clinit>()>
<java.net.InetAddress: void <init>()>
<java.net.InetAddress: void cacheAddress(java.lang.String,java.lang.Object,boolean)>
<java.net.InetAddress: void cacheInitIfNeeded()>
<java.net.InetAddress: void updateLookupTable(java.lang.String)>
<java.net.InetAddressImplFactory: java.net.InetAddressImpl create()>
<java.net.InetAddressImplFactory: void <init>()>
<java.net.JarURLConnection: java.lang.String getEntryName()>
<java.net.JarURLConnection: java.net.URL getJarFileURL()>
<java.net.JarURLConnection: void <init>(java.net.URL)>
<java.net.JarURLConnection: void parseSpecs(java.net.URL)>
<java.net.MalformedURLException: void <init>(java.lang.String)>
<java.net.Parts: java.lang.String getPath()>
<java.net.Parts: java.lang.String getQuery()>
<java.net.Parts: java.lang.String getRef()>
<java.net.Parts: void <init>(java.lang.String)>
<java.net.URL: boolean equals(java.lang.Object)>
<java.net.URL: boolean isValidProtocol(java.lang.String)>
<java.net.URL: int getDefaultPort()>
<java.net.URL: int getPort()>
<java.net.URL: int hashCode()>
<java.net.URL: java.io.InputStream openStream()>
<java.net.URL: java.lang.String getAuthority()>
<java.net.URL: java.lang.String getFile()>
<java.net.URL: java.lang.String getHost()>
<java.net.URL: java.lang.String getPath()>
<java.net.URL: java.lang.String getProtocol()>
<java.net.URL: java.lang.String getQuery()>
<java.net.URL: java.lang.String getRef()>
<java.net.URL: java.lang.String getUserInfo()>
<java.net.URL: java.lang.String toExternalForm()>
<java.net.URL: java.lang.String toString()>
<java.net.URL: java.net.URLConnection openConnection()>
<java.net.URL: java.net.URLStreamHandler getURLStreamHandler(java.lang.String)>
<java.net.URL: void <init>(java.lang.String)>
<java.net.URL: void <init>(java.lang.String,java.lang.String,int,java.lang.String)>
<java.net.URL: void <init>(java.lang.String,java.lang.String,int,java.lang.String,java.net.URLStreamHandler)>
<java.net.URL: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<java.net.URL: void <init>(java.net.URL,java.lang.String)>
<java.net.URL: void <init>(java.net.URL,java.lang.String,java.net.URLStreamHandler)>
<java.net.URL: void set(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<java.net.URL: void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory)>
<java.net.URLClassLoader$1: java.lang.Object run()>
<java.net.URLClassLoader$1: void <init>(java.net.URLClassLoader,java.lang.String)>
<java.net.URLClassLoader$2: java.lang.Object run()>
<java.net.URLClassLoader$2: void <init>(java.net.URLClassLoader,java.lang.String)>
<java.net.URLClassLoader$3$1: java.lang.Object run()>
<java.net.URLClassLoader$3$1: void <init>(java.net.URLClassLoader$3)>
<java.net.URLClassLoader$3: boolean hasMoreElements()>
<java.net.URLClassLoader$3: boolean next()>
<java.net.URLClassLoader$3: void <init>(java.net.URLClassLoader,java.util.Enumeration)>
<java.net.URLClassLoader: boolean isSealed(java.lang.String,java.util.jar.Manifest)>
<java.net.URLClassLoader: java.lang.Class access$000(java.net.URLClassLoader,java.lang.String,sun.misc.Resource,boolean)>
<java.net.URLClassLoader: java.lang.Class defineClass(java.lang.String,sun.misc.Resource,boolean)>
<java.net.URLClassLoader: java.lang.Class findClass(java.lang.String)>
<java.net.URLClassLoader: java.lang.Package definePackage(java.lang.String,java.util.jar.Manifest,java.net.URL)>
<java.net.URLClassLoader: java.net.URL findResource(java.lang.String)>
<java.net.URLClassLoader: java.security.AccessControlContext access$100(java.net.URLClassLoader)>
<java.net.URLClassLoader: java.security.PermissionCollection getPermissions(java.security.CodeSource)>
<java.net.URLClassLoader: java.util.Enumeration findResources(java.lang.String)>
<java.net.URLConnection: boolean getUseCaches()>
<java.net.URLConnection: java.net.URL getURL()>
<java.net.URLConnection: void <clinit>()>
<java.net.URLConnection: void <init>(java.net.URL)>
<java.net.URLConnection: void setContentHandlerFactory(java.net.ContentHandlerFactory)>
<java.net.URLStreamHandler: boolean equals(java.net.URL,java.net.URL)>
<java.net.URLStreamHandler: boolean hostsEqual(java.net.URL,java.net.URL)>
<java.net.URLStreamHandler: boolean sameFile(java.net.URL,java.net.URL)>
<java.net.URLStreamHandler: int getDefaultPort()>
<java.net.URLStreamHandler: int hashCode(java.net.URL)>
<java.net.URLStreamHandler: java.lang.String toExternalForm(java.net.URL)>
<java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
<java.net.URLStreamHandler: void <init>()>
<java.net.URLStreamHandler: void parseURL(java.net.URL,java.lang.String,int,int)>
<java.net.URLStreamHandler: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String)>
<java.net.URLStreamHandler: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<java.net.UnknownContentHandler: void <init>()>
<java.nio.Bits: java.nio.ByteOrder byteOrder()>
<java.nio.Buffer: boolean hasRemaining()>
<java.nio.Buffer: int capacity()>
<java.nio.Buffer: int limit()>
<java.nio.Buffer: int position()>
<java.nio.Buffer: int remaining()>
<java.nio.Buffer: java.nio.Buffer clear()>
<java.nio.Buffer: java.nio.Buffer flip()>
<java.nio.Buffer: java.nio.Buffer limit(int)>
<java.nio.Buffer: java.nio.Buffer position(int)>
<java.nio.Buffer: void <init>(int,int,int,int)>
<java.nio.ByteBuffer: boolean hasArray()>
<java.nio.ByteBuffer: byte[] array()>
<java.nio.ByteBuffer: int arrayOffset()>
<java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>
<java.nio.ByteBuffer: java.nio.ByteBuffer wrap(byte[])>
<java.nio.ByteBuffer: java.nio.ByteBuffer wrap(byte[],int,int)>
<java.nio.ByteBuffer: void <init>(int,int,int,int,byte[],int)>
<java.nio.ByteOrder: java.nio.ByteOrder nativeOrder()>
<java.nio.CharBuffer: boolean hasArray()>
<java.nio.CharBuffer: char[] array()>
<java.nio.CharBuffer: int arrayOffset()>
<java.nio.CharBuffer: java.nio.CharBuffer allocate(int)>
<java.nio.CharBuffer: java.nio.CharBuffer wrap(char[])>
<java.nio.CharBuffer: java.nio.CharBuffer wrap(char[],int,int)>
<java.nio.CharBuffer: void <init>(int,int,int,int,char[],int)>
<java.nio.HeapByteBuffer: int ix(int)>
<java.nio.HeapByteBuffer: java.nio.ByteBuffer compact()>
<java.nio.HeapByteBuffer: void <init>(byte[],int,int)>
<java.nio.HeapByteBuffer: void <init>(int,int)>
<java.nio.HeapCharBuffer: java.nio.CharBuffer slice()>
<java.nio.HeapCharBuffer: void <init>(char[],int,int)>
<java.nio.HeapCharBuffer: void <init>(char[],int,int,int,int,int)>
<java.nio.HeapCharBuffer: void <init>(int,int)>
<java.nio.channels.FileChannel: java.nio.channels.FileLock lock()>
<java.nio.channels.FileChannel: java.nio.channels.FileLock tryLock()>
<java.nio.channels.FileChannel: void <init>()>
<java.nio.channels.FileLock: java.nio.channels.FileChannel channel()>
<java.nio.channels.FileLock: long position()>
<java.nio.channels.FileLock: long size()>
<java.nio.channels.FileLock: void <init>(java.nio.channels.FileChannel,long,long,boolean)>
<java.nio.channels.spi.AbstractInterruptibleChannel$1: void <init>(java.nio.channels.spi.AbstractInterruptibleChannel)>
<java.nio.channels.spi.AbstractInterruptibleChannel: boolean isOpen()>
<java.nio.channels.spi.AbstractInterruptibleChannel: void <init>()>
<java.nio.channels.spi.AbstractInterruptibleChannel: void begin()>
<java.nio.channels.spi.AbstractInterruptibleChannel: void blockedOn(sun.nio.ch.Interruptible)>
<java.nio.channels.spi.AbstractInterruptibleChannel: void close()>
<java.nio.channels.spi.AbstractInterruptibleChannel: void end(boolean)>
<java.nio.charset.Charset: boolean atBugLevel(java.lang.String)>
<java.nio.charset.Charset: boolean isSupported(java.lang.String)>
<java.nio.charset.Charset: java.lang.String name()>
<java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>
<java.nio.charset.Charset: java.nio.charset.Charset forName(java.lang.String)>
<java.nio.charset.Charset: java.nio.charset.Charset lookup(java.lang.String)>
<java.nio.charset.Charset: java.nio.charset.Charset lookup2(java.lang.String)>
<java.nio.charset.Charset: void <init>(java.lang.String,java.lang.String[])>
<java.nio.charset.Charset: void cache(java.lang.String,java.nio.charset.Charset)>
<java.nio.charset.Charset: void checkName(java.lang.String)>
<java.nio.charset.CharsetDecoder: float maxCharsPerByte()>
<java.nio.charset.CharsetDecoder: java.nio.charset.Charset charset()>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder onMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder onUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder replaceWith(java.lang.String)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CharsetDecoder reset()>
<java.nio.charset.CharsetDecoder: java.nio.charset.CoderResult decode(java.nio.ByteBuffer,java.nio.CharBuffer,boolean)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CoderResult flush(java.nio.CharBuffer)>
<java.nio.charset.CharsetDecoder: java.nio.charset.CoderResult implFlush(java.nio.CharBuffer)>
<java.nio.charset.CharsetDecoder: void <init>(java.nio.charset.Charset,float,float)>
<java.nio.charset.CharsetDecoder: void <init>(java.nio.charset.Charset,float,float,java.lang.String)>
<java.nio.charset.CharsetDecoder: void implOnMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetDecoder: void implReplaceWith(java.lang.String)>
<java.nio.charset.CharsetDecoder: void implReset()>
<java.nio.charset.CharsetEncoder: boolean isLegalReplacement(byte[])>
<java.nio.charset.CharsetEncoder: float maxBytesPerChar()>
<java.nio.charset.CharsetEncoder: java.nio.charset.Charset charset()>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder onMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder onUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder replaceWith(byte[])>
<java.nio.charset.CharsetEncoder: java.nio.charset.CharsetEncoder reset()>
<java.nio.charset.CharsetEncoder: java.nio.charset.CoderResult encode(java.nio.CharBuffer,java.nio.ByteBuffer,boolean)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CoderResult flush(java.nio.ByteBuffer)>
<java.nio.charset.CharsetEncoder: java.nio.charset.CoderResult implFlush(java.nio.ByteBuffer)>
<java.nio.charset.CharsetEncoder: void <init>(java.nio.charset.Charset,float,float)>
<java.nio.charset.CharsetEncoder: void <init>(java.nio.charset.Charset,float,float,byte[])>
<java.nio.charset.CharsetEncoder: void implOnMalformedInput(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: void implOnUnmappableCharacter(java.nio.charset.CodingErrorAction)>
<java.nio.charset.CharsetEncoder: void implReplaceWith(byte[])>
<java.nio.charset.CharsetEncoder: void implReset()>
<java.nio.charset.CoderResult: boolean isError()>
<java.nio.charset.CoderResult: boolean isOverflow()>
<java.nio.charset.CoderResult: boolean isUnderflow()>
<java.security.AccessControlContext: java.security.AccessControlContext optimize()>
<java.security.AccessControlContext: void <init>(java.security.ProtectionDomain[],boolean)>
<java.security.AccessController: java.security.AccessControlContext getContext()>
<java.security.AllPermission: java.security.PermissionCollection newPermissionCollection()>
<java.security.AllPermission: void <init>()>
<java.security.AllPermissionCollection: void <init>()>
<java.security.AllPermissionCollection: void add(java.security.Permission)>
<java.security.BasicPermission: java.lang.String getCanonicalName()>
<java.security.BasicPermission: java.security.PermissionCollection newPermissionCollection()>
<java.security.BasicPermission: void <init>(java.lang.String)>
<java.security.BasicPermission: void init(java.lang.String)>
<java.security.BasicPermissionCollection: void <clinit>()>
<java.security.BasicPermissionCollection: void <init>()>
<java.security.BasicPermissionCollection: void add(java.security.Permission)>
<java.security.CodeSource: boolean equals(java.lang.Object)>
<java.security.CodeSource: boolean matchCerts(java.security.CodeSource,boolean)>
<java.security.CodeSource: int hashCode()>
<java.security.CodeSource: java.net.URL getLocation()>
<java.security.CodeSource: java.security.cert.Certificate[] getCertificates()>
<java.security.CodeSource: void <init>(java.net.URL,java.security.CodeSigner[])>
<java.security.CodeSource: void <init>(java.net.URL,java.security.cert.Certificate[])>
<java.security.MessageDigest$Delegate: byte[] engineDigest()>
<java.security.MessageDigest$Delegate: void <init>(java.security.MessageDigestSpi,java.lang.String)>
<java.security.MessageDigest$Delegate: void engineUpdate(byte)>
<java.security.MessageDigest$Delegate: void engineUpdate(byte[],int,int)>
<java.security.MessageDigest: byte[] digest()>
<java.security.MessageDigest: byte[] digest(byte[])>
<java.security.MessageDigest: java.security.MessageDigest getInstance(java.lang.String)>
<java.security.MessageDigest: void <init>(java.lang.String)>
<java.security.MessageDigest: void update(byte)>
<java.security.MessageDigest: void update(byte[])>
<java.security.MessageDigest: void update(byte[],int,int)>
<java.security.MessageDigestSpi: void <init>()>
<java.security.Permission: java.lang.String getName()>
<java.security.Permission: void <init>(java.lang.String)>
<java.security.PermissionCollection: boolean isReadOnly()>
<java.security.PermissionCollection: void <init>()>
<java.security.PermissionCollection: void setReadOnly()>
<java.security.Permissions: java.security.PermissionCollection getPermissionCollection(java.security.Permission,boolean)>
<java.security.Permissions: void <clinit>()>
<java.security.Permissions: void <init>()>
<java.security.Permissions: void add(java.security.Permission)>
<java.security.Policy$PolicyInfo: void <init>(java.security.Policy,boolean)>
<java.security.Policy$UnsupportedEmptyCollection: void <init>()>
<java.security.Policy: void <clinit>()>
<java.security.PrivilegedActionException: java.lang.Exception getException()>
<java.security.PrivilegedActionException: void <init>(java.lang.Exception)>
<java.security.ProtectionDomain$2: void <init>()>
<java.security.ProtectionDomain$Key: void <init>(java.security.ProtectionDomain)>
<java.security.ProtectionDomain: java.security.CodeSource getCodeSource()>
<java.security.ProtectionDomain: void <clinit>()>
<java.security.ProtectionDomain: void <init>(java.security.CodeSource,java.security.PermissionCollection)>
<java.security.ProtectionDomain: void <init>(java.security.CodeSource,java.security.PermissionCollection,java.lang.ClassLoader,java.security.Principal[])>
<java.security.Provider$EngineDescription: void <init>(java.lang.String,boolean,java.lang.String)>
<java.security.Provider$Service: boolean access$000(java.security.Provider$Service)>
<java.security.Provider$Service: boolean isValid()>
<java.security.Provider$Service: java.lang.Class getImplClass()>
<java.security.Provider$Service: java.lang.Object newInstance(java.lang.Object)>
<java.security.Provider$Service: java.lang.String access$302(java.security.Provider$Service,java.lang.String)>
<java.security.Provider$Service: java.lang.String access$402(java.security.Provider$Service,java.lang.String)>
<java.security.Provider$Service: java.lang.String access$602(java.security.Provider$Service,java.lang.String)>
<java.security.Provider$Service: java.lang.String getAlgorithm()>
<java.security.Provider$Service: java.lang.String getType()>
<java.security.Provider$Service: java.security.Provider getProvider()>
<java.security.Provider$Service: void <clinit>()>
<java.security.Provider$Service: void <init>(java.security.Provider)>
<java.security.Provider$Service: void <init>(java.security.Provider,java.security.Provider$1)>
<java.security.Provider$Service: void access$500(java.security.Provider$Service,java.lang.String)>
<java.security.Provider$Service: void addAlias(java.lang.String)>
<java.security.Provider$Service: void addAttribute(java.lang.String,java.lang.String)>
<java.security.Provider$ServiceKey: boolean equals(java.lang.Object)>
<java.security.Provider$ServiceKey: boolean matches(java.lang.String,java.lang.String)>
<java.security.Provider$ServiceKey: int hashCode()>
<java.security.Provider$ServiceKey: void <init>(java.lang.String,java.lang.String,boolean)>
<java.security.Provider$ServiceKey: void <init>(java.lang.String,java.lang.String,boolean,java.security.Provider$1)>
<java.security.Provider$UString: int hashCode()>
<java.security.Provider$UString: void <init>(java.lang.String)>
<java.security.Provider: java.lang.Object implPut(java.lang.Object,java.lang.Object)>
<java.security.Provider: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.security.Provider: java.lang.String getEngineName(java.lang.String)>
<java.security.Provider: java.lang.String[] getTypeAndAlgorithm(java.lang.String)>
<java.security.Provider: java.security.Provider$Service getService(java.lang.String,java.lang.String)>
<java.security.Provider: java.util.Map access$1000()>
<java.security.Provider: java.util.Set getServices()>
<java.security.Provider: void <clinit>()>
<java.security.Provider: void <init>(java.lang.String,double,java.lang.String)>
<java.security.Provider: void addEngine(java.lang.String,boolean,java.lang.String)>
<java.security.Provider: void check(java.lang.String)>
<java.security.Provider: void checkInitialized()>
<java.security.Provider: void ensureLegacyParsed()>
<java.security.Provider: void parseLegacyPut(java.lang.String,java.lang.String)>
<java.security.Provider: void putId()>
<java.security.Provider: void removeInvalidServices(java.util.Map)>
<java.security.SecureClassLoader: java.lang.Class defineClass(java.lang.String,byte[],int,int,java.security.CodeSource)>
<java.security.SecureClassLoader: java.security.PermissionCollection getPermissions(java.security.CodeSource)>
<java.security.SecureClassLoader: java.security.ProtectionDomain getProtectionDomain(java.security.CodeSource)>
<java.security.SecureClassLoader: void check()>
<java.security.SecureRandom: int next(int)>
<java.security.SecureRandom: java.lang.String getPrngAlgorithm()>
<java.security.SecureRandom: java.security.Provider getProvider()>
<java.security.SecureRandom: java.security.SecureRandom getInstance(java.lang.String)>
<java.security.SecureRandom: java.security.SecureRandomSpi getSecureRandomSpi()>
<java.security.SecureRandom: void <clinit>()>
<java.security.SecureRandom: void <init>()>
<java.security.SecureRandom: void <init>(java.security.SecureRandomSpi,java.security.Provider,java.lang.String)>
<java.security.SecureRandom: void getDefaultPRNG(boolean,byte[])>
<java.security.SecureRandom: void nextBytes(byte[])>
<java.security.SecureRandom: void setSeed(long)>
<java.security.SecureRandomSpi: void <init>()>
<java.security.Security$1: java.lang.Object run()>
<java.security.Security$1: void <init>()>
<java.security.Security: java.io.File securityPropFile(java.lang.String)>
<java.security.Security: java.lang.Class getSpiClass(java.lang.String)>
<java.security.Security: java.lang.Object[] getImpl(java.lang.String,java.lang.String,java.lang.String)>
<java.security.Security: java.lang.String getProperty(java.lang.String)>
<java.security.Security: void <clinit>()>
<java.security.Security: void access$000()>
<java.security.Security: void initialize()>
<java.security.Security: void initializeStatic()>
<java.text.AttributedCharacterIterator$Attribute: boolean equals(java.lang.Object)>
<java.text.AttributedCharacterIterator$Attribute: void <clinit>()>
<java.text.AttributedCharacterIterator$Attribute: void <init>(java.lang.String)>
<java.text.DateFormat$Field: void <clinit>()>
<java.text.DateFormat$Field: void <init>(java.lang.String,int)>
<java.text.DateFormat: java.lang.String format(java.util.Date)>
<java.text.DateFormat: void <init>()>
<java.text.DateFormatSymbols: java.lang.String[] toOneBasedArray(java.lang.String[])>
<java.text.DateFormatSymbols: java.text.DateFormatSymbols getCachedInstance(java.util.Locale)>
<java.text.DateFormatSymbols: java.text.DateFormatSymbols getInstanceRef(java.util.Locale)>
<java.text.DateFormatSymbols: java.text.DateFormatSymbols getProviderInstance(java.util.Locale)>
<java.text.DateFormatSymbols: void <clinit>()>
<java.text.DateFormatSymbols: void <init>(java.util.Locale)>
<java.text.DateFormatSymbols: void initializeData(java.util.Locale)>
<java.text.DecimalFormat: java.lang.Object clone()>
<java.text.DecimalFormat: java.lang.String expandAffix(java.lang.String,java.lang.StringBuffer)>
<java.text.DecimalFormat: java.lang.StringBuffer format(long,java.lang.StringBuffer,java.text.FieldPosition)>
<java.text.DecimalFormat: java.lang.StringBuffer format(long,java.lang.StringBuffer,java.text.Format$FieldDelegate)>
<java.text.DecimalFormat: java.lang.StringBuffer subformat(java.lang.StringBuffer,java.text.Format$FieldDelegate,boolean,boolean,int,int,int,int)>
<java.text.DecimalFormat: java.text.DecimalFormatSymbols getDecimalFormatSymbols()>
<java.text.DecimalFormat: java.text.FieldPosition[] expandAffix(java.lang.String)>
<java.text.DecimalFormat: java.text.FieldPosition[] getPositivePrefixFieldPositions()>
<java.text.DecimalFormat: java.text.FieldPosition[] getPositiveSuffixFieldPositions()>
<java.text.DecimalFormat: void <clinit>()>
<java.text.DecimalFormat: void <init>()>
<java.text.DecimalFormat: void <init>(java.lang.String,java.text.DecimalFormatSymbols)>
<java.text.DecimalFormat: void append(java.lang.StringBuffer,java.lang.String,java.text.Format$FieldDelegate,java.text.FieldPosition[],java.text.Format$Field)>
<java.text.DecimalFormat: void applyPattern(java.lang.String,boolean)>
<java.text.DecimalFormat: void expandAffixes()>
<java.text.DecimalFormat: void setDecimalSeparatorAlwaysShown(boolean)>
<java.text.DecimalFormat: void setMaximumFractionDigits(int)>
<java.text.DecimalFormat: void setMaximumIntegerDigits(int)>
<java.text.DecimalFormat: void setMinimumFractionDigits(int)>
<java.text.DecimalFormat: void setMinimumIntegerDigits(int)>
<java.text.DecimalFormatSymbols: char getDecimalSeparator()>
<java.text.DecimalFormatSymbols: char getGroupingSeparator()>
<java.text.DecimalFormatSymbols: char getMinusSign()>
<java.text.DecimalFormatSymbols: char getZeroDigit()>
<java.text.DecimalFormatSymbols: java.lang.Object clone()>
<java.text.DecimalFormatSymbols: java.text.DecimalFormatSymbols getInstance(java.util.Locale)>
<java.text.DecimalFormatSymbols: void <clinit>()>
<java.text.DecimalFormatSymbols: void <init>(java.util.Locale)>
<java.text.DecimalFormatSymbols: void initialize(java.util.Locale)>
<java.text.DigitList: boolean isZero()>
<java.text.DigitList: java.lang.Object clone()>
<java.text.DigitList: void <clinit>()>
<java.text.DigitList: void <init>()>
<java.text.DigitList: void set(boolean,long,int)>
<java.text.DontCareFieldPosition$1: void <init>(java.text.DontCareFieldPosition)>
<java.text.DontCareFieldPosition$1: void formatted(int,java.text.Format$Field,java.lang.Object,int,int,java.lang.StringBuffer)>
<java.text.DontCareFieldPosition: java.text.Format$FieldDelegate getFieldDelegate()>
<java.text.DontCareFieldPosition: void <clinit>()>
<java.text.DontCareFieldPosition: void <init>()>
<java.text.FieldPosition: java.text.Format$Field getFieldAttribute()>
<java.text.FieldPosition: void <init>(int)>
<java.text.FieldPosition: void setBeginIndex(int)>
<java.text.FieldPosition: void setEndIndex(int)>
<java.text.Format$Field: void <init>(java.lang.String)>
<java.text.Format: java.lang.Object clone()>
<java.text.Format: java.lang.String format(java.lang.Object)>
<java.text.Format: void <init>()>
<java.text.MessageFormat$Field: void <clinit>()>
<java.text.MessageFormat$Field: void <init>(java.lang.String)>
<java.text.MessageFormat: int findKeyword(java.lang.String,java.lang.String[])>
<java.text.MessageFormat: java.lang.String format(java.lang.String,java.lang.Object[])>
<java.text.MessageFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)>
<java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
<java.text.MessageFormat: void <clinit>()>
<java.text.MessageFormat: void <init>(java.lang.String)>
<java.text.MessageFormat: void applyPattern(java.lang.String)>
<java.text.MessageFormat: void makeFormat(int,int,java.lang.StringBuffer[])>
<java.text.NumberFormat$Field: void <clinit>()>
<java.text.NumberFormat$Field: void <init>(java.lang.String)>
<java.text.NumberFormat: boolean isGroupingUsed()>
<java.text.NumberFormat: int getMaximumFractionDigits()>
<java.text.NumberFormat: int getMaximumIntegerDigits()>
<java.text.NumberFormat: int getMinimumFractionDigits()>
<java.text.NumberFormat: int getMinimumIntegerDigits()>
<java.text.NumberFormat: java.lang.Object clone()>
<java.text.NumberFormat: java.text.NumberFormat getInstance(java.util.Locale,int)>
<java.text.NumberFormat: java.text.NumberFormat getIntegerInstance(java.util.Locale)>
<java.text.NumberFormat: void <clinit>()>
<java.text.NumberFormat: void <init>()>
<java.text.NumberFormat: void setGroupingUsed(boolean)>
<java.text.NumberFormat: void setMaximumFractionDigits(int)>
<java.text.NumberFormat: void setMaximumIntegerDigits(int)>
<java.text.NumberFormat: void setMinimumFractionDigits(int)>
<java.text.NumberFormat: void setMinimumIntegerDigits(int)>
<java.text.NumberFormat: void setParseIntegerOnly(boolean)>
<java.text.SimpleDateFormat: boolean isGregorianCalendar()>
<java.text.SimpleDateFormat: boolean useDateFormatSymbols()>
<java.text.SimpleDateFormat: char[] compile(java.lang.String)>
<java.text.SimpleDateFormat: java.lang.String getCalendarName()>
<java.text.SimpleDateFormat: java.lang.StringBuffer format(java.util.Date,java.lang.StringBuffer,java.text.FieldPosition)>
<java.text.SimpleDateFormat: java.lang.StringBuffer format(java.util.Date,java.lang.StringBuffer,java.text.Format$FieldDelegate)>
<java.text.SimpleDateFormat: void <clinit>()>
<java.text.SimpleDateFormat: void <init>(java.lang.String)>
<java.text.SimpleDateFormat: void <init>(java.lang.String,java.util.Locale)>
<java.text.SimpleDateFormat: void encode(int,int,java.lang.StringBuilder)>
<java.text.SimpleDateFormat: void initialize(java.util.Locale)>
<java.text.SimpleDateFormat: void initializeCalendar(java.util.Locale)>
<java.text.SimpleDateFormat: void initializeDefaultCentury()>
<java.text.SimpleDateFormat: void parseAmbiguousDatesAsAfter(java.util.Date)>
<java.text.SimpleDateFormat: void subFormat(int,int,java.text.Format$FieldDelegate,java.lang.StringBuffer,boolean)>
<java.text.SimpleDateFormat: void zeroPaddingNumber(int,int,int,java.lang.StringBuffer)>
<java.util.AbstractCollection: boolean addAll(java.util.Collection)>
<java.util.AbstractCollection: boolean containsAll(java.util.Collection)>
<java.util.AbstractCollection: boolean isEmpty()>
<java.util.AbstractCollection: java.lang.Object[] toArray()>
<java.util.AbstractCollection: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.AbstractCollection: void <init>()>
<java.util.AbstractList$Itr: boolean hasNext()>
<java.util.AbstractList$Itr: java.lang.Object next()>
<java.util.AbstractList$Itr: void <init>(java.util.AbstractList)>
<java.util.AbstractList$Itr: void <init>(java.util.AbstractList,java.util.AbstractList$1)>
<java.util.AbstractList$Itr: void checkForComodification()>
<java.util.AbstractList$Itr: void remove()>
<java.util.AbstractList: java.util.Iterator iterator()>
<java.util.AbstractList: java.util.ListIterator listIterator()>
<java.util.AbstractList: void <init>()>
<java.util.AbstractMap: boolean equals(java.lang.Object)>
<java.util.AbstractMap: java.lang.Object clone()>
<java.util.AbstractMap: void <init>()>
<java.util.AbstractSequentialList: java.util.Iterator iterator()>
<java.util.AbstractSequentialList: void <init>()>
<java.util.AbstractSet: boolean equals(java.lang.Object)>
<java.util.AbstractSet: void <init>()>
<java.util.ArrayList: boolean add(java.lang.Object)>
<java.util.ArrayList: boolean addAll(java.util.Collection)>
<java.util.ArrayList: boolean contains(java.lang.Object)>
<java.util.ArrayList: boolean isEmpty()>
<java.util.ArrayList: boolean remove(java.lang.Object)>
<java.util.ArrayList: int indexOf(java.lang.Object)>
<java.util.ArrayList: int size()>
<java.util.ArrayList: java.lang.Object get(int)>
<java.util.ArrayList: java.lang.Object remove(int)>
<java.util.ArrayList: java.lang.Object set(int,java.lang.Object)>
<java.util.ArrayList: java.lang.Object[] toArray()>
<java.util.ArrayList: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.ArrayList: void <init>()>
<java.util.ArrayList: void <init>(int)>
<java.util.ArrayList: void <init>(java.util.Collection)>
<java.util.ArrayList: void RangeCheck(int)>
<java.util.ArrayList: void add(int,java.lang.Object)>
<java.util.ArrayList: void clear()>
<java.util.ArrayList: void ensureCapacity(int)>
<java.util.ArrayList: void fastRemove(int)>
<java.util.ArrayList: void trimToSize()>
<java.util.Arrays$ArrayList: int size()>
<java.util.Arrays$ArrayList: java.lang.Object get(int)>
<java.util.Arrays$ArrayList: java.lang.Object[] toArray()>
<java.util.Arrays$ArrayList: void <init>(java.lang.Object[])>
<java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
<java.util.Arrays: byte[] copyOf(byte[],int)>
<java.util.Arrays: char[] copyOf(char[],int)>
<java.util.Arrays: char[] copyOfRange(char[],int,int)>
<java.util.Arrays: int binarySearch(java.lang.Object[],java.lang.Object)>
<java.util.Arrays: int binarySearch(java.lang.Object[],java.lang.Object,java.util.Comparator)>
<java.util.Arrays: int binarySearch0(java.lang.Object[],int,int,java.lang.Object)>
<java.util.Arrays: int binarySearch0(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)>
<java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int)>
<java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int,java.lang.Class)>
<java.util.Arrays: java.util.List asList(java.lang.Object[])>
<java.util.Arrays: void fill(byte[],int,int,byte)>
<java.util.Arrays: void fill(java.lang.Object[],int,int,java.lang.Object)>
<java.util.Arrays: void fill(long[],int,int,long)>
<java.util.Arrays: void mergeSort(java.lang.Object[],java.lang.Object[],int,int,int)>
<java.util.Arrays: void rangeCheck(int,int,int)>
<java.util.Arrays: void sort(java.lang.Object[])>
<java.util.Arrays: void swap(java.lang.Object[],int,int)>
<java.util.BitSet: boolean get(int)>
<java.util.BitSet: int wordIndex(int)>
<java.util.BitSet: void <init>(int)>
<java.util.BitSet: void checkInvariants()>
<java.util.BitSet: void ensureCapacity(int)>
<java.util.BitSet: void expandTo(int)>
<java.util.BitSet: void initWords(int)>
<java.util.BitSet: void set(int)>
<java.util.Calendar: boolean isFieldSet(int,int)>
<java.util.Calendar: boolean isLenient()>
<java.util.Calendar: boolean isPartiallyNormalized()>
<java.util.Calendar: boolean isSet(int)>
<java.util.Calendar: int aggregateStamp(int,int)>
<java.util.Calendar: int get(int)>
<java.util.Calendar: int getFirstDayOfWeek()>
<java.util.Calendar: int getMinimalDaysInFirstWeek()>
<java.util.Calendar: int getSetStateFields()>
<java.util.Calendar: int internalGet(int)>
<java.util.Calendar: int selectFields()>
<java.util.Calendar: java.util.Calendar createCalendar(java.util.TimeZone,java.util.Locale)>
<java.util.Calendar: java.util.Calendar getInstance(java.util.TimeZone,java.util.Locale)>
<java.util.Calendar: java.util.Date getTime()>
<java.util.Calendar: java.util.TimeZone getZone()>
<java.util.Calendar: long getTimeInMillis()>
<java.util.Calendar: void <clinit>()>
<java.util.Calendar: void <init>(java.util.TimeZone,java.util.Locale)>
<java.util.Calendar: void complete()>
<java.util.Calendar: void internalSet(int,int)>
<java.util.Calendar: void set(int,int)>
<java.util.Calendar: void setFieldsComputed(int)>
<java.util.Calendar: void setFieldsNormalized(int)>
<java.util.Calendar: void setTime(java.util.Date)>
<java.util.Calendar: void setTimeInMillis(long)>
<java.util.Calendar: void setWeekCountData(java.util.Locale)>
<java.util.Calendar: void updateTime()>
<java.util.Collections$EmptyList: int size()>
<java.util.Collections$EmptyMap: boolean isEmpty()>
<java.util.Collections$EmptySet$1: boolean hasNext()>
<java.util.Collections$EmptySet$1: void <init>(java.util.Collections$EmptySet)>
<java.util.Collections$EmptySet: boolean contains(java.lang.Object)>
<java.util.Collections$EmptySet: int size()>
<java.util.Collections$EmptySet: java.util.Iterator iterator()>
<java.util.Collections$SingletonMap: void <init>(java.lang.Object,java.lang.Object)>
<java.util.Collections$SynchronizedCollection: boolean add(java.lang.Object)>
<java.util.Collections$SynchronizedCollection: boolean remove(java.lang.Object)>
<java.util.Collections$SynchronizedCollection: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.Collections$SynchronizedCollection: java.util.Iterator iterator()>
<java.util.Collections$SynchronizedCollection: void <init>(java.util.Collection)>
<java.util.Collections$SynchronizedCollection: void <init>(java.util.Collection,java.lang.Object)>
<java.util.Collections$SynchronizedMap: boolean isEmpty()>
<java.util.Collections$SynchronizedMap: int size()>
<java.util.Collections$SynchronizedMap: java.lang.Object get(java.lang.Object)>
<java.util.Collections$SynchronizedMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.Collections$SynchronizedMap: java.lang.Object remove(java.lang.Object)>
<java.util.Collections$SynchronizedMap: java.util.Set entrySet()>
<java.util.Collections$SynchronizedMap: java.util.Set keySet()>
<java.util.Collections$SynchronizedMap: void <init>(java.util.Map)>
<java.util.Collections$SynchronizedSet: void <init>(java.util.Set)>
<java.util.Collections$SynchronizedSet: void <init>(java.util.Set,java.lang.Object)>
<java.util.Collections$UnmodifiableCollection$1: boolean hasNext()>
<java.util.Collections$UnmodifiableCollection$1: java.lang.Object next()>
<java.util.Collections$UnmodifiableCollection$1: void <init>(java.util.Collections$UnmodifiableCollection)>
<java.util.Collections$UnmodifiableCollection: int size()>
<java.util.Collections$UnmodifiableCollection: java.util.Iterator iterator()>
<java.util.Collections$UnmodifiableCollection: void <init>(java.util.Collection)>
<java.util.Collections$UnmodifiableList: java.lang.Object get(int)>
<java.util.Collections$UnmodifiableList: void <init>(java.util.List)>
<java.util.Collections$UnmodifiableMap: void <init>(java.util.Map)>
<java.util.Collections$UnmodifiableRandomAccessList: void <init>(java.util.List)>
<java.util.Collections$UnmodifiableSet: void <init>(java.util.Set)>
<java.util.Collections: java.util.List emptyList()>
<java.util.Collections: java.util.List unmodifiableList(java.util.List)>
<java.util.Collections: java.util.Map emptyMap()>
<java.util.Collections: java.util.Map singletonMap(java.lang.Object,java.lang.Object)>
<java.util.Collections: java.util.Map synchronizedMap(java.util.Map)>
<java.util.Collections: java.util.Map unmodifiableMap(java.util.Map)>
<java.util.Collections: java.util.Set synchronizedSet(java.util.Set)>
<java.util.Collections: java.util.Set synchronizedSet(java.util.Set,java.lang.Object)>
<java.util.Collections: java.util.Set unmodifiableSet(java.util.Set)>
<java.util.Currency$1: java.lang.Object run()>
<java.util.Currency$1: void <init>()>
<java.util.Currency: int getMainTableEntry(char,char)>
<java.util.Currency: java.lang.String getCurrencyCode()>
<java.util.Currency: java.lang.String getSymbol(java.util.Locale)>
<java.util.Currency: java.util.Currency getInstance(java.lang.String,int)>
<java.util.Currency: java.util.Currency getInstance(java.util.Locale)>
<java.util.Currency: void <clinit>()>
<java.util.Currency: void <init>(java.lang.String,int)>
<java.util.CurrencyData: void <clinit>()>
<java.util.Date: java.lang.String toString()>
<java.util.Date: java.lang.StringBuilder convertToAbbr(java.lang.StringBuilder,java.lang.String)>
<java.util.Date: long getTime()>
<java.util.Date: long getTimeImpl()>
<java.util.Date: sun.util.calendar.BaseCalendar getCalendarSystem(long)>
<java.util.Date: sun.util.calendar.BaseCalendar$Date normalize()>
<java.util.Date: void <clinit>()>
<java.util.Date: void <init>()>
<java.util.Date: void <init>(long)>
<java.util.Dictionary: void <init>()>
<java.util.EventObject: java.lang.Object getSource()>
<java.util.EventObject: void <init>(java.lang.Object)>
<java.util.GregorianCalendar: boolean isLeapYear(int)>
<java.util.GregorianCalendar: int computeFields(int,int)>
<java.util.GregorianCalendar: int getWeekNumber(long,long)>
<java.util.GregorianCalendar: int internalGetEra()>
<java.util.GregorianCalendar: int monthLength(int)>
<java.util.GregorianCalendar: int monthLength(int,int)>
<java.util.GregorianCalendar: long getFixedDate(sun.util.calendar.BaseCalendar,int,int)>
<java.util.GregorianCalendar: void <clinit>()>
<java.util.GregorianCalendar: void <init>(java.util.TimeZone,java.util.Locale)>
<java.util.GregorianCalendar: void add(int,int)>
<java.util.GregorianCalendar: void computeFields()>
<java.util.GregorianCalendar: void computeTime()>
<java.util.GregorianCalendar: void pinDayOfMonth()>
<java.util.HashMap$Entry: java.lang.Object getKey()>
<java.util.HashMap$Entry: java.lang.Object getValue()>
<java.util.HashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.HashMap$Entry)>
<java.util.HashMap$Entry: void recordAccess(java.util.HashMap)>
<java.util.HashMap$Entry: void recordRemoval(java.util.HashMap)>
<java.util.HashMap$EntryIterator: java.lang.Object next()>
<java.util.HashMap$EntryIterator: java.util.Map$Entry next()>
<java.util.HashMap$EntryIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$EntryIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$EntrySet: int size()>
<java.util.HashMap$EntrySet: java.util.Iterator iterator()>
<java.util.HashMap$EntrySet: void <init>(java.util.HashMap)>
<java.util.HashMap$EntrySet: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$HashIterator: boolean hasNext()>
<java.util.HashMap$HashIterator: java.util.HashMap$Entry nextEntry()>
<java.util.HashMap$HashIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$HashIterator: void remove()>
<java.util.HashMap$KeyIterator: java.lang.Object next()>
<java.util.HashMap$KeyIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$KeyIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$KeySet: int size()>
<java.util.HashMap$KeySet: java.util.Iterator iterator()>
<java.util.HashMap$KeySet: void <init>(java.util.HashMap)>
<java.util.HashMap$KeySet: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$ValueIterator: java.lang.Object next()>
<java.util.HashMap$ValueIterator: void <init>(java.util.HashMap)>
<java.util.HashMap$ValueIterator: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap$Values: int size()>
<java.util.HashMap$Values: java.util.Iterator iterator()>
<java.util.HashMap$Values: void <init>(java.util.HashMap)>
<java.util.HashMap$Values: void <init>(java.util.HashMap,java.util.HashMap$1)>
<java.util.HashMap: boolean containsKey(java.lang.Object)>
<java.util.HashMap: boolean isEmpty()>
<java.util.HashMap: int hash(int)>
<java.util.HashMap: int indexFor(int,int)>
<java.util.HashMap: int size()>
<java.util.HashMap: java.lang.Object clone()>
<java.util.HashMap: java.lang.Object get(java.lang.Object)>
<java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.HashMap: java.lang.Object remove(java.lang.Object)>
<java.util.HashMap: java.util.Collection values()>
<java.util.HashMap: java.util.HashMap$Entry getEntry(java.lang.Object)>
<java.util.HashMap: java.util.HashMap$Entry removeEntryForKey(java.lang.Object)>
<java.util.HashMap: java.util.Iterator newEntryIterator()>
<java.util.HashMap: java.util.Iterator newKeyIterator()>
<java.util.HashMap: java.util.Iterator newValueIterator()>
<java.util.HashMap: java.util.Set entrySet()>
<java.util.HashMap: java.util.Set entrySet0()>
<java.util.HashMap: java.util.Set keySet()>
<java.util.HashMap: void <init>()>
<java.util.HashMap: void <init>(int)>
<java.util.HashMap: void <init>(int,float)>
<java.util.HashMap: void <init>(java.util.Map)>
<java.util.HashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.HashMap: void clear()>
<java.util.HashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.HashMap: void init()>
<java.util.HashMap: void putAllForCreate(java.util.Map)>
<java.util.HashMap: void putForCreate(java.lang.Object,java.lang.Object)>
<java.util.HashMap: void resize(int)>
<java.util.HashMap: void transfer(java.util.HashMap$Entry[])>
<java.util.HashSet: boolean add(java.lang.Object)>
<java.util.HashSet: boolean contains(java.lang.Object)>
<java.util.HashSet: boolean isEmpty()>
<java.util.HashSet: boolean remove(java.lang.Object)>
<java.util.HashSet: int size()>
<java.util.HashSet: java.lang.Object clone()>
<java.util.HashSet: java.util.Iterator iterator()>
<java.util.HashSet: void <init>()>
<java.util.HashSet: void <init>(int)>
<java.util.HashSet: void <init>(int,float,boolean)>
<java.util.HashSet: void <init>(java.util.Collection)>
<java.util.HashSet: void clear()>
<java.util.Hashtable$EmptyEnumerator: boolean hasMoreElements()>
<java.util.Hashtable$EmptyIterator: boolean hasNext()>
<java.util.Hashtable$Entry: java.lang.Object clone()>
<java.util.Hashtable$Entry: java.lang.Object getKey()>
<java.util.Hashtable$Entry: java.lang.Object getValue()>
<java.util.Hashtable$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.Hashtable$Entry)>
<java.util.Hashtable$EntrySet: java.util.Iterator iterator()>
<java.util.Hashtable$EntrySet: void <init>(java.util.Hashtable)>
<java.util.Hashtable$EntrySet: void <init>(java.util.Hashtable,java.util.Hashtable$1)>
<java.util.Hashtable$Enumerator: boolean hasMoreElements()>
<java.util.Hashtable$Enumerator: boolean hasNext()>
<java.util.Hashtable$Enumerator: java.lang.Object next()>
<java.util.Hashtable$Enumerator: java.lang.Object nextElement()>
<java.util.Hashtable$Enumerator: void <init>(java.util.Hashtable,int,boolean)>
<java.util.Hashtable$KeySet: java.util.Iterator iterator()>
<java.util.Hashtable$KeySet: void <init>(java.util.Hashtable)>
<java.util.Hashtable$KeySet: void <init>(java.util.Hashtable,java.util.Hashtable$1)>
<java.util.Hashtable: boolean containsKey(java.lang.Object)>
<java.util.Hashtable: boolean isEmpty()>
<java.util.Hashtable: int access$500(java.util.Hashtable)>
<java.util.Hashtable: int size()>
<java.util.Hashtable: java.lang.Object clone()>
<java.util.Hashtable: java.lang.Object get(java.lang.Object)>
<java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
<java.util.Hashtable: java.util.Enumeration getEnumeration(int)>
<java.util.Hashtable: java.util.Enumeration keys()>
<java.util.Hashtable: java.util.Hashtable$Entry[] access$400(java.util.Hashtable)>
<java.util.Hashtable: java.util.Iterator access$100(java.util.Hashtable,int)>
<java.util.Hashtable: java.util.Iterator getIterator(int)>
<java.util.Hashtable: java.util.Set entrySet()>
<java.util.Hashtable: java.util.Set keySet()>
<java.util.Hashtable: void <init>()>
<java.util.Hashtable: void <init>(int)>
<java.util.Hashtable: void <init>(int,float)>
<java.util.Hashtable: void <init>(java.util.Map)>
<java.util.Hashtable: void clear()>
<java.util.Hashtable: void putAll(java.util.Map)>
<java.util.Hashtable: void rehash()>
<java.util.IdentityHashMap$IdentityHashMapIterator: boolean hasNext()>
<java.util.IdentityHashMap$IdentityHashMapIterator: int nextIndex()>
<java.util.IdentityHashMap$IdentityHashMapIterator: void <init>(java.util.IdentityHashMap)>
<java.util.IdentityHashMap$IdentityHashMapIterator: void <init>(java.util.IdentityHashMap,java.util.IdentityHashMap$1)>
<java.util.IdentityHashMap$KeyIterator: java.lang.Object next()>
<java.util.IdentityHashMap$KeyIterator: void <init>(java.util.IdentityHashMap)>
<java.util.IdentityHashMap$KeyIterator: void <init>(java.util.IdentityHashMap,java.util.IdentityHashMap$1)>
<java.util.IdentityHashMap$KeySet: java.util.Iterator iterator()>
<java.util.IdentityHashMap$KeySet: void <init>(java.util.IdentityHashMap)>
<java.util.IdentityHashMap$KeySet: void <init>(java.util.IdentityHashMap,java.util.IdentityHashMap$1)>
<java.util.IdentityHashMap: int access$000(java.util.IdentityHashMap)>
<java.util.IdentityHashMap: int access$200(java.util.IdentityHashMap)>
<java.util.IdentityHashMap: java.lang.Object access$600(java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object unmaskNull(java.lang.Object)>
<java.util.IdentityHashMap: java.lang.Object[] access$100(java.util.IdentityHashMap)>
<java.util.IdentityHashMap: java.util.Set keySet()>
<java.util.LinkedHashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,java.util.HashMap$Entry)>
<java.util.LinkedHashMap$Entry: void access$600(java.util.LinkedHashMap$Entry,java.util.LinkedHashMap$Entry)>
<java.util.LinkedHashMap$Entry: void addBefore(java.util.LinkedHashMap$Entry)>
<java.util.LinkedHashMap$Entry: void recordAccess(java.util.HashMap)>
<java.util.LinkedHashMap$EntryIterator: java.lang.Object next()>
<java.util.LinkedHashMap$EntryIterator: java.util.Map$Entry next()>
<java.util.LinkedHashMap$EntryIterator: void <init>(java.util.LinkedHashMap)>
<java.util.LinkedHashMap$EntryIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
<java.util.LinkedHashMap$KeyIterator: java.lang.Object next()>
<java.util.LinkedHashMap$KeyIterator: void <init>(java.util.LinkedHashMap)>
<java.util.LinkedHashMap$KeyIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
<java.util.LinkedHashMap$LinkedHashIterator: boolean hasNext()>
<java.util.LinkedHashMap$LinkedHashIterator: java.util.LinkedHashMap$Entry nextEntry()>
<java.util.LinkedHashMap$LinkedHashIterator: void <init>(java.util.LinkedHashMap)>
<java.util.LinkedHashMap$LinkedHashIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
<java.util.LinkedHashMap$ValueIterator: java.lang.Object next()>
<java.util.LinkedHashMap$ValueIterator: void <init>(java.util.LinkedHashMap)>
<java.util.LinkedHashMap$ValueIterator: void <init>(java.util.LinkedHashMap,java.util.LinkedHashMap$1)>
<java.util.LinkedHashMap: boolean access$000(java.util.LinkedHashMap)>
<java.util.LinkedHashMap: boolean removeEldestEntry(java.util.Map$Entry)>
<java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
<java.util.LinkedHashMap: java.util.Iterator newEntryIterator()>
<java.util.LinkedHashMap: java.util.Iterator newKeyIterator()>
<java.util.LinkedHashMap: java.util.Iterator newValueIterator()>
<java.util.LinkedHashMap: java.util.LinkedHashMap$Entry access$100(java.util.LinkedHashMap)>
<java.util.LinkedHashMap: void <init>()>
<java.util.LinkedHashMap: void <init>(int)>
<java.util.LinkedHashMap: void <init>(int,float)>
<java.util.LinkedHashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.LinkedHashMap: void clear()>
<java.util.LinkedHashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)>
<java.util.LinkedHashMap: void init()>
<java.util.LinkedHashMap: void transfer(java.util.HashMap$Entry[])>
<java.util.LinkedHashSet: void <init>()>
<java.util.LinkedList$Entry: void <init>(java.lang.Object,java.util.LinkedList$Entry,java.util.LinkedList$Entry)>
<java.util.LinkedList$ListItr: boolean hasNext()>
<java.util.LinkedList$ListItr: void <init>(java.util.LinkedList,int)>
<java.util.LinkedList: boolean add(java.lang.Object)>
<java.util.LinkedList: boolean contains(java.lang.Object)>
<java.util.LinkedList: boolean remove(java.lang.Object)>
<java.util.LinkedList: int access$100(java.util.LinkedList)>
<java.util.LinkedList: int indexOf(java.lang.Object)>
<java.util.LinkedList: int size()>
<java.util.LinkedList: java.lang.Object remove(java.util.LinkedList$Entry)>
<java.util.LinkedList: java.lang.Object removeFirst()>
<java.util.LinkedList: java.lang.Object[] toArray()>
<java.util.LinkedList: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.LinkedList: java.util.LinkedList$Entry access$000(java.util.LinkedList)>
<java.util.LinkedList: java.util.LinkedList$Entry addBefore(java.lang.Object,java.util.LinkedList$Entry)>
<java.util.LinkedList: java.util.ListIterator listIterator(int)>
<java.util.LinkedList: void <init>()>
<java.util.ListResourceBundle: java.lang.Object handleGetObject(java.lang.String)>
<java.util.ListResourceBundle: void <init>()>
<java.util.ListResourceBundle: void loadLookup()>
<java.util.Locale: boolean equals(java.lang.Object)>
<java.util.Locale: int hashCode()>
<java.util.Locale: java.lang.String getCountry()>
<java.util.Locale: java.lang.String getLanguage()>
<java.util.Locale: java.lang.String getVariant()>
<java.util.Locale: java.lang.String toString()>
<java.util.Locale: java.util.Locale getDefault()>
<java.util.Locale: java.util.Locale getInstance(java.lang.String,java.lang.String,java.lang.String)>
<java.util.MissingResourceException: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<java.util.Properties$LineReader: int readLine()>
<java.util.Properties$LineReader: void <init>(java.util.Properties,java.io.InputStream)>
<java.util.Properties: java.lang.Object setProperty(java.lang.String,java.lang.String)>
<java.util.Properties: java.lang.String getProperty(java.lang.String)>
<java.util.Properties: java.lang.String getProperty(java.lang.String,java.lang.String)>
<java.util.Properties: java.lang.String loadConvert(char[],int,int,char[])>
<java.util.Properties: java.lang.String saveConvert(java.lang.String,boolean,boolean)>
<java.util.Properties: java.util.Enumeration propertyNames()>
<java.util.Properties: void <init>()>
<java.util.Properties: void <init>(java.util.Properties)>
<java.util.Properties: void enumerate(java.util.Hashtable)>
<java.util.Properties: void load(java.io.InputStream)>
<java.util.Properties: void load0(java.util.Properties$LineReader)>
<java.util.Properties: void store(java.io.OutputStream,java.lang.String)>
<java.util.Properties: void store0(java.io.BufferedWriter,java.lang.String,boolean)>
<java.util.Properties: void writeComments(java.io.BufferedWriter,java.lang.String)>
<java.util.PropertyResourceBundle: java.lang.Object handleGetObject(java.lang.String)>
<java.util.PropertyResourceBundle: java.util.Enumeration getKeys()>
<java.util.PropertyResourceBundle: void <init>(java.io.InputStream)>
<java.util.Random: long nextLong()>
<java.util.Random: void <clinit>()>
<java.util.Random: void <init>(long)>
<java.util.ResourceBundle$1: void <init>()>
<java.util.ResourceBundle$BundleReference: void <init>(java.util.ResourceBundle,java.lang.ref.ReferenceQueue,java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$CacheKey: boolean equals(java.lang.Object)>
<java.util.ResourceBundle$CacheKey: int hashCode()>
<java.util.ResourceBundle$CacheKey: java.lang.ClassLoader getLoader()>
<java.util.ResourceBundle$CacheKey: java.lang.Object clone()>
<java.util.ResourceBundle$CacheKey: java.lang.String getName()>
<java.util.ResourceBundle$CacheKey: java.lang.Throwable access$400(java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$CacheKey: java.lang.Throwable getCause()>
<java.util.ResourceBundle$CacheKey: java.util.Locale getLocale()>
<java.util.ResourceBundle$CacheKey: java.util.ResourceBundle$CacheKey setLocale(java.util.Locale)>
<java.util.ResourceBundle$CacheKey: long access$600(java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$CacheKey: long access$602(java.util.ResourceBundle$CacheKey,long)>
<java.util.ResourceBundle$CacheKey: void <init>(java.lang.String,java.util.Locale,java.lang.ClassLoader)>
<java.util.ResourceBundle$CacheKey: void calculateHashCode()>
<java.util.ResourceBundle$CacheKey: void setFormat(java.lang.String)>
<java.util.ResourceBundle$Control$1: java.io.InputStream run()>
<java.util.ResourceBundle$Control$1: java.lang.Object run()>
<java.util.ResourceBundle$Control$1: void <init>(java.util.ResourceBundle$Control,boolean,java.lang.ClassLoader,java.lang.String)>
<java.util.ResourceBundle$Control: java.lang.String toBundleName(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: java.lang.String toResourceName(java.lang.String,java.lang.String)>
<java.util.ResourceBundle$Control: java.util.List getCandidateLocales(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: java.util.List getFormats(java.lang.String)>
<java.util.ResourceBundle$Control: java.util.Locale getFallbackLocale(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: java.util.ResourceBundle newBundle(java.lang.String,java.util.Locale,java.lang.String,java.lang.ClassLoader,boolean)>
<java.util.ResourceBundle$Control: java.util.ResourceBundle$Control access$300()>
<java.util.ResourceBundle$Control: long getTimeToLive(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle$Control: void <clinit>()>
<java.util.ResourceBundle$Control: void <init>()>
<java.util.ResourceBundle$LoaderReference: void <init>(java.lang.ClassLoader,java.lang.ref.ReferenceQueue,java.util.ResourceBundle$CacheKey)>
<java.util.ResourceBundle$RBClassLoader$1: java.lang.Object run()>
<java.util.ResourceBundle$RBClassLoader$1: java.util.ResourceBundle$RBClassLoader run()>
<java.util.ResourceBundle$RBClassLoader$1: void <init>()>
<java.util.ResourceBundle$RBClassLoader: java.lang.Class loadClass(java.lang.String)>
<java.util.ResourceBundle$RBClassLoader: java.util.ResourceBundle$RBClassLoader access$000()>
<java.util.ResourceBundle$RBClassLoader: void <clinit>()>
<java.util.ResourceBundle$RBClassLoader: void <init>()>
<java.util.ResourceBundle$RBClassLoader: void <init>(java.util.ResourceBundle$1)>
<java.util.ResourceBundle: boolean checkList(java.util.List)>
<java.util.ResourceBundle: boolean hasValidParentChain(java.util.ResourceBundle)>
<java.util.ResourceBundle: boolean isValidBundle(java.util.ResourceBundle)>
<java.util.ResourceBundle: java.lang.ClassLoader getLoader()>
<java.util.ResourceBundle: java.lang.Object getObject(java.lang.String)>
<java.util.ResourceBundle: java.lang.String getString(java.lang.String)>
<java.util.ResourceBundle: java.lang.String[] getStringArray(java.lang.String)>
<java.util.ResourceBundle: java.lang.ref.ReferenceQueue access$200()>
<java.util.ResourceBundle: java.util.ResourceBundle findBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.List,int,java.util.ResourceBundle$Control,java.util.ResourceBundle)>
<java.util.ResourceBundle: java.util.ResourceBundle findBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: java.util.ResourceBundle getBundle(java.lang.String)>
<java.util.ResourceBundle: java.util.ResourceBundle getBundle(java.lang.String,java.util.Locale)>
<java.util.ResourceBundle: java.util.ResourceBundle getBundle(java.lang.String,java.util.Locale,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: java.util.ResourceBundle getBundleImpl(java.lang.String,java.util.Locale,java.lang.ClassLoader,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: java.util.ResourceBundle loadBundle(java.util.ResourceBundle$CacheKey,java.util.List,java.util.ResourceBundle$Control,boolean)>
<java.util.ResourceBundle: java.util.ResourceBundle putBundleInCache(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: void <clinit>()>
<java.util.ResourceBundle: void <init>()>
<java.util.ResourceBundle: void setExpirationTime(java.util.ResourceBundle$CacheKey,java.util.ResourceBundle$Control)>
<java.util.ResourceBundle: void setParent(java.util.ResourceBundle)>
<java.util.ServiceLoader$1: boolean hasNext()>
<java.util.ServiceLoader$1: void <init>(java.util.ServiceLoader)>
<java.util.ServiceLoader$LazyIterator: boolean hasNext()>
<java.util.ServiceLoader$LazyIterator: void <init>(java.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader)>
<java.util.ServiceLoader$LazyIterator: void <init>(java.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader,java.util.ServiceLoader$1)>
<java.util.ServiceLoader: java.util.Iterator iterator()>
<java.util.ServiceLoader: java.util.LinkedHashMap access$400(java.util.ServiceLoader)>
<java.util.ServiceLoader: java.util.ServiceLoader load(java.lang.Class,java.lang.ClassLoader)>
<java.util.ServiceLoader: java.util.ServiceLoader loadInstalled(java.lang.Class)>
<java.util.ServiceLoader: java.util.ServiceLoader$LazyIterator access$500(java.util.ServiceLoader)>
<java.util.ServiceLoader: void <init>(java.lang.Class,java.lang.ClassLoader)>
<java.util.ServiceLoader: void reload()>
<java.util.Stack: boolean empty()>
<java.util.Stack: java.lang.Object peek()>
<java.util.Stack: java.lang.Object pop()>
<java.util.Stack: java.lang.Object push(java.lang.Object)>
<java.util.Stack: void <init>()>
<java.util.StringTokenizer: boolean hasMoreTokens()>
<java.util.StringTokenizer: int countTokens()>
<java.util.StringTokenizer: int scanToken(int)>
<java.util.StringTokenizer: int skipDelimiters(int)>
<java.util.StringTokenizer: java.lang.String nextToken()>
<java.util.StringTokenizer: void <init>(java.lang.String,java.lang.String)>
<java.util.StringTokenizer: void <init>(java.lang.String,java.lang.String,boolean)>
<java.util.StringTokenizer: void setMaxDelimCodePoint()>
<java.util.TimeZone$1: java.lang.Object run()>
<java.util.TimeZone$1: void <init>(java.lang.String)>
<java.util.TimeZone$DisplayNames: java.util.Map access$000()>
<java.util.TimeZone$DisplayNames: void <clinit>()>
<java.util.TimeZone: java.lang.Object clone()>
<java.util.TimeZone: java.lang.String getDisplayName(boolean,int,java.util.Locale)>
<java.util.TimeZone: java.lang.String getID()>
<java.util.TimeZone: java.lang.String[] getDisplayNames(java.lang.String,java.util.Locale)>
<java.util.TimeZone: java.util.TimeZone getDefault()>
<java.util.TimeZone: java.util.TimeZone getDefaultInAppContext()>
<java.util.TimeZone: java.util.TimeZone getDefaultRef()>
<java.util.TimeZone: java.util.TimeZone getTimeZone(java.lang.String,boolean)>
<java.util.TimeZone: java.util.TimeZone parseCustomTimeZone(java.lang.String)>
<java.util.TimeZone: java.util.TimeZone setDefaultZone()>
<java.util.TimeZone: void <clinit>()>
<java.util.TimeZone: void <init>()>
<java.util.TimeZone: void setID(java.lang.String)>
<java.util.TreeMap$Entry: void <init>(java.lang.Object,java.lang.Object,java.util.TreeMap$Entry)>
<java.util.TreeMap$KeyIterator: java.lang.Object next()>
<java.util.TreeMap$KeyIterator: void <init>(java.util.TreeMap,java.util.TreeMap$Entry)>
<java.util.TreeMap$KeySet: java.util.Iterator iterator()>
<java.util.TreeMap$KeySet: void <init>(java.util.NavigableMap)>
<java.util.TreeMap$PrivateEntryIterator: boolean hasNext()>
<java.util.TreeMap$PrivateEntryIterator: java.util.TreeMap$Entry nextEntry()>
<java.util.TreeMap$PrivateEntryIterator: void <init>(java.util.TreeMap,java.util.TreeMap$Entry)>
<java.util.TreeMap: boolean colorOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: int access$100(java.util.TreeMap)>
<java.util.TreeMap: int size()>
<java.util.TreeMap: java.lang.Object get(java.lang.Object)>
<java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.TreeMap: java.lang.Object remove(java.lang.Object)>
<java.util.TreeMap: java.util.Iterator keyIterator()>
<java.util.TreeMap: java.util.NavigableSet navigableKeySet()>
<java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
<java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
<java.util.TreeMap: java.util.TreeMap$Entry getFirstEntry()>
<java.util.TreeMap: java.util.TreeMap$Entry leftOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.util.TreeMap$Entry parentOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.util.TreeMap$Entry rightOf(java.util.TreeMap$Entry)>
<java.util.TreeMap: java.util.TreeMap$Entry successor(java.util.TreeMap$Entry)>
<java.util.TreeMap: void <init>()>
<java.util.TreeMap: void <init>(java.util.Comparator)>
<java.util.TreeMap: void clear()>
<java.util.TreeMap: void deleteEntry(java.util.TreeMap$Entry)>
<java.util.TreeMap: void fixAfterDeletion(java.util.TreeMap$Entry)>
<java.util.TreeMap: void fixAfterInsertion(java.util.TreeMap$Entry)>
<java.util.TreeMap: void rotateLeft(java.util.TreeMap$Entry)>
<java.util.TreeMap: void rotateRight(java.util.TreeMap$Entry)>
<java.util.TreeMap: void setColor(java.util.TreeMap$Entry,boolean)>
<java.util.TreeSet: boolean add(java.lang.Object)>
<java.util.TreeSet: boolean addAll(java.util.Collection)>
<java.util.TreeSet: int size()>
<java.util.TreeSet: java.util.Iterator iterator()>
<java.util.TreeSet: void <clinit>()>
<java.util.TreeSet: void <init>()>
<java.util.TreeSet: void <init>(java.util.NavigableMap)>
<java.util.Vector: boolean add(java.lang.Object)>
<java.util.Vector: boolean contains(java.lang.Object)>
<java.util.Vector: boolean isEmpty()>
<java.util.Vector: int indexOf(java.lang.Object,int)>
<java.util.Vector: int size()>
<java.util.Vector: java.lang.Object elementAt(int)>
<java.util.Vector: java.lang.Object get(int)>
<java.util.Vector: java.lang.Object remove(int)>
<java.util.Vector: java.lang.Object[] toArray(java.lang.Object[])>
<java.util.Vector: void <init>()>
<java.util.Vector: void <init>(int)>
<java.util.Vector: void <init>(int,int)>
<java.util.Vector: void addElement(java.lang.Object)>
<java.util.Vector: void copyInto(java.lang.Object[])>
<java.util.Vector: void ensureCapacityHelper(int)>
<java.util.Vector: void insertElementAt(java.lang.Object,int)>
<java.util.Vector: void removeAllElements()>
<java.util.Vector: void removeElementAt(int)>
<java.util.WeakHashMap$Entry: int access$000(java.util.WeakHashMap$Entry)>
<java.util.WeakHashMap$Entry: java.lang.Object access$200(java.util.WeakHashMap$Entry)>
<java.util.WeakHashMap$Entry: java.util.WeakHashMap$Entry access$100(java.util.WeakHashMap$Entry)>
<java.util.WeakHashMap$Entry: void <init>(java.lang.Object,java.lang.Object,java.lang.ref.ReferenceQueue,int,java.util.WeakHashMap$Entry)>
<java.util.WeakHashMap$HashIterator: boolean hasNext()>
<java.util.WeakHashMap$HashIterator: void <init>(java.util.WeakHashMap)>
<java.util.WeakHashMap$KeyIterator: void <init>(java.util.WeakHashMap)>
<java.util.WeakHashMap$KeyIterator: void <init>(java.util.WeakHashMap,java.util.WeakHashMap$1)>
<java.util.WeakHashMap$KeySet: java.util.Iterator iterator()>
<java.util.WeakHashMap$KeySet: void <init>(java.util.WeakHashMap)>
<java.util.WeakHashMap$KeySet: void <init>(java.util.WeakHashMap,java.util.WeakHashMap$1)>
<java.util.WeakHashMap: boolean eq(java.lang.Object,java.lang.Object)>
<java.util.WeakHashMap: int access$400(java.util.WeakHashMap)>
<java.util.WeakHashMap: int indexFor(int,int)>
<java.util.WeakHashMap: int size()>
<java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
<java.util.WeakHashMap: java.lang.Object maskNull(java.lang.Object)>
<java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.WeakHashMap: java.util.Set keySet()>
<java.util.WeakHashMap: java.util.WeakHashMap$Entry[] access$500(java.util.WeakHashMap)>
<java.util.WeakHashMap: java.util.WeakHashMap$Entry[] getTable()>
<java.util.WeakHashMap: void <clinit>()>
<java.util.WeakHashMap: void <init>()>
<java.util.WeakHashMap: void expungeStaleEntries()>
<java.util.concurrent.ConcurrentHashMap$HashEntry: java.util.concurrent.ConcurrentHashMap$HashEntry[] newArray(int)>
<java.util.concurrent.ConcurrentHashMap$HashEntry: void <init>(java.lang.Object,int,java.util.concurrent.ConcurrentHashMap$HashEntry,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.lang.Object get(java.lang.Object,int)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.lang.Object put(java.lang.Object,int,java.lang.Object,boolean)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.lang.Object remove(java.lang.Object,int,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.util.concurrent.ConcurrentHashMap$HashEntry getFirst(int)>
<java.util.concurrent.ConcurrentHashMap$Segment: java.util.concurrent.ConcurrentHashMap$Segment[] newArray(int)>
<java.util.concurrent.ConcurrentHashMap$Segment: void <init>(int,float)>
<java.util.concurrent.ConcurrentHashMap$Segment: void rehash()>
<java.util.concurrent.ConcurrentHashMap$Segment: void setTable(java.util.concurrent.ConcurrentHashMap$HashEntry[])>
<java.util.concurrent.ConcurrentHashMap: int hash(int)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.lang.Object remove(java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap$Segment segmentFor(int)>
<java.util.concurrent.ConcurrentHashMap: void <init>()>
<java.util.concurrent.ConcurrentHashMap: void <init>(int)>
<java.util.concurrent.ConcurrentHashMap: void <init>(int,float,int)>
<java.util.concurrent.atomic.AtomicInteger: boolean compareAndSet(int,int)>
<java.util.concurrent.atomic.AtomicInteger: int decrementAndGet()>
<java.util.concurrent.atomic.AtomicInteger: int get()>
<java.util.concurrent.atomic.AtomicInteger: int getAndAdd(int)>
<java.util.concurrent.atomic.AtomicInteger: int incrementAndGet()>
<java.util.concurrent.atomic.AtomicInteger: void <init>()>
<java.util.concurrent.atomic.AtomicLong: void <clinit>()>
<java.util.concurrent.atomic.AtomicLong: void <init>(long)>
<java.util.concurrent.atomic.AtomicReference: void <clinit>()>
<java.util.concurrent.atomic.AtomicReference: void <init>(java.lang.Object)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl: boolean compareAndSet(java.lang.Object,java.lang.Object,java.lang.Object)>
<java.util.concurrent.locks.AbstractOwnableSynchronizer: java.lang.Thread getExclusiveOwnerThread()>
<java.util.concurrent.locks.AbstractOwnableSynchronizer: void <init>()>
<java.util.concurrent.locks.AbstractOwnableSynchronizer: void setExclusiveOwnerThread(java.lang.Thread)>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: boolean compareAndSetState(int,int)>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: boolean release(int)>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: int getState()>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: void <init>()>
<java.util.concurrent.locks.AbstractQueuedSynchronizer: void setState(int)>
<java.util.concurrent.locks.ReentrantLock$NonfairSync: void <init>()>
<java.util.concurrent.locks.ReentrantLock$NonfairSync: void lock()>
<java.util.concurrent.locks.ReentrantLock$Sync: boolean tryRelease(int)>
<java.util.concurrent.locks.ReentrantLock$Sync: void <init>()>
<java.util.concurrent.locks.ReentrantLock: void <init>()>
<java.util.concurrent.locks.ReentrantLock: void lock()>
<java.util.concurrent.locks.ReentrantLock: void unlock()>
<java.util.jar.Attributes$Name: boolean equals(java.lang.Object)>
<java.util.jar.Attributes$Name: boolean isAlpha(char)>
<java.util.jar.Attributes$Name: boolean isDigit(char)>
<java.util.jar.Attributes$Name: boolean isValid(char)>
<java.util.jar.Attributes$Name: boolean isValid(java.lang.String)>
<java.util.jar.Attributes$Name: int hashCode()>
<java.util.jar.Attributes$Name: void <clinit>()>
<java.util.jar.Attributes$Name: void <init>(java.lang.String)>
<java.util.jar.Attributes: java.lang.Object get(java.lang.Object)>
<java.util.jar.Attributes: java.lang.Object put(java.lang.Object,java.lang.Object)>
<java.util.jar.Attributes: java.lang.String getValue(java.lang.String)>
<java.util.jar.Attributes: java.lang.String getValue(java.util.jar.Attributes$Name)>
<java.util.jar.Attributes: java.lang.String putValue(java.lang.String,java.lang.String)>
<java.util.jar.Attributes: void <init>()>
<java.util.jar.Attributes: void <init>(int)>
<java.util.jar.Attributes: void read(java.util.jar.Manifest$FastInputStream,byte[])>
<java.util.jar.JarEntry: void <init>(java.util.jar.JarEntry)>
<java.util.jar.JarEntry: void <init>(java.util.zip.ZipEntry)>
<java.util.jar.JarFile$1: boolean hasMoreElements()>
<java.util.jar.JarFile$1: java.lang.Object nextElement()>
<java.util.jar.JarFile$1: java.util.jar.JarFile$JarFileEntry nextElement()>
<java.util.jar.JarFile$1: void <init>(java.util.jar.JarFile,java.util.Enumeration)>
<java.util.jar.JarFile$JarFileEntry: java.security.CodeSigner[] getCodeSigners()>
<java.util.jar.JarFile$JarFileEntry: void <init>(java.util.jar.JarFile,java.util.zip.ZipEntry)>
<java.util.jar.JarFile: boolean hasClassPathAttribute()>
<java.util.jar.JarFile: boolean isKnownToNotHaveClassPathAttribute()>
<java.util.jar.JarFile: byte[] getBytes(java.util.zip.ZipEntry)>
<java.util.jar.JarFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>
<java.util.jar.JarFile: java.util.Enumeration entries()>
<java.util.jar.JarFile: java.util.jar.JarEntry getJarEntry(java.lang.String)>
<java.util.jar.JarFile: java.util.jar.JarEntry getManEntry()>
<java.util.jar.JarFile: java.util.jar.JarVerifier access$100(java.util.jar.JarFile)>
<java.util.jar.JarFile: java.util.jar.Manifest getManifest()>
<java.util.jar.JarFile: java.util.jar.Manifest getManifestFromReference()>
<java.util.jar.JarFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
<java.util.jar.JarFile: void <clinit>()>
<java.util.jar.JarFile: void <init>(java.io.File)>
<java.util.jar.JarFile: void <init>(java.io.File,boolean,int)>
<java.util.jar.JarFile: void <init>(java.lang.String)>
<java.util.jar.JarFile: void access$000(java.util.jar.JarFile)>
<java.util.jar.JarFile: void maybeInstantiateVerifier()>
<java.util.jar.JarVerifier$3: void <init>(java.util.jar.JarVerifier)>
<java.util.jar.JarVerifier: void <clinit>()>
<java.util.jar.JarVerifier: void <init>(byte[])>
<java.util.jar.JavaUtilJarAccessImpl: boolean jarFileHasClassPathAttribute(java.util.jar.JarFile)>
<java.util.jar.JavaUtilJarAccessImpl: void <init>()>
<java.util.jar.Manifest$FastInputStream: byte peek()>
<java.util.jar.Manifest$FastInputStream: int readLine(byte[])>
<java.util.jar.Manifest$FastInputStream: int readLine(byte[],int,int)>
<java.util.jar.Manifest$FastInputStream: void <init>(java.io.InputStream)>
<java.util.jar.Manifest$FastInputStream: void <init>(java.io.InputStream,int)>
<java.util.jar.Manifest$FastInputStream: void fill()>
<java.util.jar.Manifest: java.util.Map getEntries()>
<java.util.jar.Manifest: java.util.jar.Attributes getAttributes(java.lang.String)>
<java.util.jar.Manifest: java.util.jar.Attributes getMainAttributes()>
<java.util.jar.Manifest: void <init>(java.io.InputStream)>
<java.util.jar.Manifest: void read(java.io.InputStream)>
<java.util.zip.CRC32: long getValue()>
<java.util.zip.CRC32: void <init>()>
<java.util.zip.CRC32: void reset()>
<java.util.zip.CRC32: void update(byte[])>
<java.util.zip.CRC32: void update(byte[],int,int)>
<java.util.zip.Inflater: boolean finished()>
<java.util.zip.Inflater: boolean needsDictionary()>
<java.util.zip.Inflater: boolean needsInput()>
<java.util.zip.Inflater: int getRemaining()>
<java.util.zip.Inflater: int inflate(byte[],int,int)>
<java.util.zip.Inflater: long getBytesRead()>
<java.util.zip.Inflater: long getBytesWritten()>
<java.util.zip.Inflater: void <clinit>()>
<java.util.zip.Inflater: void <init>(boolean)>
<java.util.zip.Inflater: void end()>
<java.util.zip.Inflater: void ensureOpen()>
<java.util.zip.Inflater: void finalize()>
<java.util.zip.Inflater: void reset()>
<java.util.zip.Inflater: void setInput(byte[],int,int)>
<java.util.zip.InflaterInputStream: int read()>
<java.util.zip.InflaterInputStream: int read(byte[],int,int)>
<java.util.zip.InflaterInputStream: void <init>(java.io.InputStream,java.util.zip.Inflater,int)>
<java.util.zip.InflaterInputStream: void close()>
<java.util.zip.InflaterInputStream: void ensureOpen()>
<java.util.zip.InflaterInputStream: void fill()>
<java.util.zip.ZStreamRef: long address()>
<java.util.zip.ZStreamRef: void <init>(long)>
<java.util.zip.ZStreamRef: void clear()>
<java.util.zip.ZipEntry: boolean isDirectory()>
<java.util.zip.ZipEntry: java.lang.String getName()>
<java.util.zip.ZipEntry: long getSize()>
<java.util.zip.ZipEntry: void <clinit>()>
<java.util.zip.ZipEntry: void <init>(java.lang.String)>
<java.util.zip.ZipEntry: void <init>(java.lang.String,long)>
<java.util.zip.ZipEntry: void <init>(java.util.zip.ZipEntry)>
<java.util.zip.ZipEntry: void <init>(long)>
<java.util.zip.ZipException: void <init>(java.lang.String)>
<java.util.zip.ZipFile$1: int available()>
<java.util.zip.ZipFile$1: void <init>(java.util.zip.ZipFile,java.io.InputStream,java.util.zip.Inflater,int,java.util.zip.ZipFile$ZipFileInputStream)>
<java.util.zip.ZipFile$1: void close()>
<java.util.zip.ZipFile$1: void fill()>
<java.util.zip.ZipFile$2: boolean hasMoreElements()>
<java.util.zip.ZipFile$2: java.lang.Object nextElement()>
<java.util.zip.ZipFile$2: java.util.zip.ZipEntry nextElement()>
<java.util.zip.ZipFile$2: void <init>(java.util.zip.ZipFile)>
<java.util.zip.ZipFile$ZipFileInputStream: int read(byte[],int,int)>
<java.util.zip.ZipFile$ZipFileInputStream: long size()>
<java.util.zip.ZipFile$ZipFileInputStream: void <init>(java.util.zip.ZipFile,long)>
<java.util.zip.ZipFile$ZipFileInputStream: void close()>
<java.util.zip.ZipFile: int access$1200(long,long,long,byte[],int,int)>
<java.util.zip.ZipFile: int access$200(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: java.io.InputStream getInputStream(java.lang.String)>
<java.util.zip.ZipFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>
<java.util.zip.ZipFile: java.lang.String getName()>
<java.util.zip.ZipFile: java.util.Enumeration entries()>
<java.util.zip.ZipFile: java.util.zip.Inflater getInflater()>
<java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
<java.util.zip.ZipFile: long access$1000(long)>
<java.util.zip.ZipFile: long access$300(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: long access$400(long,int)>
<java.util.zip.ZipFile: long access$900(long)>
<java.util.zip.ZipFile: void <clinit>()>
<java.util.zip.ZipFile: void <init>(java.io.File)>
<java.util.zip.ZipFile: void <init>(java.io.File,int)>
<java.util.zip.ZipFile: void access$000(java.util.zip.ZipFile,java.util.zip.Inflater)>
<java.util.zip.ZipFile: void access$100(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: void access$1100(java.util.zip.ZipFile)>
<java.util.zip.ZipFile: void access$800(long,long)>
<java.util.zip.ZipFile: void close()>
<java.util.zip.ZipFile: void ensureOpen()>
<java.util.zip.ZipFile: void ensureOpenOrZipException()>
<java.util.zip.ZipFile: void finalize()>
<java.util.zip.ZipFile: void releaseInflater(java.util.zip.Inflater)>
<java.util.zip.ZipInputStream: int get16(byte[],int)>
<java.util.zip.ZipInputStream: int read(byte[],int,int)>
<java.util.zip.ZipInputStream: java.lang.String getFileName(byte[],int)>
<java.util.zip.ZipInputStream: java.lang.String getUTF8String(byte[],int,int)>
<java.util.zip.ZipInputStream: java.util.zip.ZipEntry createZipEntry(java.lang.String)>
<java.util.zip.ZipInputStream: java.util.zip.ZipEntry getNextEntry()>
<java.util.zip.ZipInputStream: java.util.zip.ZipEntry readLOC()>
<java.util.zip.ZipInputStream: long get32(byte[],int)>
<java.util.zip.ZipInputStream: void <clinit>()>
<java.util.zip.ZipInputStream: void <init>(java.io.InputStream)>
<java.util.zip.ZipInputStream: void close()>
<java.util.zip.ZipInputStream: void closeEntry()>
<java.util.zip.ZipInputStream: void ensureOpen()>
<java.util.zip.ZipInputStream: void readEnd(java.util.zip.ZipEntry)>
<java.util.zip.ZipInputStream: void readFully(byte[],int,int)>
<javax.xml.parsers.DocumentBuilder: void <init>()>
<javax.xml.parsers.DocumentBuilderFactory: boolean isCoalescing()>
<javax.xml.parsers.DocumentBuilderFactory: boolean isExpandEntityReferences()>
<javax.xml.parsers.DocumentBuilderFactory: boolean isIgnoringComments()>
<javax.xml.parsers.DocumentBuilderFactory: boolean isIgnoringElementContentWhitespace()>
<javax.xml.parsers.DocumentBuilderFactory: boolean isNamespaceAware()>
<javax.xml.parsers.DocumentBuilderFactory: boolean isValidating()>
<javax.xml.parsers.DocumentBuilderFactory: javax.xml.parsers.DocumentBuilderFactory newInstance()>
<javax.xml.parsers.DocumentBuilderFactory: void <init>()>
<javax.xml.parsers.DocumentBuilderFactory: void setExpandEntityReferences(boolean)>
<javax.xml.parsers.DocumentBuilderFactory: void setIgnoringComments(boolean)>
<javax.xml.parsers.DocumentBuilderFactory: void setValidating(boolean)>
<javax.xml.parsers.FactoryFinder: java.lang.Class getProviderClass(java.lang.String,java.lang.ClassLoader,boolean)>
<javax.xml.parsers.FactoryFinder: java.lang.Object find(java.lang.String,java.lang.String)>
<javax.xml.parsers.FactoryFinder: java.lang.Object findJarServiceProvider(java.lang.String)>
<javax.xml.parsers.FactoryFinder: java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean)>
<javax.xml.parsers.FactoryFinder: void <clinit>()>
<javax.xml.parsers.FactoryFinder: void dPrint(java.lang.String)>
<javax.xml.parsers.SAXParser: void <init>()>
<javax.xml.parsers.SAXParser: void parse(java.io.InputStream,org.xml.sax.helpers.DefaultHandler)>
<javax.xml.parsers.SAXParserFactory: boolean isNamespaceAware()>
<javax.xml.parsers.SAXParserFactory: boolean isValidating()>
<javax.xml.parsers.SAXParserFactory: javax.xml.parsers.SAXParserFactory newInstance()>
<javax.xml.parsers.SAXParserFactory: void <init>()>
<javax.xml.parsers.SAXParserFactory: void setNamespaceAware(boolean)>
<javax.xml.parsers.SAXParserFactory: void setValidating(boolean)>
<javax.xml.parsers.SecuritySupport$1: java.lang.Object run()>
<javax.xml.parsers.SecuritySupport$1: void <init>(javax.xml.parsers.SecuritySupport)>
<javax.xml.parsers.SecuritySupport$2: java.lang.Object run()>
<javax.xml.parsers.SecuritySupport$2: void <init>(javax.xml.parsers.SecuritySupport,java.lang.String)>
<javax.xml.parsers.SecuritySupport$4: java.lang.Object run()>
<javax.xml.parsers.SecuritySupport$4: void <init>(javax.xml.parsers.SecuritySupport,java.lang.ClassLoader,java.lang.String)>
<javax.xml.parsers.SecuritySupport$5: java.lang.Object run()>
<javax.xml.parsers.SecuritySupport$5: void <init>(javax.xml.parsers.SecuritySupport,java.io.File)>
<javax.xml.parsers.SecuritySupport: boolean doesFileExist(java.io.File)>
<javax.xml.parsers.SecuritySupport: java.io.InputStream getResourceAsStream(java.lang.ClassLoader,java.lang.String)>
<javax.xml.parsers.SecuritySupport: java.lang.ClassLoader getContextClassLoader()>
<javax.xml.parsers.SecuritySupport: java.lang.String getSystemProperty(java.lang.String)>
<javax.xml.parsers.SecuritySupport: void <init>()>
<javax.xml.transform.FactoryFinder: java.lang.Class getProviderClass(java.lang.String,java.lang.ClassLoader,boolean)>
<javax.xml.transform.FactoryFinder: java.lang.Object find(java.lang.String,java.lang.String)>
<javax.xml.transform.FactoryFinder: java.lang.Object findJarServiceProvider(java.lang.String)>
<javax.xml.transform.FactoryFinder: java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean)>
<javax.xml.transform.FactoryFinder: java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean,boolean)>
<javax.xml.transform.FactoryFinder: java.lang.Object newInstanceNoServiceLoader(java.lang.Class)>
<javax.xml.transform.FactoryFinder: void <clinit>()>
<javax.xml.transform.FactoryFinder: void dPrint(java.lang.String)>
<javax.xml.transform.SecuritySupport$1: java.lang.Object run()>
<javax.xml.transform.SecuritySupport$1: void <init>(javax.xml.transform.SecuritySupport)>
<javax.xml.transform.SecuritySupport$2: java.lang.Object run()>
<javax.xml.transform.SecuritySupport$2: void <init>(javax.xml.transform.SecuritySupport,java.lang.String)>
<javax.xml.transform.SecuritySupport$4: java.lang.Object run()>
<javax.xml.transform.SecuritySupport$4: void <init>(javax.xml.transform.SecuritySupport,java.lang.ClassLoader,java.lang.String)>
<javax.xml.transform.SecuritySupport$5: java.lang.Object run()>
<javax.xml.transform.SecuritySupport$5: void <init>(javax.xml.transform.SecuritySupport,java.io.File)>
<javax.xml.transform.SecuritySupport: boolean doesFileExist(java.io.File)>
<javax.xml.transform.SecuritySupport: java.io.InputStream getResourceAsStream(java.lang.ClassLoader,java.lang.String)>
<javax.xml.transform.SecuritySupport: java.lang.ClassLoader getContextClassLoader()>
<javax.xml.transform.SecuritySupport: java.lang.String getSystemProperty(java.lang.String)>
<javax.xml.transform.SecuritySupport: void <init>()>
<javax.xml.transform.Transformer: void <init>()>
<javax.xml.transform.TransformerFactory: javax.xml.transform.TransformerFactory newInstance()>
<javax.xml.transform.TransformerFactory: void <init>()>
<javax.xml.transform.dom.DOMSource: java.lang.String getSystemId()>
<javax.xml.transform.dom.DOMSource: org.w3c.dom.Node getNode()>
<javax.xml.transform.dom.DOMSource: void <init>(org.w3c.dom.Node)>
<javax.xml.transform.dom.DOMSource: void setNode(org.w3c.dom.Node)>
<javax.xml.transform.sax.SAXTransformerFactory: void <init>()>
<javax.xml.transform.stream.StreamResult: java.io.OutputStream getOutputStream()>
<javax.xml.transform.stream.StreamResult: java.io.Writer getWriter()>
<javax.xml.transform.stream.StreamResult: void <init>(java.io.OutputStream)>
<javax.xml.transform.stream.StreamResult: void setOutputStream(java.io.OutputStream)>
<org.apache.xalan.processor.TransformerFactoryImpl: java.lang.Class class$(java.lang.String)>
<org.apache.xalan.processor.TransformerFactoryImpl: javax.xml.transform.Transformer newTransformer()>
<org.apache.xalan.processor.TransformerFactoryImpl: void <clinit>()>
<org.apache.xalan.processor.TransformerFactoryImpl: void <init>()>
<org.apache.xalan.serialize.CharInfo: boolean isSpecial(char)>
<org.apache.xalan.serialize.CharInfo: java.lang.Class class$(java.lang.String)>
<org.apache.xalan.serialize.CharInfo: void <clinit>()>
<org.apache.xalan.serialize.CharInfo: void <init>(java.lang.String)>
<org.apache.xalan.serialize.CharInfo: void defineEntity(java.lang.String,char)>
<org.apache.xalan.serialize.EncodingInfo: void <init>(java.lang.String,java.lang.String,int)>
<org.apache.xalan.serialize.Encodings: int getLastPrintable()>
<org.apache.xalan.serialize.Encodings: int getLastPrintable(java.lang.String)>
<org.apache.xalan.serialize.Encodings: java.lang.Class class$(java.lang.String)>
<org.apache.xalan.serialize.Encodings: java.lang.String convertJava2MimeEncoding(java.lang.String)>
<org.apache.xalan.serialize.Encodings: java.lang.String getMimeEncoding(java.lang.String)>
<org.apache.xalan.serialize.Encodings: org.apache.xalan.serialize.EncodingInfo[] loadEncodingInfo()>
<org.apache.xalan.serialize.Encodings: void <clinit>()>
<org.apache.xalan.serialize.SerializerFactory: org.apache.xalan.serialize.Serializer getSerializer(java.util.Properties)>
<org.apache.xalan.serialize.SerializerFactory: void <clinit>()>
<org.apache.xalan.serialize.SerializerToXML: boolean canConvert(char)>
<org.apache.xalan.serialize.SerializerToXML: boolean childNodesWereAdded()>
<org.apache.xalan.serialize.SerializerToXML: boolean shouldIndent()>
<org.apache.xalan.serialize.SerializerToXML: org.xml.sax.ContentHandler asContentHandler()>
<org.apache.xalan.serialize.SerializerToXML: void <clinit>()>
<org.apache.xalan.serialize.SerializerToXML: void <init>()>
<org.apache.xalan.serialize.SerializerToXML: void endDocument()>
<org.apache.xalan.serialize.SerializerToXML: void endElement(java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xalan.serialize.SerializerToXML: void flushWriter()>
<org.apache.xalan.serialize.SerializerToXML: void indent(int)>
<org.apache.xalan.serialize.SerializerToXML: void init(java.io.OutputStream,java.util.Properties)>
<org.apache.xalan.serialize.SerializerToXML: void init(java.io.Writer,java.util.Properties,boolean)>
<org.apache.xalan.serialize.SerializerToXML: void openElementForChildren()>
<org.apache.xalan.serialize.SerializerToXML: void outputLineSep()>
<org.apache.xalan.serialize.SerializerToXML: void printSpace(int)>
<org.apache.xalan.serialize.SerializerToXML: void processAttribute(java.lang.String,java.lang.String)>
<org.apache.xalan.serialize.SerializerToXML: void pushState(java.lang.String,java.lang.String,java.util.Vector,org.apache.xml.utils.BoolStack)>
<org.apache.xalan.serialize.SerializerToXML: void setDocumentLocator(org.xml.sax.Locator)>
<org.apache.xalan.serialize.SerializerToXML: void setOutputFormat(java.util.Properties)>
<org.apache.xalan.serialize.SerializerToXML: void setOutputStream(java.io.OutputStream)>
<org.apache.xalan.serialize.SerializerToXML: void startDocument()>
<org.apache.xalan.serialize.SerializerToXML: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.apache.xalan.serialize.SerializerToXML: void writeAttrString(java.lang.String,java.lang.String)>
<org.apache.xalan.serialize.SerializerToXML: void writeParentTagEnd()>
<org.apache.xalan.serialize.WriterToUTF8: void <init>(java.io.OutputStream)>
<org.apache.xalan.serialize.WriterToUTF8: void flush()>
<org.apache.xalan.serialize.WriterToUTF8: void write(char[],int,int)>
<org.apache.xalan.serialize.WriterToUTF8: void write(int)>
<org.apache.xalan.serialize.WriterToUTF8: void write(java.lang.String)>
<org.apache.xalan.templates.ElemTemplateElement: void <init>()>
<org.apache.xalan.templates.OutputProperties: boolean getBooleanProperty(java.lang.String,java.util.Properties)>
<org.apache.xalan.templates.OutputProperties: boolean isLegalPropertyKey(java.lang.String)>
<org.apache.xalan.templates.OutputProperties: int getIntProperty(java.lang.String,java.util.Properties)>
<org.apache.xalan.templates.OutputProperties: java.lang.Class class$(java.lang.String)>
<org.apache.xalan.templates.OutputProperties: java.lang.String fixupPropertyString(java.lang.String,boolean)>
<org.apache.xalan.templates.OutputProperties: java.lang.String getProperty(java.lang.String)>
<org.apache.xalan.templates.OutputProperties: java.util.Properties getDefaultMethodProperties(java.lang.String)>
<org.apache.xalan.templates.OutputProperties: java.util.Properties getProperties()>
<org.apache.xalan.templates.OutputProperties: java.util.Properties loadPropertiesFile(java.lang.String,java.util.Properties)>
<org.apache.xalan.templates.OutputProperties: java.util.Vector getQNameProperties(java.lang.String,java.util.Properties)>
<org.apache.xalan.templates.OutputProperties: void <clinit>()>
<org.apache.xalan.templates.OutputProperties: void <init>(java.lang.String)>
<org.apache.xalan.templates.OutputProperties: void setMethodDefaults(java.lang.String)>
<org.apache.xalan.templates.OutputProperties: void setProperty(java.lang.String,java.lang.String)>
<org.apache.xalan.transformer.SerializerSwitcher: org.apache.xalan.serialize.Serializer switchSerializerIfHTML(java.lang.String,java.lang.String,java.util.Properties,org.apache.xalan.serialize.Serializer)>
<org.apache.xalan.transformer.TransformerIdentityImpl: void <init>()>
<org.apache.xalan.transformer.TransformerIdentityImpl: void createResultContentHandler(javax.xml.transform.Result)>
<org.apache.xalan.transformer.TransformerIdentityImpl: void endDocument()>
<org.apache.xalan.transformer.TransformerIdentityImpl: void endElement(java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xalan.transformer.TransformerIdentityImpl: void flushStartDoc()>
<org.apache.xalan.transformer.TransformerIdentityImpl: void setDocumentLocator(org.xml.sax.Locator)>
<org.apache.xalan.transformer.TransformerIdentityImpl: void setOutputProperty(java.lang.String,java.lang.String)>
<org.apache.xalan.transformer.TransformerIdentityImpl: void startDocument()>
<org.apache.xalan.transformer.TransformerIdentityImpl: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.apache.xalan.transformer.TransformerIdentityImpl: void transform(javax.xml.transform.Source,javax.xml.transform.Result)>
<org.apache.xerces.dom.AttrImpl: java.lang.String getName()>
<org.apache.xerces.dom.AttrImpl: java.lang.String getNodeName()>
<org.apache.xerces.dom.AttrImpl: java.lang.String getNodeValue()>
<org.apache.xerces.dom.AttrImpl: java.lang.String getValue()>
<org.apache.xerces.dom.AttrImpl: org.w3c.dom.Element getOwnerElement()>
<org.apache.xerces.dom.AttrImpl: short getNodeType()>
<org.apache.xerces.dom.AttrImpl: void <clinit>()>
<org.apache.xerces.dom.AttrImpl: void <init>(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String)>
<org.apache.xerces.dom.AttrImpl: void setNodeValue(java.lang.String)>
<org.apache.xerces.dom.AttrImpl: void setValue(java.lang.String)>
<org.apache.xerces.dom.AttributeMap: org.w3c.dom.Node internalRemoveNamedItem(java.lang.String,boolean)>
<org.apache.xerces.dom.AttributeMap: org.w3c.dom.Node remove(org.apache.xerces.dom.AttrImpl,int,boolean)>
<org.apache.xerces.dom.AttributeMap: org.w3c.dom.Node removeNamedItem(java.lang.String)>
<org.apache.xerces.dom.AttributeMap: org.w3c.dom.Node setNamedItem(org.w3c.dom.Node)>
<org.apache.xerces.dom.AttributeMap: void <init>(org.apache.xerces.dom.ElementImpl,org.apache.xerces.dom.NamedNodeMapImpl)>
<org.apache.xerces.dom.CharacterDataImpl$1: void <init>()>
<org.apache.xerces.dom.CharacterDataImpl: void <clinit>()>
<org.apache.xerces.dom.CharacterDataImpl: void <init>(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String)>
<org.apache.xerces.dom.ChildNode: org.apache.xerces.dom.NodeImpl parentNode()>
<org.apache.xerces.dom.ChildNode: org.w3c.dom.Node getNextSibling()>
<org.apache.xerces.dom.ChildNode: org.w3c.dom.Node getParentNode()>
<org.apache.xerces.dom.ChildNode: void <init>(org.apache.xerces.dom.CoreDocumentImpl)>
<org.apache.xerces.dom.CoreDocumentImpl: boolean isKidOK(org.w3c.dom.Node,org.w3c.dom.Node)>
<org.apache.xerces.dom.CoreDocumentImpl: boolean isXMLName(java.lang.String,boolean)>
<org.apache.xerces.dom.CoreDocumentImpl: int changes()>
<org.apache.xerces.dom.CoreDocumentImpl: java.lang.String getXmlVersion()>
<org.apache.xerces.dom.CoreDocumentImpl: org.apache.xerces.dom.NodeListCache getNodeListCache(org.apache.xerces.dom.ParentNode)>
<org.apache.xerces.dom.CoreDocumentImpl: org.w3c.dom.Attr createAttribute(java.lang.String)>
<org.apache.xerces.dom.CoreDocumentImpl: org.w3c.dom.DocumentType getDoctype()>
<org.apache.xerces.dom.CoreDocumentImpl: org.w3c.dom.Element createElement(java.lang.String)>
<org.apache.xerces.dom.CoreDocumentImpl: org.w3c.dom.Element getDocumentElement()>
<org.apache.xerces.dom.CoreDocumentImpl: org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node)>
<org.apache.xerces.dom.CoreDocumentImpl: short getNodeType()>
<org.apache.xerces.dom.CoreDocumentImpl: void <clinit>()>
<org.apache.xerces.dom.CoreDocumentImpl: void <init>()>
<org.apache.xerces.dom.CoreDocumentImpl: void <init>(boolean)>
<org.apache.xerces.dom.CoreDocumentImpl: void changed()>
<org.apache.xerces.dom.CoreDocumentImpl: void freeNodeListCache(org.apache.xerces.dom.NodeListCache)>
<org.apache.xerces.dom.CoreDocumentImpl: void setDocumentURI(java.lang.String)>
<org.apache.xerces.dom.CoreDocumentImpl: void setInputEncoding(java.lang.String)>
<org.apache.xerces.dom.CoreDocumentImpl: void setXmlEncoding(java.lang.String)>
<org.apache.xerces.dom.CoreDocumentImpl: void setXmlStandalone(boolean)>
<org.apache.xerces.dom.CoreDocumentImpl: void setXmlVersion(java.lang.String)>
<org.apache.xerces.dom.DOMMessageFormatter: java.lang.String formatMessage(java.lang.String,java.lang.String,java.lang.Object[])>
<org.apache.xerces.dom.DOMMessageFormatter: java.util.ResourceBundle getResourceBundle(java.lang.String)>
<org.apache.xerces.dom.DOMMessageFormatter: void <clinit>()>
<org.apache.xerces.dom.DOMMessageFormatter: void init()>
<org.apache.xerces.dom.DeepNodeListImpl: int getLength()>
<org.apache.xerces.dom.DeepNodeListImpl: org.w3c.dom.Node item(int)>
<org.apache.xerces.dom.DeepNodeListImpl: org.w3c.dom.Node nextMatchingElementAfter(org.w3c.dom.Node)>
<org.apache.xerces.dom.DeepNodeListImpl: void <init>(org.apache.xerces.dom.NodeImpl,java.lang.String)>
<org.apache.xerces.dom.DeferredAttrImpl: void <init>(org.apache.xerces.dom.DeferredDocumentImpl,int)>
<org.apache.xerces.dom.DeferredAttrImpl: void synchronizeChildren()>
<org.apache.xerces.dom.DeferredAttrImpl: void synchronizeData()>
<org.apache.xerces.dom.DeferredDocumentImpl$RefCount: void <init>(org.apache.xerces.dom.DeferredDocumentImpl)>
<org.apache.xerces.dom.DeferredDocumentImpl: int clearChunkIndex(int[][],int,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: int createDeferredAttribute(java.lang.String,java.lang.String,java.lang.String,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: int createDeferredDocument()>
<org.apache.xerces.dom.DeferredDocumentImpl: int createDeferredElement(java.lang.String,java.lang.String,java.lang.Object)>
<org.apache.xerces.dom.DeferredDocumentImpl: int createDeferredTextNode(java.lang.String,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: int createNode(short)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getChunkIndex(int[][],int,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getLastChild(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getLastChild(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getNodeExtra(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getNodeExtra(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getParentNode(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getPrevSibling(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: int getPrevSibling(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: int setChunkIndex(int[][],int,int,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: int setDeferredAttribute(int,java.lang.String,java.lang.String,java.lang.String,boolean,boolean,java.lang.Object)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.Object getTypeInfo(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.String clearChunkValue(java.lang.Object[][],int,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.String getNodeName(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.String getNodeName(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.String getNodeValueString(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.String getNodeValueString(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: java.lang.String setChunkValue(java.lang.Object[][],java.lang.Object,int,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: org.apache.xerces.dom.DeferredNode getNodeObject(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: short getNodeType(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: short getNodeType(int,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: void <clinit>()>
<org.apache.xerces.dom.DeferredDocumentImpl: void <init>(boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: void <init>(boolean,boolean)>
<org.apache.xerces.dom.DeferredDocumentImpl: void appendChild(int,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: void createChunk(int[][],int)>
<org.apache.xerces.dom.DeferredDocumentImpl: void createChunk(java.lang.Object[][],int)>
<org.apache.xerces.dom.DeferredDocumentImpl: void ensureCapacity(int)>
<org.apache.xerces.dom.DeferredDocumentImpl: void synchronizeChildren()>
<org.apache.xerces.dom.DeferredDocumentImpl: void synchronizeChildren(org.apache.xerces.dom.AttrImpl,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: void synchronizeChildren(org.apache.xerces.dom.ParentNode,int)>
<org.apache.xerces.dom.DeferredDocumentImpl: void synchronizeData()>
<org.apache.xerces.dom.DeferredElementImpl: void <init>(org.apache.xerces.dom.DeferredDocumentImpl,int)>
<org.apache.xerces.dom.DeferredElementImpl: void synchronizeChildren()>
<org.apache.xerces.dom.DeferredElementImpl: void synchronizeData()>
<org.apache.xerces.dom.DeferredTextImpl: void <init>(org.apache.xerces.dom.DeferredDocumentImpl,int)>
<org.apache.xerces.dom.DocumentImpl: boolean getMutationEvents()>
<org.apache.xerces.dom.DocumentImpl: void <init>()>
<org.apache.xerces.dom.DocumentImpl: void <init>(boolean)>
<org.apache.xerces.dom.DocumentImpl: void insertedNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean)>
<org.apache.xerces.dom.DocumentImpl: void insertingNode(org.apache.xerces.dom.NodeImpl,boolean)>
<org.apache.xerces.dom.DocumentImpl: void removedAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.NodeImpl,java.lang.String)>
<org.apache.xerces.dom.DocumentImpl: void setAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.AttrImpl)>
<org.apache.xerces.dom.DocumentImpl: void setMutationEvents(boolean)>
<org.apache.xerces.dom.ElementImpl: boolean hasAttribute(java.lang.String)>
<org.apache.xerces.dom.ElementImpl: java.lang.String getAttribute(java.lang.String)>
<org.apache.xerces.dom.ElementImpl: java.lang.String getNodeName()>
<org.apache.xerces.dom.ElementImpl: java.lang.String getTagName()>
<org.apache.xerces.dom.ElementImpl: org.apache.xerces.dom.NamedNodeMapImpl getDefaultAttributes()>
<org.apache.xerces.dom.ElementImpl: org.w3c.dom.Attr getAttributeNode(java.lang.String)>
<org.apache.xerces.dom.ElementImpl: org.w3c.dom.NamedNodeMap getAttributes()>
<org.apache.xerces.dom.ElementImpl: org.w3c.dom.NodeList getElementsByTagName(java.lang.String)>
<org.apache.xerces.dom.ElementImpl: short getNodeType()>
<org.apache.xerces.dom.ElementImpl: void <init>(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String)>
<org.apache.xerces.dom.ElementImpl: void setAttribute(java.lang.String,java.lang.String)>
<org.apache.xerces.dom.ElementImpl: void setupDefaultAttributes()>
<org.apache.xerces.dom.ElementImpl: void synchronizeData()>
<org.apache.xerces.dom.NamedNodeMapImpl: boolean hasDefaults()>
<org.apache.xerces.dom.NamedNodeMapImpl: boolean isReadOnly()>
<org.apache.xerces.dom.NamedNodeMapImpl: int findNamePoint(java.lang.String,int)>
<org.apache.xerces.dom.NamedNodeMapImpl: int getLength()>
<org.apache.xerces.dom.NamedNodeMapImpl: org.w3c.dom.Node getNamedItem(java.lang.String)>
<org.apache.xerces.dom.NamedNodeMapImpl: org.w3c.dom.Node item(int)>
<org.apache.xerces.dom.NamedNodeMapImpl: void <init>(org.apache.xerces.dom.NodeImpl)>
<org.apache.xerces.dom.NodeImpl: boolean hasChildNodes()>
<org.apache.xerces.dom.NodeImpl: boolean hasStringValue()>
<org.apache.xerces.dom.NodeImpl: boolean isIdAttribute()>
<org.apache.xerces.dom.NodeImpl: boolean isNormalized()>
<org.apache.xerces.dom.NodeImpl: boolean isOwned()>
<org.apache.xerces.dom.NodeImpl: boolean isReadOnly()>
<org.apache.xerces.dom.NodeImpl: boolean needsSyncChildren()>
<org.apache.xerces.dom.NodeImpl: boolean needsSyncData()>
<org.apache.xerces.dom.NodeImpl: int changes()>
<org.apache.xerces.dom.NodeImpl: java.lang.String getLocalName()>
<org.apache.xerces.dom.NodeImpl: java.lang.String getNamespaceURI()>
<org.apache.xerces.dom.NodeImpl: org.apache.xerces.dom.CoreDocumentImpl ownerDocument()>
<org.apache.xerces.dom.NodeImpl: org.w3c.dom.Document getOwnerDocument()>
<org.apache.xerces.dom.NodeImpl: org.w3c.dom.Node appendChild(org.w3c.dom.Node)>
<org.apache.xerces.dom.NodeImpl: void <init>(org.apache.xerces.dom.CoreDocumentImpl)>
<org.apache.xerces.dom.NodeImpl: void changed()>
<org.apache.xerces.dom.NodeImpl: void hasStringValue(boolean)>
<org.apache.xerces.dom.NodeImpl: void isFirstChild(boolean)>
<org.apache.xerces.dom.NodeImpl: void isIdAttribute(boolean)>
<org.apache.xerces.dom.NodeImpl: void isNormalized(boolean)>
<org.apache.xerces.dom.NodeImpl: void isOwned(boolean)>
<org.apache.xerces.dom.NodeImpl: void isSpecified(boolean)>
<org.apache.xerces.dom.NodeImpl: void needsSyncChildren(boolean)>
<org.apache.xerces.dom.NodeImpl: void needsSyncData(boolean)>
<org.apache.xerces.dom.NodeListCache: void <init>(org.apache.xerces.dom.ParentNode)>
<org.apache.xerces.dom.ParentNode: boolean hasChildNodes()>
<org.apache.xerces.dom.ParentNode: int getLength()>
<org.apache.xerces.dom.ParentNode: int nodeListGetLength()>
<org.apache.xerces.dom.ParentNode: org.apache.xerces.dom.ChildNode lastChild()>
<org.apache.xerces.dom.ParentNode: org.apache.xerces.dom.CoreDocumentImpl ownerDocument()>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.Document getOwnerDocument()>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.Node getFirstChild()>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node)>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.Node internalInsertBefore(org.w3c.dom.Node,org.w3c.dom.Node,boolean)>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.Node item(int)>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.Node nodeListItem(int)>
<org.apache.xerces.dom.ParentNode: org.w3c.dom.NodeList getChildNodes()>
<org.apache.xerces.dom.ParentNode: void <init>(org.apache.xerces.dom.CoreDocumentImpl)>
<org.apache.xerces.dom.ParentNode: void checkNormalizationAfterInsert(org.apache.xerces.dom.ChildNode)>
<org.apache.xerces.dom.ParentNode: void lastChild(org.apache.xerces.dom.ChildNode)>
<org.apache.xerces.dom.TextImpl: short getNodeType()>
<org.apache.xerces.dom.TextImpl: void <init>(org.apache.xerces.dom.CoreDocumentImpl,java.lang.String)>
<org.apache.xerces.impl.Constants$ArrayEnumeration: void <init>(java.lang.Object[])>
<org.apache.xerces.impl.Constants: void <clinit>()>
<org.apache.xerces.impl.XMLDTDScannerImpl: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.XMLDTDScannerImpl: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.XMLDTDScannerImpl: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.XMLDTDScannerImpl: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.XMLDTDScannerImpl: void <clinit>()>
<org.apache.xerces.impl.XMLDTDScannerImpl: void <init>()>
<org.apache.xerces.impl.XMLDTDScannerImpl: void init()>
<org.apache.xerces.impl.XMLDTDScannerImpl: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLDTDScannerImpl: void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)>
<org.apache.xerces.impl.XMLDTDScannerImpl: void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)>
<org.apache.xerces.impl.XMLDTDScannerImpl: void setScannerState(int)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack: org.apache.xerces.xni.QName pushElement(org.apache.xerces.xni.QName)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack: void <init>()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack: void clear()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack: void popElement(org.apache.xerces.xni.QName)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher: boolean dispatch(boolean)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher: void <init>(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: boolean scanDocument(boolean)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: boolean scanStartElement()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: int scanContent()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: int scanEndElement()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void <clinit>()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void <init>()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void scanAttribute(org.apache.xerces.xni.XMLAttributes)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void scanComment()>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void scanPIData(java.lang.String,org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void scanXMLDeclOrTextDecl(boolean)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void setDispatcher(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void setScannerState(int)>
<org.apache.xerces.impl.XMLDocumentFragmentScannerImpl: void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher: boolean elementDepthIsZeroHook()>
<org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher: boolean scanRootElementHook()>
<org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher: void <init>(org.apache.xerces.impl.XMLDocumentScannerImpl)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher: void <init>(org.apache.xerces.impl.XMLDocumentScannerImpl)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher: boolean dispatch(boolean)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher: void <init>(org.apache.xerces.impl.XMLDocumentScannerImpl)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher: boolean dispatch(boolean)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher: void <init>(org.apache.xerces.impl.XMLDocumentScannerImpl)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher: boolean dispatch(boolean)>
<org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher: void <init>(org.apache.xerces.impl.XMLDocumentScannerImpl)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.XMLDocumentScannerImpl: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.XMLDocumentScannerImpl: org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher()>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void <clinit>()>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void <init>()>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.XMLDocumentScannerImpl: void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBuffer: boolean access$300(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBuffer: char[] access$200(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBuffer: void <init>(boolean,int)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool: org.apache.xerces.impl.XMLEntityManager$CharacterBuffer getBuffer(boolean)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool: void <init>(int,int)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool: void <init>(int,int,int)>
<org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool: void init()>
<org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool: void returnToPool(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer)>
<org.apache.xerces.impl.XMLEntityManager$Entity: void <init>()>
<org.apache.xerces.impl.XMLEntityManager$Entity: void <init>(java.lang.String,boolean)>
<org.apache.xerces.impl.XMLEntityManager$Entity: void clear()>
<org.apache.xerces.impl.XMLEntityManager$ExternalEntity: void <init>()>
<org.apache.xerces.impl.XMLEntityManager$ExternalEntity: void clear()>
<org.apache.xerces.impl.XMLEntityManager$RewindableInputStream: int read()>
<org.apache.xerces.impl.XMLEntityManager$RewindableInputStream: int read(byte[],int,int)>
<org.apache.xerces.impl.XMLEntityManager$RewindableInputStream: void <init>(org.apache.xerces.impl.XMLEntityManager,java.io.InputStream)>
<org.apache.xerces.impl.XMLEntityManager$RewindableInputStream: void close()>
<org.apache.xerces.impl.XMLEntityManager$RewindableInputStream: void reset()>
<org.apache.xerces.impl.XMLEntityManager$ScannedEntity: boolean isEncodingExternallySpecified()>
<org.apache.xerces.impl.XMLEntityManager$ScannedEntity: boolean isExternal()>
<org.apache.xerces.impl.XMLEntityManager$ScannedEntity: java.lang.String getExpandedSystemId()>
<org.apache.xerces.impl.XMLEntityManager$ScannedEntity: org.apache.xerces.impl.XMLEntityManager$CharacterBuffer access$000(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)>
<org.apache.xerces.impl.XMLEntityManager$ScannedEntity: void <init>(org.apache.xerces.impl.XMLEntityManager,java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.io.InputStream,java.io.Reader,java.lang.String,boolean,boolean,boolean)>
<org.apache.xerces.impl.XMLEntityManager$ScannedEntity: void setEncodingExternallySpecified(boolean)>
<org.apache.xerces.impl.XMLEntityManager: java.io.Reader createReader(java.io.InputStream,java.lang.String,java.lang.Boolean)>
<org.apache.xerces.impl.XMLEntityManager: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.XMLEntityManager: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.XMLEntityManager: java.lang.Object[] getEncodingName(byte[],int)>
<org.apache.xerces.impl.XMLEntityManager: java.lang.String expandSystemId(java.lang.String,java.lang.String,boolean)>
<org.apache.xerces.impl.XMLEntityManager: java.lang.String setupCurrentEntity(java.lang.String,org.apache.xerces.xni.parser.XMLInputSource,boolean,boolean)>
<org.apache.xerces.impl.XMLEntityManager: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.XMLEntityManager: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.XMLEntityManager: org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool access$100(org.apache.xerces.impl.XMLEntityManager)>
<org.apache.xerces.impl.XMLEntityManager: org.apache.xerces.impl.XMLEntityManager$ScannedEntity getCurrentEntity()>
<org.apache.xerces.impl.XMLEntityManager: org.apache.xerces.impl.XMLEntityScanner getEntityScanner()>
<org.apache.xerces.impl.XMLEntityManager: org.apache.xerces.xni.XMLResourceIdentifier getCurrentResourceIdentifier()>
<org.apache.xerces.impl.XMLEntityManager: void <clinit>()>
<org.apache.xerces.impl.XMLEntityManager: void <init>()>
<org.apache.xerces.impl.XMLEntityManager: void <init>(org.apache.xerces.impl.XMLEntityManager)>
<org.apache.xerces.impl.XMLEntityManager: void closeReaders()>
<org.apache.xerces.impl.XMLEntityManager: void endEntity()>
<org.apache.xerces.impl.XMLEntityManager: void print(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)>
<org.apache.xerces.impl.XMLEntityManager: void reset()>
<org.apache.xerces.impl.XMLEntityManager: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLEntityManager: void setEntityHandler(org.apache.xerces.impl.XMLEntityHandler)>
<org.apache.xerces.impl.XMLEntityManager: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.XMLEntityManager: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.XMLEntityManager: void setScannerVersion(short)>
<org.apache.xerces.impl.XMLEntityManager: void setStandalone(boolean)>
<org.apache.xerces.impl.XMLEntityScanner: boolean load(int,boolean)>
<org.apache.xerces.impl.XMLEntityScanner: boolean scanData(java.lang.String,org.apache.xerces.util.XMLStringBuffer)>
<org.apache.xerces.impl.XMLEntityScanner: boolean scanQName(org.apache.xerces.xni.QName)>
<org.apache.xerces.impl.XMLEntityScanner: boolean skipChar(int)>
<org.apache.xerces.impl.XMLEntityScanner: boolean skipDeclSpaces()>
<org.apache.xerces.impl.XMLEntityScanner: boolean skipSpaces()>
<org.apache.xerces.impl.XMLEntityScanner: boolean skipString(java.lang.String)>
<org.apache.xerces.impl.XMLEntityScanner: int peekChar()>
<org.apache.xerces.impl.XMLEntityScanner: int scanChar()>
<org.apache.xerces.impl.XMLEntityScanner: int scanContent(org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLEntityScanner: int scanLiteral(int,org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLEntityScanner: java.lang.String getEncoding()>
<org.apache.xerces.impl.XMLEntityScanner: java.lang.String getExpandedSystemId()>
<org.apache.xerces.impl.XMLEntityScanner: java.lang.String scanNCName()>
<org.apache.xerces.impl.XMLEntityScanner: java.lang.String scanName()>
<org.apache.xerces.impl.XMLEntityScanner: void <init>()>
<org.apache.xerces.impl.XMLEntityScanner: void reset(org.apache.xerces.util.SymbolTable,org.apache.xerces.impl.XMLEntityManager,org.apache.xerces.impl.XMLErrorReporter)>
<org.apache.xerces.impl.XMLEntityScanner: void setCurrentEntity(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)>
<org.apache.xerces.impl.XMLEntityScanner: void setEncoding(java.lang.String)>
<org.apache.xerces.impl.XMLEntityScanner: void setXMLVersion(java.lang.String)>
<org.apache.xerces.impl.XMLErrorReporter: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.XMLErrorReporter: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.XMLErrorReporter: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.XMLErrorReporter: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.XMLErrorReporter: java.util.Locale getLocale()>
<org.apache.xerces.impl.XMLErrorReporter: org.apache.xerces.util.MessageFormatter getMessageFormatter(java.lang.String)>
<org.apache.xerces.impl.XMLErrorReporter: void <clinit>()>
<org.apache.xerces.impl.XMLErrorReporter: void <init>()>
<org.apache.xerces.impl.XMLErrorReporter: void putMessageFormatter(java.lang.String,org.apache.xerces.util.MessageFormatter)>
<org.apache.xerces.impl.XMLErrorReporter: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLErrorReporter: void setDocumentLocator(org.apache.xerces.xni.XMLLocator)>
<org.apache.xerces.impl.XMLErrorReporter: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.XMLErrorReporter: void setLocale(java.util.Locale)>
<org.apache.xerces.impl.XMLErrorReporter: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher: boolean scanRootElementHook()>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher: void <init>(org.apache.xerces.impl.XMLNSDocumentScannerImpl)>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher: void reconfigurePipeline()>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: boolean scanStartElement()>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: int scanEndElement()>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher()>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: org.apache.xerces.impl.dtd.XMLDTDValidatorFilter access$000(org.apache.xerces.impl.XMLNSDocumentScannerImpl)>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: void <init>()>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: void scanAttribute(org.apache.xerces.util.XMLAttributesImpl)>
<org.apache.xerces.impl.XMLNSDocumentScannerImpl: void setDTDValidator(org.apache.xerces.impl.dtd.XMLDTDValidatorFilter)>
<org.apache.xerces.impl.XMLScanner: boolean isInvalidLiteral(int)>
<org.apache.xerces.impl.XMLScanner: boolean isValidNameStartChar(int)>
<org.apache.xerces.impl.XMLScanner: boolean scanAttributeValue(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,java.lang.String,boolean,java.lang.String)>
<org.apache.xerces.impl.XMLScanner: boolean versionSupported(java.lang.String)>
<org.apache.xerces.impl.XMLScanner: int isUnchangedByNormalization(org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLScanner: java.lang.String scanPseudoAttribute(boolean,org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLScanner: void <clinit>()>
<org.apache.xerces.impl.XMLScanner: void <init>()>
<org.apache.xerces.impl.XMLScanner: void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.XMLScanner: void init()>
<org.apache.xerces.impl.XMLScanner: void normalizeWhitespace(org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLScanner: void normalizeWhitespace(org.apache.xerces.xni.XMLString,int)>
<org.apache.xerces.impl.XMLScanner: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLScanner: void scanComment(org.apache.xerces.util.XMLStringBuffer)>
<org.apache.xerces.impl.XMLScanner: void scanPI()>
<org.apache.xerces.impl.XMLScanner: void scanPIData(java.lang.String,org.apache.xerces.xni.XMLString)>
<org.apache.xerces.impl.XMLScanner: void scanXMLDeclOrTextDecl(boolean,java.lang.String[])>
<org.apache.xerces.impl.XMLScanner: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.XMLScanner: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.XMLScanner: void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.XMLVersionDetector: short determineDocVersion(org.apache.xerces.xni.parser.XMLInputSource)>
<org.apache.xerces.impl.XMLVersionDetector: void <clinit>()>
<org.apache.xerces.impl.XMLVersionDetector: void <init>()>
<org.apache.xerces.impl.XMLVersionDetector: void fixupCurrentEntity(org.apache.xerces.impl.XMLEntityManager,char[],int)>
<org.apache.xerces.impl.XMLVersionDetector: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.XMLVersionDetector: void startDocumentParsing(org.apache.xerces.impl.XMLEntityHandler,short)>
<org.apache.xerces.impl.dtd.DTDGrammarBucket: void <init>()>
<org.apache.xerces.impl.dtd.DTDGrammarBucket: void clear()>
<org.apache.xerces.impl.dtd.DTDGrammarBucket: void setStandalone(boolean)>
<org.apache.xerces.impl.dtd.XMLAttributeDecl: void <init>()>
<org.apache.xerces.impl.dtd.XMLDTDDescription: void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void <clinit>()>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void <init>()>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void reset()>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.dtd.XMLDTDProcessor: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: boolean handleStartElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: boolean hasGrammar()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: boolean validate()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: java.lang.Boolean getFeatureDefault(java.lang.String)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: java.lang.Object getPropertyDefault(java.lang.String)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: java.lang.String[] getRecognizedFeatures()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: java.lang.String[] getRecognizedProperties()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: org.apache.xerces.impl.dtd.DTDGrammarBucket getGrammarBucket()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: org.apache.xerces.xni.parser.XMLDocumentSource getDocumentSource()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void <clinit>()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void <init>()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void init()>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void reset(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void rootElementSpecified(org.apache.xerces.xni.QName)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.dtd.XMLDTDValidator: void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.impl.dtd.XMLElementDecl: void <init>()>
<org.apache.xerces.impl.dtd.XMLEntityDecl: void <init>()>
<org.apache.xerces.impl.dtd.XMLNSDTDValidator: void <init>()>
<org.apache.xerces.impl.dtd.XMLSimpleType: void <init>()>
<org.apache.xerces.impl.dv.DTDDVFactory: org.apache.xerces.impl.dv.DTDDVFactory getInstance()>
<org.apache.xerces.impl.dv.DTDDVFactory: org.apache.xerces.impl.dv.DTDDVFactory getInstance(java.lang.String)>
<org.apache.xerces.impl.dv.DTDDVFactory: void <init>()>
<org.apache.xerces.impl.dv.ObjectFactory: java.lang.Class findProviderClass(java.lang.String,java.lang.ClassLoader,boolean)>
<org.apache.xerces.impl.dv.ObjectFactory: java.lang.ClassLoader findClassLoader()>
<org.apache.xerces.impl.dv.ObjectFactory: java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean)>
<org.apache.xerces.impl.dv.ObjectFactory: void <clinit>()>
<org.apache.xerces.impl.dv.SecuritySupport$1: java.lang.Object run()>
<org.apache.xerces.impl.dv.SecuritySupport$1: void <init>(org.apache.xerces.impl.dv.SecuritySupport)>
<org.apache.xerces.impl.dv.SecuritySupport$2: java.lang.Object run()>
<org.apache.xerces.impl.dv.SecuritySupport$2: void <init>(org.apache.xerces.impl.dv.SecuritySupport)>
<org.apache.xerces.impl.dv.SecuritySupport$3: java.lang.Object run()>
<org.apache.xerces.impl.dv.SecuritySupport$3: void <init>(org.apache.xerces.impl.dv.SecuritySupport,java.lang.ClassLoader)>
<org.apache.xerces.impl.dv.SecuritySupport: java.lang.ClassLoader getContextClassLoader()>
<org.apache.xerces.impl.dv.SecuritySupport: java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader)>
<org.apache.xerces.impl.dv.SecuritySupport: java.lang.ClassLoader getSystemClassLoader()>
<org.apache.xerces.impl.dv.SecuritySupport: org.apache.xerces.impl.dv.SecuritySupport getInstance()>
<org.apache.xerces.impl.dv.SecuritySupport: void <clinit>()>
<org.apache.xerces.impl.dv.SecuritySupport: void <init>()>
<org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl: void <clinit>()>
<org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl: void <init>()>
<org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl: void createBuiltInTypes()>
<org.apache.xerces.impl.dv.dtd.ENTITYDatatypeValidator: void <init>()>
<org.apache.xerces.impl.dv.dtd.IDDatatypeValidator: void <init>()>
<org.apache.xerces.impl.dv.dtd.IDREFDatatypeValidator: void <init>()>
<org.apache.xerces.impl.dv.dtd.ListDatatypeValidator: void <init>(org.apache.xerces.impl.dv.DatatypeValidator)>
<org.apache.xerces.impl.dv.dtd.NMTOKENDatatypeValidator: void <init>()>
<org.apache.xerces.impl.dv.dtd.NOTATIONDatatypeValidator: void <init>()>
<org.apache.xerces.impl.dv.dtd.StringDatatypeValidator: void <init>()>
<org.apache.xerces.impl.io.UTF8Reader: int read(char[],int,int)>
<org.apache.xerces.impl.io.UTF8Reader: void <init>(java.io.InputStream,int,org.apache.xerces.util.MessageFormatter,java.util.Locale)>
<org.apache.xerces.impl.io.UTF8Reader: void close()>
<org.apache.xerces.impl.msg.XMLMessageFormatter: void <init>()>
<org.apache.xerces.impl.validation.ValidationManager: void <init>()>
<org.apache.xerces.impl.validation.ValidationManager: void addValidationState(org.apache.xerces.impl.validation.ValidationState)>
<org.apache.xerces.impl.validation.ValidationManager: void reset()>
<org.apache.xerces.impl.validation.ValidationManager: void setEntityState(org.apache.xerces.impl.validation.EntityState)>
<org.apache.xerces.impl.validation.ValidationManager: void setGrammarFound(boolean)>
<org.apache.xerces.impl.validation.ValidationState: void <clinit>()>
<org.apache.xerces.impl.validation.ValidationState: void <init>()>
<org.apache.xerces.impl.validation.ValidationState: void resetIDTables()>
<org.apache.xerces.impl.validation.ValidationState: void setEntityState(org.apache.xerces.impl.validation.EntityState)>
<org.apache.xerces.impl.validation.ValidationState: void setUsingNamespaces(boolean)>
<org.apache.xerces.jaxp.DocumentBuilderFactoryImpl: boolean isXIncludeAware()>
<org.apache.xerces.jaxp.DocumentBuilderFactoryImpl: javax.xml.parsers.DocumentBuilder newDocumentBuilder()>
<org.apache.xerces.jaxp.DocumentBuilderFactoryImpl: javax.xml.validation.Schema getSchema()>
<org.apache.xerces.jaxp.DocumentBuilderFactoryImpl: void <init>()>
<org.apache.xerces.jaxp.DocumentBuilderImpl: org.w3c.dom.Document newDocument()>
<org.apache.xerces.jaxp.DocumentBuilderImpl: org.w3c.dom.Document parse(org.xml.sax.InputSource)>
<org.apache.xerces.jaxp.DocumentBuilderImpl: void <init>(org.apache.xerces.jaxp.DocumentBuilderFactoryImpl,java.util.Hashtable,java.util.Hashtable,boolean)>
<org.apache.xerces.jaxp.DocumentBuilderImpl: void setDocumentBuilderFactoryAttributes(java.util.Hashtable)>
<org.apache.xerces.jaxp.DocumentBuilderImpl: void setErrorHandler(org.xml.sax.ErrorHandler)>
<org.apache.xerces.jaxp.DocumentBuilderImpl: void setFeatures(java.util.Hashtable)>
<org.apache.xerces.jaxp.SAXParserFactoryImpl: boolean isXIncludeAware()>
<org.apache.xerces.jaxp.SAXParserFactoryImpl: javax.xml.parsers.SAXParser newSAXParser()>
<org.apache.xerces.jaxp.SAXParserFactoryImpl: javax.xml.validation.Schema getSchema()>
<org.apache.xerces.jaxp.SAXParserFactoryImpl: org.apache.xerces.jaxp.SAXParserImpl newSAXParserImpl()>
<org.apache.xerces.jaxp.SAXParserFactoryImpl: void <init>()>
<org.apache.xerces.jaxp.SAXParserFactoryImpl: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser: void <init>(org.apache.xerces.jaxp.SAXParserImpl)>
<org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser: void parse(org.xml.sax.InputSource)>
<org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser: void setFeature0(java.lang.String,boolean)>
<org.apache.xerces.jaxp.SAXParserImpl: org.apache.xerces.xni.parser.XMLComponent access$000(org.apache.xerces.jaxp.SAXParserImpl)>
<org.apache.xerces.jaxp.SAXParserImpl: void <init>(org.apache.xerces.jaxp.SAXParserFactoryImpl,java.util.Hashtable)>
<org.apache.xerces.jaxp.SAXParserImpl: void <init>(org.apache.xerces.jaxp.SAXParserFactoryImpl,java.util.Hashtable,boolean)>
<org.apache.xerces.jaxp.SAXParserImpl: void parse(org.xml.sax.InputSource,org.xml.sax.helpers.DefaultHandler)>
<org.apache.xerces.jaxp.SAXParserImpl: void setFeatures(java.util.Hashtable)>
<org.apache.xerces.parsers.AbstractDOMParser: org.w3c.dom.Document getDocument()>
<org.apache.xerces.parsers.AbstractDOMParser: void <clinit>()>
<org.apache.xerces.parsers.AbstractDOMParser: void <init>(org.apache.xerces.xni.parser.XMLParserConfiguration)>
<org.apache.xerces.parsers.AbstractDOMParser: void characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractDOMParser: void emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractDOMParser: void endDocument(org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractDOMParser: void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractDOMParser: void reset()>
<org.apache.xerces.parsers.AbstractDOMParser: void setDocumentClassName(java.lang.String)>
<org.apache.xerces.parsers.AbstractDOMParser: void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractDOMParser: void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractDOMParser: void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: int getLength()>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: java.lang.String getLocalName(int)>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: java.lang.String getValue(int)>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: java.lang.String getValue(java.lang.String)>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: java.lang.String getValue(java.lang.String,java.lang.String)>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: void <init>()>
<org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy: void setAttributes(org.apache.xerces.xni.XMLAttributes)>
<org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy: void <init>(org.apache.xerces.parsers.AbstractSAXParser,org.apache.xerces.xni.XMLLocator)>
<org.apache.xerces.parsers.AbstractSAXParser: org.xml.sax.EntityResolver getEntityResolver()>
<org.apache.xerces.parsers.AbstractSAXParser: org.xml.sax.ErrorHandler getErrorHandler()>
<org.apache.xerces.parsers.AbstractSAXParser: void <clinit>()>
<org.apache.xerces.parsers.AbstractSAXParser: void <init>(org.apache.xerces.xni.parser.XMLParserConfiguration)>
<org.apache.xerces.parsers.AbstractSAXParser: void characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void endDocument(org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void endNamespaceMapping()>
<org.apache.xerces.parsers.AbstractSAXParser: void parse(org.xml.sax.InputSource)>
<org.apache.xerces.parsers.AbstractSAXParser: void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void reset()>
<org.apache.xerces.parsers.AbstractSAXParser: void setContentHandler(org.xml.sax.ContentHandler)>
<org.apache.xerces.parsers.AbstractSAXParser: void setDTDHandler(org.xml.sax.DTDHandler)>
<org.apache.xerces.parsers.AbstractSAXParser: void setDocumentHandler(org.xml.sax.DocumentHandler)>
<org.apache.xerces.parsers.AbstractSAXParser: void setEntityResolver(org.xml.sax.EntityResolver)>
<org.apache.xerces.parsers.AbstractSAXParser: void setErrorHandler(org.xml.sax.ErrorHandler)>
<org.apache.xerces.parsers.AbstractSAXParser: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.parsers.AbstractSAXParser: void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractSAXParser: void startNamespaceMapping()>
<org.apache.xerces.parsers.AbstractSAXParser: void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractXMLDocumentParser: void <init>(org.apache.xerces.xni.parser.XMLParserConfiguration)>
<org.apache.xerces.parsers.AbstractXMLDocumentParser: void emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations)>
<org.apache.xerces.parsers.AbstractXMLDocumentParser: void reset()>
<org.apache.xerces.parsers.AbstractXMLDocumentParser: void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)>
<org.apache.xerces.parsers.AbstractXMLDocumentParser: void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)>
<org.apache.xerces.parsers.AbstractXMLDocumentParser: void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)>
<org.apache.xerces.parsers.DOMParser: org.xml.sax.EntityResolver getEntityResolver()>
<org.apache.xerces.parsers.DOMParser: org.xml.sax.ErrorHandler getErrorHandler()>
<org.apache.xerces.parsers.DOMParser: void <clinit>()>
<org.apache.xerces.parsers.DOMParser: void <init>()>
<org.apache.xerces.parsers.DOMParser: void <init>(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool)>
<org.apache.xerces.parsers.DOMParser: void parse(org.xml.sax.InputSource)>
<org.apache.xerces.parsers.DOMParser: void setErrorHandler(org.xml.sax.ErrorHandler)>
<org.apache.xerces.parsers.DOMParser: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.parsers.ObjectFactory: java.lang.Class class$(java.lang.String)>
<org.apache.xerces.parsers.ObjectFactory: java.lang.Class findProviderClass(java.lang.String,java.lang.ClassLoader,boolean)>
<org.apache.xerces.parsers.ObjectFactory: java.lang.ClassLoader findClassLoader()>
<org.apache.xerces.parsers.ObjectFactory: java.lang.Object createObject(java.lang.String,java.lang.String)>
<org.apache.xerces.parsers.ObjectFactory: java.lang.Object createObject(java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.parsers.ObjectFactory: java.lang.Object findJarServiceProvider(java.lang.String)>
<org.apache.xerces.parsers.ObjectFactory: java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean)>
<org.apache.xerces.parsers.ObjectFactory: void <clinit>()>
<org.apache.xerces.parsers.SAXParser: void <clinit>()>
<org.apache.xerces.parsers.SAXParser: void <init>()>
<org.apache.xerces.parsers.SAXParser: void <init>(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool)>
<org.apache.xerces.parsers.SecuritySupport$1: java.lang.Object run()>
<org.apache.xerces.parsers.SecuritySupport$1: void <init>(org.apache.xerces.parsers.SecuritySupport)>
<org.apache.xerces.parsers.SecuritySupport$2: java.lang.Object run()>
<org.apache.xerces.parsers.SecuritySupport$2: void <init>(org.apache.xerces.parsers.SecuritySupport)>
<org.apache.xerces.parsers.SecuritySupport$3: java.lang.Object run()>
<org.apache.xerces.parsers.SecuritySupport$3: void <init>(org.apache.xerces.parsers.SecuritySupport,java.lang.ClassLoader)>
<org.apache.xerces.parsers.SecuritySupport$4: java.lang.Object run()>
<org.apache.xerces.parsers.SecuritySupport$4: void <init>(org.apache.xerces.parsers.SecuritySupport,java.lang.String)>
<org.apache.xerces.parsers.SecuritySupport$6: java.lang.Object run()>
<org.apache.xerces.parsers.SecuritySupport$6: void <init>(org.apache.xerces.parsers.SecuritySupport,java.lang.ClassLoader,java.lang.String)>
<org.apache.xerces.parsers.SecuritySupport$7: java.lang.Object run()>
<org.apache.xerces.parsers.SecuritySupport$7: void <init>(org.apache.xerces.parsers.SecuritySupport,java.io.File)>
<org.apache.xerces.parsers.SecuritySupport: boolean getFileExists(java.io.File)>
<org.apache.xerces.parsers.SecuritySupport: java.io.InputStream getResourceAsStream(java.lang.ClassLoader,java.lang.String)>
<org.apache.xerces.parsers.SecuritySupport: java.lang.ClassLoader getContextClassLoader()>
<org.apache.xerces.parsers.SecuritySupport: java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader)>
<org.apache.xerces.parsers.SecuritySupport: java.lang.ClassLoader getSystemClassLoader()>
<org.apache.xerces.parsers.SecuritySupport: java.lang.String getSystemProperty(java.lang.String)>
<org.apache.xerces.parsers.SecuritySupport: org.apache.xerces.parsers.SecuritySupport getInstance()>
<org.apache.xerces.parsers.SecuritySupport: void <clinit>()>
<org.apache.xerces.parsers.SecuritySupport: void <init>()>
<org.apache.xerces.parsers.XIncludeAwareParserConfiguration: boolean getFeature(java.lang.String)>
<org.apache.xerces.parsers.XIncludeAwareParserConfiguration: void <init>()>
<org.apache.xerces.parsers.XIncludeAwareParserConfiguration: void <init>(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool,org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.parsers.XIncludeAwareParserConfiguration: void configurePipeline()>
<org.apache.xerces.parsers.XIncludeAwareParserConfiguration: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.parsers.XML11Configuration: boolean getFeature0(java.lang.String)>
<org.apache.xerces.parsers.XML11Configuration: boolean parse(boolean)>
<org.apache.xerces.parsers.XML11Configuration: void <init>(org.apache.xerces.util.SymbolTable,org.apache.xerces.xni.grammars.XMLGrammarPool,org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.parsers.XML11Configuration: void addCommonComponent(org.apache.xerces.xni.parser.XMLComponent)>
<org.apache.xerces.parsers.XML11Configuration: void addComponent(org.apache.xerces.xni.parser.XMLComponent)>
<org.apache.xerces.parsers.XML11Configuration: void addRecognizedParamsAndSetDefaults(org.apache.xerces.xni.parser.XMLComponent)>
<org.apache.xerces.parsers.XML11Configuration: void checkFeature(java.lang.String)>
<org.apache.xerces.parsers.XML11Configuration: void checkProperty(java.lang.String)>
<org.apache.xerces.parsers.XML11Configuration: void cleanup()>
<org.apache.xerces.parsers.XML11Configuration: void configurePipeline()>
<org.apache.xerces.parsers.XML11Configuration: void parse(org.apache.xerces.xni.parser.XMLInputSource)>
<org.apache.xerces.parsers.XML11Configuration: void reset()>
<org.apache.xerces.parsers.XML11Configuration: void resetCommon()>
<org.apache.xerces.parsers.XML11Configuration: void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)>
<org.apache.xerces.parsers.XML11Configuration: void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)>
<org.apache.xerces.parsers.XML11Configuration: void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)>
<org.apache.xerces.parsers.XML11Configuration: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.parsers.XML11Configuration: void setInputSource(org.apache.xerces.xni.parser.XMLInputSource)>
<org.apache.xerces.parsers.XML11Configuration: void setLocale(java.util.Locale)>
<org.apache.xerces.parsers.XML11Configuration: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.parsers.XMLParser: void <clinit>()>
<org.apache.xerces.parsers.XMLParser: void <init>(org.apache.xerces.xni.parser.XMLParserConfiguration)>
<org.apache.xerces.parsers.XMLParser: void parse(org.apache.xerces.xni.parser.XMLInputSource)>
<org.apache.xerces.parsers.XMLParser: void reset()>
<org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer: void <init>(org.apache.xerces.util.AugmentationsImpl)>
<org.apache.xerces.util.AugmentationsImpl$SmallContainer: java.lang.Object getItem(java.lang.Object)>
<org.apache.xerces.util.AugmentationsImpl$SmallContainer: void <init>(org.apache.xerces.util.AugmentationsImpl)>
<org.apache.xerces.util.AugmentationsImpl$SmallContainer: void clear()>
<org.apache.xerces.util.AugmentationsImpl: java.lang.Object getItem(java.lang.String)>
<org.apache.xerces.util.AugmentationsImpl: void <init>()>
<org.apache.xerces.util.AugmentationsImpl: void removeAllItems()>
<org.apache.xerces.util.EntityResolverWrapper: void <init>(org.xml.sax.EntityResolver)>
<org.apache.xerces.util.EntityResolverWrapper: void setEntityResolver(org.xml.sax.EntityResolver)>
<org.apache.xerces.util.ErrorHandlerWrapper: void <init>(org.xml.sax.ErrorHandler)>
<org.apache.xerces.util.ErrorHandlerWrapper: void setErrorHandler(org.xml.sax.ErrorHandler)>
<org.apache.xerces.util.NamespaceSupport: int getDeclaredPrefixCount()>
<org.apache.xerces.util.NamespaceSupport: java.lang.String getURI(java.lang.String)>
<org.apache.xerces.util.NamespaceSupport: void <init>()>
<org.apache.xerces.util.NamespaceSupport: void popContext()>
<org.apache.xerces.util.NamespaceSupport: void pushContext()>
<org.apache.xerces.util.NamespaceSupport: void reset()>
<org.apache.xerces.util.ParserConfigurationSettings: boolean getFeature(java.lang.String)>
<org.apache.xerces.util.ParserConfigurationSettings: java.lang.Object getProperty(java.lang.String)>
<org.apache.xerces.util.ParserConfigurationSettings: void <init>(org.apache.xerces.xni.parser.XMLComponentManager)>
<org.apache.xerces.util.ParserConfigurationSettings: void addRecognizedFeatures(java.lang.String[])>
<org.apache.xerces.util.ParserConfigurationSettings: void addRecognizedProperties(java.lang.String[])>
<org.apache.xerces.util.ParserConfigurationSettings: void checkFeature(java.lang.String)>
<org.apache.xerces.util.ParserConfigurationSettings: void checkProperty(java.lang.String)>
<org.apache.xerces.util.ParserConfigurationSettings: void setFeature(java.lang.String,boolean)>
<org.apache.xerces.util.ParserConfigurationSettings: void setProperty(java.lang.String,java.lang.Object)>
<org.apache.xerces.util.SymbolTable$Entry: void <init>(char[],int,int,org.apache.xerces.util.SymbolTable$Entry)>
<org.apache.xerces.util.SymbolTable: int hash(char[],int,int)>
<org.apache.xerces.util.SymbolTable: java.lang.String addSymbol(char[],int,int)>
<org.apache.xerces.util.SymbolTable: void <init>()>
<org.apache.xerces.util.SymbolTable: void <init>(int,float)>
<org.apache.xerces.util.XMLAttributesImpl$Attribute: void <init>()>
<org.apache.xerces.util.XMLAttributesImpl: boolean isSpecified(int)>
<org.apache.xerces.util.XMLAttributesImpl: int addAttribute(org.apache.xerces.xni.QName,java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: int getIndex(java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: int getIndex(java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: int getIndexFast(java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: int getLength()>
<org.apache.xerces.util.XMLAttributesImpl: java.lang.String getLocalName(int)>
<org.apache.xerces.util.XMLAttributesImpl: java.lang.String getQName(int)>
<org.apache.xerces.util.XMLAttributesImpl: java.lang.String getURI(int)>
<org.apache.xerces.util.XMLAttributesImpl: java.lang.String getValue(int)>
<org.apache.xerces.util.XMLAttributesImpl: java.lang.String getValue(java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: java.lang.String getValue(java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: org.apache.xerces.xni.Augmentations getAugmentations(int)>
<org.apache.xerces.util.XMLAttributesImpl: org.apache.xerces.xni.QName checkDuplicatesNS()>
<org.apache.xerces.util.XMLAttributesImpl: void <init>()>
<org.apache.xerces.util.XMLAttributesImpl: void <init>(int)>
<org.apache.xerces.util.XMLAttributesImpl: void addAttributeNS(org.apache.xerces.xni.QName,java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLAttributesImpl: void getName(int,org.apache.xerces.xni.QName)>
<org.apache.xerces.util.XMLAttributesImpl: void removeAllAttributes()>
<org.apache.xerces.util.XMLAttributesImpl: void setNamespaces(boolean)>
<org.apache.xerces.util.XMLAttributesImpl: void setSpecified(int,boolean)>
<org.apache.xerces.util.XMLAttributesImpl: void setValue(int,java.lang.String)>
<org.apache.xerces.util.XMLChar: boolean isContent(int)>
<org.apache.xerces.util.XMLChar: boolean isHighSurrogate(int)>
<org.apache.xerces.util.XMLChar: boolean isInvalid(int)>
<org.apache.xerces.util.XMLChar: boolean isNCName(int)>
<org.apache.xerces.util.XMLChar: boolean isNCNameStart(int)>
<org.apache.xerces.util.XMLChar: boolean isName(int)>
<org.apache.xerces.util.XMLChar: boolean isNameStart(int)>
<org.apache.xerces.util.XMLChar: boolean isSpace(int)>
<org.apache.xerces.util.XMLChar: boolean isValid(int)>
<org.apache.xerces.util.XMLChar: boolean isValidName(java.lang.String)>
<org.apache.xerces.util.XMLChar: void <clinit>()>
<org.apache.xerces.util.XMLResourceIdentifierImpl: java.lang.String getExpandedSystemId()>
<org.apache.xerces.util.XMLResourceIdentifierImpl: void <init>()>
<org.apache.xerces.util.XMLResourceIdentifierImpl: void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLResourceIdentifierImpl: void clear()>
<org.apache.xerces.util.XMLResourceIdentifierImpl: void setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLResourceIdentifierImpl: void setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.util.XMLStringBuffer: void <init>()>
<org.apache.xerces.util.XMLStringBuffer: void <init>(int)>
<org.apache.xerces.util.XMLStringBuffer: void append(char)>
<org.apache.xerces.util.XMLStringBuffer: void append(char[],int,int)>
<org.apache.xerces.util.XMLStringBuffer: void append(org.apache.xerces.xni.XMLString)>
<org.apache.xerces.util.XMLStringBuffer: void clear()>
<org.apache.xerces.util.XMLSymbols: void <clinit>()>
<org.apache.xerces.xni.NamespaceContext: void <clinit>()>
<org.apache.xerces.xni.QName: void <init>()>
<org.apache.xerces.xni.QName: void clear()>
<org.apache.xerces.xni.QName: void setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.xni.QName: void setValues(org.apache.xerces.xni.QName)>
<org.apache.xerces.xni.XMLString: boolean equals(char[],int,int)>
<org.apache.xerces.xni.XMLString: java.lang.String toString()>
<org.apache.xerces.xni.XMLString: void <init>()>
<org.apache.xerces.xni.XMLString: void setValues(char[],int,int)>
<org.apache.xerces.xni.XMLString: void setValues(org.apache.xerces.xni.XMLString)>
<org.apache.xerces.xni.XNIException: java.lang.Exception getException()>
<org.apache.xerces.xni.XNIException: void <init>(java.lang.Exception)>
<org.apache.xerces.xni.parser.XMLInputSource: java.io.InputStream getByteStream()>
<org.apache.xerces.xni.parser.XMLInputSource: java.io.Reader getCharacterStream()>
<org.apache.xerces.xni.parser.XMLInputSource: java.lang.String getBaseSystemId()>
<org.apache.xerces.xni.parser.XMLInputSource: java.lang.String getEncoding()>
<org.apache.xerces.xni.parser.XMLInputSource: java.lang.String getPublicId()>
<org.apache.xerces.xni.parser.XMLInputSource: java.lang.String getSystemId()>
<org.apache.xerces.xni.parser.XMLInputSource: void <init>(java.lang.String,java.lang.String,java.lang.String)>
<org.apache.xerces.xni.parser.XMLInputSource: void setByteStream(java.io.InputStream)>
<org.apache.xerces.xni.parser.XMLInputSource: void setCharacterStream(java.io.Reader)>
<org.apache.xerces.xni.parser.XMLInputSource: void setEncoding(java.lang.String)>
<org.apache.xml.utils.AttList: int getLength()>
<org.apache.xml.utils.AttList: java.lang.String getQName(int)>
<org.apache.xml.utils.AttList: java.lang.String getValue(int)>
<org.apache.xml.utils.AttList: void <init>(org.w3c.dom.NamedNodeMap,org.apache.xpath.DOMHelper)>
<org.apache.xml.utils.BoolStack: boolean isEmpty()>
<org.apache.xml.utils.BoolStack: boolean peekOrFalse()>
<org.apache.xml.utils.BoolStack: boolean peekOrTrue()>
<org.apache.xml.utils.BoolStack: boolean pop()>
<org.apache.xml.utils.BoolStack: boolean push(boolean)>
<org.apache.xml.utils.BoolStack: void <init>()>
<org.apache.xml.utils.BoolStack: void <init>(int)>
<org.apache.xml.utils.BoolStack: void setTop(boolean)>
<org.apache.xml.utils.CharKey: int hashCode()>
<org.apache.xml.utils.CharKey: void <init>()>
<org.apache.xml.utils.CharKey: void <init>(char)>
<org.apache.xml.utils.DefaultErrorHandler: void <init>()>
<org.apache.xml.utils.NSInfo: void <init>(boolean,boolean)>
<org.apache.xml.utils.NSInfo: void <init>(boolean,boolean,int)>
<org.apache.xml.utils.TreeWalker: void <init>(org.xml.sax.ContentHandler,org.apache.xpath.DOMHelper,java.lang.String)>
<org.apache.xml.utils.TreeWalker: void endNode(org.w3c.dom.Node)>
<org.apache.xml.utils.TreeWalker: void startNode(org.w3c.dom.Node)>
<org.apache.xml.utils.TreeWalker: void traverse(org.w3c.dom.Node)>
<org.apache.xml.utils.UnImplNode: void <init>()>
<org.apache.xpath.DOM2Helper: java.lang.String getLocalNameOfNode(org.w3c.dom.Node)>
<org.apache.xpath.DOM2Helper: java.lang.String getNamespaceOfNode(org.w3c.dom.Node)>
<org.apache.xpath.DOM2Helper: void <init>()>
<org.apache.xpath.DOMHelper: java.lang.String getLocalNameOfNode(org.w3c.dom.Node)>
<org.apache.xpath.DOMHelper: void <clinit>()>
<org.apache.xpath.DOMHelper: void <init>()>
<org.eclipse.core.internal.boot.PlatformURLBaseConnection: java.net.URL resolve()>
<org.eclipse.core.internal.boot.PlatformURLBaseConnection: void <init>(java.net.URL)>
<org.eclipse.core.internal.boot.PlatformURLBaseConnection: void startup(java.net.URL)>
<org.eclipse.core.internal.boot.PlatformURLConnection: java.net.URL getResolvedURL()>
<org.eclipse.core.internal.boot.PlatformURLConnection: void <clinit>()>
<org.eclipse.core.internal.boot.PlatformURLConnection: void <init>(java.net.URL)>
<org.eclipse.core.internal.boot.PlatformURLConnection: void setResolvedURL(java.net.URL)>
<org.eclipse.core.internal.boot.PlatformURLHandler: java.net.URLConnection openConnection(java.net.URL)>
<org.eclipse.core.internal.boot.PlatformURLHandler: void <clinit>()>
<org.eclipse.core.internal.boot.PlatformURLHandler: void <init>()>
<org.eclipse.core.internal.boot.PlatformURLHandler: void register(java.lang.String,java.lang.Class)>
<org.eclipse.core.internal.compatibility.PluginActivator: void <init>()>
<org.eclipse.core.internal.compatibility.PluginActivator: void start(org.osgi.framework.BundleContext)>
<org.eclipse.core.internal.content.BasicDescription: org.eclipse.core.runtime.content.IContentType getContentType()>
<org.eclipse.core.internal.content.BasicDescription: void <init>(org.eclipse.core.internal.content.IContentTypeInfo)>
<org.eclipse.core.internal.content.ContentDescription: boolean isRequested(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.content.ContentDescription: boolean isSet()>
<org.eclipse.core.internal.content.ContentDescription: void <init>(org.eclipse.core.runtime.QualifiedName[],org.eclipse.core.internal.content.IContentTypeInfo)>
<org.eclipse.core.internal.content.ContentType: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.content.ContentType: boolean hasFileSpec(java.lang.String,int,boolean)>
<org.eclipse.core.internal.content.ContentType: boolean hasFileSpec(org.eclipse.core.runtime.preferences.IScopeContext,java.lang.String,int)>
<org.eclipse.core.internal.content.ContentType: boolean internalAddFileSpec(java.lang.String,int)>
<org.eclipse.core.internal.content.ContentType: boolean isAlias()>
<org.eclipse.core.internal.content.ContentType: boolean isValid()>
<org.eclipse.core.internal.content.ContentType: byte getValidation()>
<org.eclipse.core.internal.content.ContentType: int describe(org.eclipse.core.runtime.content.IContentDescriber,org.eclipse.core.internal.content.ILazySource,org.eclipse.core.internal.content.ContentDescription)>
<org.eclipse.core.internal.content.ContentType: int hashCode()>
<org.eclipse.core.internal.content.ContentType: java.lang.String basicGetDefaultProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.content.ContentType: java.lang.String getAliasTargetId()>
<org.eclipse.core.internal.content.ContentType: java.lang.String getBaseTypeId()>
<org.eclipse.core.internal.content.ContentType: java.lang.String getDefaultProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.content.ContentType: java.lang.String getId()>
<org.eclipse.core.internal.content.ContentType: java.lang.String internalGetDefaultProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.content.ContentType: java.lang.String[] getFileSpecs(int)>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.internal.content.BasicDescription internalGetDescriptionFor(org.eclipse.core.internal.content.ILazySource,org.eclipse.core.runtime.QualifiedName[])>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.internal.content.ContentType createContentType(org.eclipse.core.internal.content.ContentTypeCatalog,java.lang.String,java.lang.String,byte,java.lang.String[],java.lang.String[],java.lang.String,java.lang.String,java.util.Map,org.eclipse.core.runtime.IConfigurationElement)>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.internal.content.ContentType getAliasTarget(boolean)>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.internal.content.ContentType getContentType()>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.internal.content.ContentTypeCatalog getCatalog()>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.internal.content.FileSpec createFileSpec(java.lang.String,int)>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.runtime.content.IContentDescriber getDescriber()>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.runtime.content.IContentDescription getDefaultDescription()>
<org.eclipse.core.internal.content.ContentType: org.eclipse.core.runtime.content.IContentType getBaseType()>
<org.eclipse.core.internal.content.ContentType: void <clinit>()>
<org.eclipse.core.internal.content.ContentType: void <init>(org.eclipse.core.internal.content.ContentTypeManager)>
<org.eclipse.core.internal.content.ContentType: void setAliasTarget(org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentType: void setBaseType(org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentType: void setValidation(byte)>
<org.eclipse.core.internal.content.ContentTypeBuilder$1: boolean visit(org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.core.internal.content.ContentTypeBuilder$1: void <init>(org.eclipse.core.internal.content.ContentTypeBuilder,org.eclipse.core.runtime.preferences.IEclipsePreferences,org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeBuilder: byte parsePriority(java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeBuilder: java.lang.String getUniqueId(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeBuilder: org.eclipse.core.internal.content.ContentType createContentType(org.eclipse.core.runtime.IConfigurationElement)>
<org.eclipse.core.internal.content.ContentTypeBuilder: org.eclipse.core.runtime.IConfigurationElement[] getConfigurationElements()>
<org.eclipse.core.internal.content.ContentTypeBuilder: org.eclipse.core.runtime.QualifiedName parseQualifiedName(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeBuilder: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeBuilder: void addFileAssociation(org.eclipse.core.runtime.IConfigurationElement,org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentTypeBuilder: void applyPreferences()>
<org.eclipse.core.internal.content.ContentTypeBuilder: void buildCatalog()>
<org.eclipse.core.internal.content.ContentTypeBuilder: void registerContentType(org.eclipse.core.runtime.IConfigurationElement)>
<org.eclipse.core.internal.content.ContentTypeBuilder: void registerFileAssociation(org.eclipse.core.runtime.IConfigurationElement)>
<org.eclipse.core.internal.content.ContentTypeCatalog$1: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeCatalog$2: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeCatalog$3: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeCatalog$4: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeCatalog$5: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeCatalog$6: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog,org.eclipse.core.runtime.content.IContentType[][],org.eclipse.core.runtime.content.IContentTypeManager$ISelectionPolicy,org.eclipse.core.runtime.content.IContentType[],boolean,boolean)>
<org.eclipse.core.internal.content.ContentTypeCatalog$6: void run()>
<org.eclipse.core.internal.content.ContentTypeCatalog$7: int visit(org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentTypeCatalog$7: void <init>(org.eclipse.core.internal.content.ContentTypeCatalog,org.eclipse.core.internal.content.ContentType,org.eclipse.core.runtime.preferences.IScopeContext,java.lang.String,int,java.util.Collection,java.util.Set)>
<org.eclipse.core.internal.content.ContentTypeCatalog: boolean ensureValid(org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentTypeCatalog: boolean internalAccept(org.eclipse.core.internal.content.ContentTypeVisitor,org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentTypeCatalog: int getGeneration()>
<org.eclipse.core.internal.content.ContentTypeCatalog: java.util.Set getDirectlyAssociated(java.lang.String,int)>
<org.eclipse.core.internal.content.ContentTypeCatalog: java.util.Set selectMatchingByName(org.eclipse.core.runtime.preferences.IScopeContext,java.util.Collection,java.util.Collection,java.lang.String,int)>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.internal.content.ContentType internalGetContentType(java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.internal.content.ContentTypeManager getManager()>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.internal.content.ContentType[] getChildren(org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentDescription getDescriptionFor(org.eclipse.core.internal.content.ContentTypeMatcher,java.io.InputStream,java.lang.String,org.eclipse.core.runtime.QualifiedName[])>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentDescription getDescriptionFor(org.eclipse.core.internal.content.ContentTypeMatcher,org.eclipse.core.internal.content.ILazySource,java.lang.String,org.eclipse.core.runtime.QualifiedName[])>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentType[] applyPolicy(org.eclipse.core.runtime.content.IContentTypeManager$ISelectionPolicy,org.eclipse.core.runtime.content.IContentType[],boolean,boolean)>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentType[] concat(org.eclipse.core.runtime.content.IContentType[][])>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentType[] findContentTypesFor(org.eclipse.core.internal.content.ContentTypeMatcher,java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentType[] internalFindContentTypesFor(org.eclipse.core.internal.content.ContentTypeMatcher,org.eclipse.core.internal.content.ILazySource,java.lang.String,boolean)>
<org.eclipse.core.internal.content.ContentTypeCatalog: org.eclipse.core.runtime.content.IContentType[][] internalFindContentTypesFor(org.eclipse.core.internal.content.ContentTypeMatcher,java.lang.String,java.util.Comparator)>
<org.eclipse.core.internal.content.ContentTypeCatalog: void <clinit>()>
<org.eclipse.core.internal.content.ContentTypeCatalog: void <init>(org.eclipse.core.internal.content.ContentTypeManager,int)>
<org.eclipse.core.internal.content.ContentTypeCatalog: void addContentType(org.eclipse.core.runtime.content.IContentType)>
<org.eclipse.core.internal.content.ContentTypeCatalog: void associate(org.eclipse.core.internal.content.ContentType)>
<org.eclipse.core.internal.content.ContentTypeCatalog: void associate(org.eclipse.core.internal.content.ContentType,java.lang.String,int)>
<org.eclipse.core.internal.content.ContentTypeCatalog: void makeAliases()>
<org.eclipse.core.internal.content.ContentTypeCatalog: void organize()>
<org.eclipse.core.internal.content.ContentTypeHandler: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.content.ContentTypeHandler: org.eclipse.core.internal.content.ContentType getTarget()>
<org.eclipse.core.internal.content.ContentTypeHandler: org.eclipse.core.runtime.content.IContentDescription getDefaultDescription()>
<org.eclipse.core.internal.content.ContentTypeHandler: void <init>(org.eclipse.core.internal.content.ContentType,int)>
<org.eclipse.core.internal.content.ContentTypeManager: java.lang.String getFileExtension(java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.internal.content.ContentTypeBuilder createBuilder(org.eclipse.core.internal.content.ContentTypeCatalog)>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.internal.content.ContentTypeCatalog getCatalog()>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.internal.content.ContentTypeManager getInstance()>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.internal.content.ILazySource readBuffer(java.io.InputStream)>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.runtime.content.IContentTypeMatcher getMatcher(org.eclipse.core.runtime.content.IContentTypeManager$ISelectionPolicy,org.eclipse.core.runtime.preferences.IScopeContext)>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.runtime.preferences.IEclipsePreferences getPreferences()>
<org.eclipse.core.internal.content.ContentTypeManager: org.eclipse.core.runtime.preferences.IEclipsePreferences getPreferences(org.eclipse.core.runtime.preferences.IScopeContext)>
<org.eclipse.core.internal.content.ContentTypeManager: void <clinit>()>
<org.eclipse.core.internal.content.ContentTypeManager: void <init>()>
<org.eclipse.core.internal.content.ContentTypeManager: void addContentTypeChangeListener(org.eclipse.core.runtime.content.IContentTypeManager$IContentTypeChangeListener)>
<org.eclipse.core.internal.content.ContentTypeManager: void invalidate()>
<org.eclipse.core.internal.content.ContentTypeManager: void registryChanged(org.eclipse.core.runtime.IRegistryChangeEvent)>
<org.eclipse.core.internal.content.ContentTypeManager: void startup()>
<org.eclipse.core.internal.content.ContentTypeMatcher: org.eclipse.core.internal.content.ContentTypeCatalog getCatalog()>
<org.eclipse.core.internal.content.ContentTypeMatcher: org.eclipse.core.runtime.content.IContentDescription getDescriptionFor(java.io.InputStream,java.lang.String,org.eclipse.core.runtime.QualifiedName[])>
<org.eclipse.core.internal.content.ContentTypeMatcher: org.eclipse.core.runtime.content.IContentDescription getSpecificDescription(org.eclipse.core.internal.content.BasicDescription)>
<org.eclipse.core.internal.content.ContentTypeMatcher: org.eclipse.core.runtime.content.IContentType findContentTypeFor(java.lang.String)>
<org.eclipse.core.internal.content.ContentTypeMatcher: org.eclipse.core.runtime.content.IContentTypeManager$ISelectionPolicy getPolicy()>
<org.eclipse.core.internal.content.ContentTypeMatcher: org.eclipse.core.runtime.preferences.IScopeContext getContext()>
<org.eclipse.core.internal.content.ContentTypeMatcher: void <init>(org.eclipse.core.runtime.content.IContentTypeManager$ISelectionPolicy,org.eclipse.core.runtime.preferences.IScopeContext)>
<org.eclipse.core.internal.content.DefaultDescription: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.content.DefaultDescription: java.lang.Object getProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.content.DefaultDescription: java.lang.String getCharset()>
<org.eclipse.core.internal.content.DefaultDescription: void <init>(org.eclipse.core.internal.content.IContentTypeInfo)>
<org.eclipse.core.internal.content.FileSpec: boolean equals(java.lang.String,int,boolean)>
<org.eclipse.core.internal.content.FileSpec: int getBasicType(int)>
<org.eclipse.core.internal.content.FileSpec: int getType()>
<org.eclipse.core.internal.content.FileSpec: java.lang.String getMappingKeyFor(java.lang.String)>
<org.eclipse.core.internal.content.FileSpec: java.lang.String getText()>
<org.eclipse.core.internal.content.FileSpec: void <init>(java.lang.String,int)>
<org.eclipse.core.internal.content.LazyInputStream: boolean isText()>
<org.eclipse.core.internal.content.LazyInputStream: int loadBlock()>
<org.eclipse.core.internal.content.LazyInputStream: int read()>
<org.eclipse.core.internal.content.LazyInputStream: void <init>(java.io.InputStream,int)>
<org.eclipse.core.internal.content.LazyInputStream: void ensureAvailable(long)>
<org.eclipse.core.internal.content.LazyInputStream: void rewind()>
<org.eclipse.core.internal.content.TextContentDescriber: byte[] getByteOrderMark(java.io.InputStream)>
<org.eclipse.core.internal.content.TextContentDescriber: int describe(java.io.InputStream,org.eclipse.core.runtime.content.IContentDescription)>
<org.eclipse.core.internal.content.TextContentDescriber: void <clinit>()>
<org.eclipse.core.internal.content.TextContentDescriber: void <init>()>
<org.eclipse.core.internal.content.Util: java.lang.String[] parseItems(java.lang.String)>
<org.eclipse.core.internal.content.Util: java.lang.String[] parseItems(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.dtree.AbstractDataTree: boolean isImmutable()>
<org.eclipse.core.internal.dtree.AbstractDataTree: org.eclipse.core.runtime.IPath rootKey()>
<org.eclipse.core.internal.dtree.AbstractDataTree: void <clinit>()>
<org.eclipse.core.internal.dtree.AbstractDataTree: void <init>()>
<org.eclipse.core.internal.dtree.AbstractDataTree: void immutable()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: boolean hasData()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: boolean isDeleted()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: boolean isDelta()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: boolean isEmptyDelta()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: int indexOfChild(java.lang.String)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: int size()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: java.lang.String getName()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode assembleWith(org.eclipse.core.internal.dtree.AbstractDataTreeNode)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode assembleWith(org.eclipse.core.internal.dtree.AbstractDataTreeNode,org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode childAtOrNull(java.lang.String)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode convertToAddedComparisonNode(org.eclipse.core.internal.dtree.AbstractDataTreeNode,int)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode convertToRemovedComparisonNode(org.eclipse.core.internal.dtree.AbstractDataTreeNode,int)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode[] assembleWith(org.eclipse.core.internal.dtree.AbstractDataTreeNode[],org.eclipse.core.internal.dtree.AbstractDataTreeNode[],boolean)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode[] compareWithParent(org.eclipse.core.internal.dtree.AbstractDataTreeNode[],org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode[] getChildren()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode[] simplifyWithParent(org.eclipse.core.internal.dtree.AbstractDataTreeNode[],org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: void <clinit>()>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: void <init>(java.lang.String,org.eclipse.core.internal.dtree.AbstractDataTreeNode[])>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: void setName(java.lang.String)>
<org.eclipse.core.internal.dtree.AbstractDataTreeNode: void storeStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.dtree.DataDeltaNode: boolean isDelta()>
<org.eclipse.core.internal.dtree.DataDeltaNode: int type()>
<org.eclipse.core.internal.dtree.DataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode asBackwardDelta(org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode compareWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode copy()>
<org.eclipse.core.internal.dtree.DataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode simplifyWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DataDeltaNode: void <init>(java.lang.String,java.lang.Object)>
<org.eclipse.core.internal.dtree.DataDeltaNode: void <init>(java.lang.String,java.lang.Object,org.eclipse.core.internal.dtree.AbstractDataTreeNode[])>
<org.eclipse.core.internal.dtree.DataTreeLookup: org.eclipse.core.internal.dtree.DataTreeLookup newLookup(org.eclipse.core.runtime.IPath,boolean,java.lang.Object)>
<org.eclipse.core.internal.dtree.DataTreeLookup: org.eclipse.core.internal.dtree.DataTreeLookup newLookup(org.eclipse.core.runtime.IPath,boolean,java.lang.Object,boolean)>
<org.eclipse.core.internal.dtree.DataTreeLookup: void <clinit>()>
<org.eclipse.core.internal.dtree.DataTreeLookup: void <init>()>
<org.eclipse.core.internal.dtree.DataTreeNode: boolean hasData()>
<org.eclipse.core.internal.dtree.DataTreeNode: int type()>
<org.eclipse.core.internal.dtree.DataTreeNode: java.lang.Object getData()>
<org.eclipse.core.internal.dtree.DataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode asBackwardDelta(org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode asReverseComparisonNode(org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode compareWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DataTreeNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode copy()>
<org.eclipse.core.internal.dtree.DataTreeNode: void <init>(java.lang.String,java.lang.Object)>
<org.eclipse.core.internal.dtree.DataTreeNode: void <init>(java.lang.String,java.lang.Object,org.eclipse.core.internal.dtree.AbstractDataTreeNode[])>
<org.eclipse.core.internal.dtree.DataTreeNode: void storeStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.dtree.DataTreeWriter: void <init>(org.eclipse.core.internal.dtree.IDataFlattener)>
<org.eclipse.core.internal.dtree.DataTreeWriter: void writeNode(org.eclipse.core.internal.dtree.AbstractDataTreeNode,org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.dtree.DataTreeWriter: void writeNumber(int)>
<org.eclipse.core.internal.dtree.DataTreeWriter: void writeTree(org.eclipse.core.internal.dtree.AbstractDataTree,org.eclipse.core.runtime.IPath,int,java.io.DataOutput)>
<org.eclipse.core.internal.dtree.DeletedNode: boolean isDeleted()>
<org.eclipse.core.internal.dtree.DeletedNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode asBackwardDelta(org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeletedNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode compareWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DeletedNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode simplifyWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DeletedNode: void <init>(java.lang.String)>
<org.eclipse.core.internal.dtree.DeltaDataTree: boolean hasAncestor(org.eclipse.core.internal.dtree.DeltaDataTree)>
<org.eclipse.core.internal.dtree.DeltaDataTree: boolean includes(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: boolean isEmptyDelta()>
<org.eclipse.core.internal.dtree.DeltaDataTree: java.lang.Object getData(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: java.lang.String[] getNamesOfChildren(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTree copy()>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTreeNode copyCompleteSubtree(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTreeNode getRootNode()>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTreeNode safeCopyCompleteSubtree(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTreeNode safeNaiveCopyCompleteSubtree(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTreeNode searchNodeAt(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.AbstractDataTreeNode[] getChildNodes(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DataTreeLookup lookup(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree asBackwardDelta()>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree asReverseComparisonTree(org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree assembleWithForwardDelta(org.eclipse.core.internal.dtree.DeltaDataTree)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree compareWith(org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree forwardDeltaWith(org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree getParent()>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree newEmptyDeltaTree()>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.internal.dtree.DeltaDataTree reroot()>
<org.eclipse.core.internal.dtree.DeltaDataTree: org.eclipse.core.runtime.IPath[] getChildren(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void <init>()>
<org.eclipse.core.internal.dtree.DeltaDataTree: void <init>(org.eclipse.core.internal.dtree.AbstractDataTreeNode)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void <init>(org.eclipse.core.internal.dtree.AbstractDataTreeNode,org.eclipse.core.internal.dtree.DeltaDataTree)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void addChild(org.eclipse.core.runtime.IPath,java.lang.String,org.eclipse.core.internal.dtree.AbstractDataTreeNode)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void assembleNode(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.AbstractDataTreeNode)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void createChild(org.eclipse.core.runtime.IPath,java.lang.String,java.lang.Object)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void deleteChild(org.eclipse.core.runtime.IPath,java.lang.String)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void empty()>
<org.eclipse.core.internal.dtree.DeltaDataTree: void emptyDelta()>
<org.eclipse.core.internal.dtree.DeltaDataTree: void reroot(org.eclipse.core.internal.dtree.DeltaDataTree)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void setData(org.eclipse.core.runtime.IPath,java.lang.Object)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void setParent(org.eclipse.core.internal.dtree.DeltaDataTree)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void setRootNode(org.eclipse.core.internal.dtree.AbstractDataTreeNode)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void simplify(org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.DeltaDataTree: void storeStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: boolean isDelta()>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: boolean isEmptyDelta()>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode asBackwardDelta(org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode compareWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode copy()>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: org.eclipse.core.internal.dtree.AbstractDataTreeNode simplifyWithParent(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: void <init>(java.lang.String)>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: void <init>(java.lang.String,org.eclipse.core.internal.dtree.AbstractDataTreeNode)>
<org.eclipse.core.internal.dtree.NoDataDeltaNode: void <init>(java.lang.String,org.eclipse.core.internal.dtree.AbstractDataTreeNode[])>
<org.eclipse.core.internal.dtree.NodeComparison: boolean isUnchanged()>
<org.eclipse.core.internal.dtree.NodeComparison: int getUserComparison()>
<org.eclipse.core.internal.dtree.NodeComparison: java.lang.Object getNewData()>
<org.eclipse.core.internal.dtree.NodeComparison: java.lang.Object getOldData()>
<org.eclipse.core.internal.dtree.NodeComparison: org.eclipse.core.internal.dtree.NodeComparison asReverseComparison(org.eclipse.core.internal.dtree.IComparator)>
<org.eclipse.core.internal.dtree.NodeComparison: void <init>(java.lang.Object,java.lang.Object,int,int)>
<org.eclipse.core.internal.events.AutoBuildJob: boolean shouldBuild()>
<org.eclipse.core.internal.events.AutoBuildJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.AutoBuildJob: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.events.AutoBuildJob: void build(boolean)>
<org.eclipse.core.internal.events.AutoBuildJob: void doBuild(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.AutoBuildJob: void forceBuild()>
<org.eclipse.core.internal.events.AutoBuildJob: void interrupt()>
<org.eclipse.core.internal.events.AutoBuildJob: void propertyChange(org.eclipse.core.runtime.Preferences$PropertyChangeEvent)>
<org.eclipse.core.internal.events.BuildCommand: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.events.BuildCommand: boolean isBuilding(int)>
<org.eclipse.core.internal.events.BuildCommand: int maskForTrigger(int)>
<org.eclipse.core.internal.events.BuildCommand: java.lang.Object clone()>
<org.eclipse.core.internal.events.BuildCommand: java.lang.String getBuilderName()>
<org.eclipse.core.internal.events.BuildCommand: java.util.Map getArguments()>
<org.eclipse.core.internal.events.BuildCommand: java.util.Map getArguments(boolean)>
<org.eclipse.core.internal.events.BuildCommand: org.eclipse.core.resources.IncrementalProjectBuilder getBuilder()>
<org.eclipse.core.internal.events.BuildCommand: void <init>()>
<org.eclipse.core.internal.events.BuildCommand: void setArguments(java.util.Map)>
<org.eclipse.core.internal.events.BuildCommand: void setBuilder(org.eclipse.core.resources.IncrementalProjectBuilder)>
<org.eclipse.core.internal.events.BuildManager$1: void <init>(org.eclipse.core.internal.events.BuildManager,org.eclipse.core.resources.IProject,org.eclipse.core.runtime.MultiStatus,int,org.eclipse.core.resources.ICommand[],org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager$1: void run()>
<org.eclipse.core.internal.events.BuildManager$2: void <init>(org.eclipse.core.internal.events.BuildManager,org.eclipse.core.runtime.MultiStatus,int,java.util.Map,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager$2: void run()>
<org.eclipse.core.internal.events.BuildManager$DeltaCache: void <init>(org.eclipse.core.internal.events.BuildManager)>
<org.eclipse.core.internal.events.BuildManager$DeltaCache: void flush()>
<org.eclipse.core.internal.events.BuildManager: boolean canRun(int)>
<org.eclipse.core.internal.events.BuildManager: boolean validateNature(org.eclipse.core.internal.events.InternalBuilder,java.lang.String)>
<org.eclipse.core.internal.events.BuildManager: java.util.ArrayList createBuildersPersistentInfo(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.events.BuildManager: java.util.ArrayList getBuildersPersistentInfo(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.events.BuildManager: org.eclipse.core.internal.resources.WorkManager getWorkManager()>
<org.eclipse.core.internal.events.BuildManager: org.eclipse.core.resources.IncrementalProjectBuilder getBuilder(org.eclipse.core.resources.IProject,org.eclipse.core.resources.ICommand,int,org.eclipse.core.runtime.MultiStatus)>
<org.eclipse.core.internal.events.BuildManager: org.eclipse.core.resources.IncrementalProjectBuilder initializeBuilder(java.lang.String,org.eclipse.core.resources.IProject,int,org.eclipse.core.runtime.MultiStatus)>
<org.eclipse.core.internal.events.BuildManager: org.eclipse.core.resources.IncrementalProjectBuilder instantiateBuilder(java.lang.String)>
<org.eclipse.core.internal.events.BuildManager: org.eclipse.core.runtime.ISafeRunnable getSafeRunnable(int,java.util.Map,org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager: void <init>(org.eclipse.core.internal.resources.Workspace,org.eclipse.core.runtime.jobs.ILock)>
<org.eclipse.core.internal.events.BuildManager: void basicBuild(int,org.eclipse.core.resources.IncrementalProjectBuilder,java.util.Map,org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager: void basicBuild(org.eclipse.core.resources.IProject,int,org.eclipse.core.resources.ICommand[],org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager: void basicBuild(org.eclipse.core.resources.IProject,int,org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager: void build(org.eclipse.core.resources.IProject,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager: void checkCanceled(int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.BuildManager: void endTopLevel(boolean)>
<org.eclipse.core.internal.events.BuildManager: void handleEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.events.BuildManager: void hookEndBuild(int)>
<org.eclipse.core.internal.events.BuildManager: void hookEndBuild(org.eclipse.core.resources.IncrementalProjectBuilder)>
<org.eclipse.core.internal.events.BuildManager: void hookStartBuild(int)>
<org.eclipse.core.internal.events.BuildManager: void hookStartBuild(org.eclipse.core.resources.IncrementalProjectBuilder,int)>
<org.eclipse.core.internal.events.BuildManager: void interrupt()>
<org.eclipse.core.internal.events.BuildManager: void setBuildersPersistentInfo(org.eclipse.core.resources.IProject,java.util.ArrayList)>
<org.eclipse.core.internal.events.BuildManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.InternalBuilder: boolean wasForgetStateRequested()>
<org.eclipse.core.internal.events.InternalBuilder: java.lang.String getLabel()>
<org.eclipse.core.internal.events.InternalBuilder: java.lang.String getNatureId()>
<org.eclipse.core.internal.events.InternalBuilder: org.eclipse.core.internal.watson.ElementTree getLastBuiltTree()>
<org.eclipse.core.internal.events.InternalBuilder: org.eclipse.core.resources.ICommand getCommand()>
<org.eclipse.core.internal.events.InternalBuilder: org.eclipse.core.resources.IProject getProject()>
<org.eclipse.core.internal.events.InternalBuilder: void <clinit>()>
<org.eclipse.core.internal.events.InternalBuilder: void <init>()>
<org.eclipse.core.internal.events.InternalBuilder: void clearForgetLastBuiltState()>
<org.eclipse.core.internal.events.InternalBuilder: void setCommand(org.eclipse.core.resources.ICommand)>
<org.eclipse.core.internal.events.InternalBuilder: void setInterestingProjects(org.eclipse.core.resources.IProject[])>
<org.eclipse.core.internal.events.InternalBuilder: void setLabel(java.lang.String)>
<org.eclipse.core.internal.events.InternalBuilder: void setLastBuiltTree(org.eclipse.core.internal.watson.ElementTree)>
<org.eclipse.core.internal.events.InternalBuilder: void setNatureId(java.lang.String)>
<org.eclipse.core.internal.events.InternalBuilder: void setPluginId(java.lang.String)>
<org.eclipse.core.internal.events.InternalBuilder: void setProject(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.events.LifecycleEvent: org.eclipse.core.internal.events.LifecycleEvent newEvent(int,org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.events.LifecycleEvent: void <clinit>()>
<org.eclipse.core.internal.events.LifecycleEvent: void <init>()>
<org.eclipse.core.internal.events.NodeIDMap: boolean isEmpty()>
<org.eclipse.core.internal.events.NodeIDMap: boolean shouldGrow()>
<org.eclipse.core.internal.events.NodeIDMap: int getIndex(long)>
<org.eclipse.core.internal.events.NodeIDMap: int hashFor(long,int)>
<org.eclipse.core.internal.events.NodeIDMap: org.eclipse.core.runtime.IPath getNewPath(long)>
<org.eclipse.core.internal.events.NodeIDMap: org.eclipse.core.runtime.IPath getOldPath(long)>
<org.eclipse.core.internal.events.NodeIDMap: void <clinit>()>
<org.eclipse.core.internal.events.NodeIDMap: void <init>()>
<org.eclipse.core.internal.events.NodeIDMap: void expand()>
<org.eclipse.core.internal.events.NodeIDMap: void put(long,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.events.NodeIDMap: void putNewPath(long,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.events.NodeIDMap: void putOldPath(long,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.events.NotificationManager$1: void <init>(org.eclipse.core.internal.events.NotificationManager$NotifyJob)>
<org.eclipse.core.internal.events.NotificationManager$2: void <init>(org.eclipse.core.internal.events.NotificationManager,org.eclipse.core.resources.IResourceChangeListener,org.eclipse.core.resources.IResourceChangeEvent)>
<org.eclipse.core.internal.events.NotificationManager$2: void handleException(java.lang.Throwable)>
<org.eclipse.core.internal.events.NotificationManager$2: void run()>
<org.eclipse.core.internal.events.NotificationManager$NotifyJob: void <init>(org.eclipse.core.internal.events.NotificationManager)>
<org.eclipse.core.internal.events.NotificationManager: boolean beginAvoidNotify()>
<org.eclipse.core.internal.events.NotificationManager: boolean shouldNotify()>
<org.eclipse.core.internal.events.NotificationManager: org.eclipse.core.internal.events.ResourceChangeListenerList$ListenerEntry[] getListeners()>
<org.eclipse.core.internal.events.NotificationManager: org.eclipse.core.internal.events.ResourceDelta getDelta(org.eclipse.core.internal.watson.ElementTree,int)>
<org.eclipse.core.internal.events.NotificationManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.events.NotificationManager: void addListener(org.eclipse.core.resources.IResourceChangeListener,int)>
<org.eclipse.core.internal.events.NotificationManager: void beginNotify()>
<org.eclipse.core.internal.events.NotificationManager: void broadcastChanges(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.events.ResourceChangeEvent,boolean)>
<org.eclipse.core.internal.events.NotificationManager: void cleanUp(org.eclipse.core.internal.watson.ElementTree,int)>
<org.eclipse.core.internal.events.NotificationManager: void endAvoidNotify()>
<org.eclipse.core.internal.events.NotificationManager: void handleEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.events.NotificationManager: void notify(org.eclipse.core.internal.events.ResourceChangeListenerList$ListenerEntry[],org.eclipse.core.resources.IResourceChangeEvent,boolean)>
<org.eclipse.core.internal.events.NotificationManager: void requestNotify()>
<org.eclipse.core.internal.events.NotificationManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.events.ResourceChangeEvent: int getType()>
<org.eclipse.core.internal.events.ResourceChangeEvent: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.core.internal.events.ResourceChangeEvent: org.eclipse.core.resources.IResourceDelta getDelta()>
<org.eclipse.core.internal.events.ResourceChangeEvent: void <clinit>()>
<org.eclipse.core.internal.events.ResourceChangeEvent: void <init>(java.lang.Object,int,int,org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.core.internal.events.ResourceChangeEvent: void <init>(java.lang.Object,int,org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.events.ResourceChangeEvent: void setDelta(org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.core.internal.events.ResourceChangeListenerList$ListenerEntry: void <init>(org.eclipse.core.resources.IResourceChangeListener,int)>
<org.eclipse.core.internal.events.ResourceChangeListenerList: boolean hasListenerFor(int)>
<org.eclipse.core.internal.events.ResourceChangeListenerList: org.eclipse.core.internal.events.ResourceChangeListenerList$ListenerEntry[] getListeners()>
<org.eclipse.core.internal.events.ResourceChangeListenerList: void <clinit>()>
<org.eclipse.core.internal.events.ResourceChangeListenerList: void <init>()>
<org.eclipse.core.internal.events.ResourceChangeListenerList: void add(org.eclipse.core.resources.IResourceChangeListener,int)>
<org.eclipse.core.internal.events.ResourceChangeListenerList: void adding(int)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareCharsets(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareContents(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareMarkers(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareNodeIDs(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareOpen(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareSync(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareType(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: boolean compareUsed(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceComparator: int compare(java.lang.Object,java.lang.Object)>
<org.eclipse.core.internal.events.ResourceComparator: org.eclipse.core.internal.events.ResourceComparator getBuildComparator()>
<org.eclipse.core.internal.events.ResourceComparator: org.eclipse.core.internal.events.ResourceComparator getNotificationComparator()>
<org.eclipse.core.internal.events.ResourceComparator: org.eclipse.core.internal.events.ResourceComparator getSaveComparator()>
<org.eclipse.core.internal.events.ResourceComparator: void <clinit>()>
<org.eclipse.core.internal.events.ResourceComparator: void <init>(boolean,boolean)>
<org.eclipse.core.internal.events.ResourceDelta: boolean isPhantom()>
<org.eclipse.core.internal.events.ResourceDelta: boolean isTeamPrivate()>
<org.eclipse.core.internal.events.ResourceDelta: int getFlags()>
<org.eclipse.core.internal.events.ResourceDelta: int getKind()>
<org.eclipse.core.internal.events.ResourceDelta: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.core.internal.events.ResourceDelta: org.eclipse.core.resources.IResourceDelta findMember(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.events.ResourceDelta: org.eclipse.core.resources.IResourceDelta[] getAffectedChildren()>
<org.eclipse.core.internal.events.ResourceDelta: org.eclipse.core.resources.IResourceDelta[] getAffectedChildren(int,int)>
<org.eclipse.core.internal.events.ResourceDelta: org.eclipse.core.runtime.IPath getFullPath()>
<org.eclipse.core.internal.events.ResourceDelta: void <clinit>()>
<org.eclipse.core.internal.events.ResourceDelta: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.events.ResourceDeltaInfo)>
<org.eclipse.core.internal.events.ResourceDelta: void accept(org.eclipse.core.resources.IResourceDeltaVisitor)>
<org.eclipse.core.internal.events.ResourceDelta: void accept(org.eclipse.core.resources.IResourceDeltaVisitor,int)>
<org.eclipse.core.internal.events.ResourceDelta: void checkForMarkerDeltas()>
<org.eclipse.core.internal.events.ResourceDelta: void fixMovesAndMarkers(org.eclipse.core.internal.watson.ElementTree)>
<org.eclipse.core.internal.events.ResourceDelta: void setChildren(org.eclipse.core.internal.events.ResourceDelta[])>
<org.eclipse.core.internal.events.ResourceDelta: void setNewInfo(org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceDelta: void setOldInfo(org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.events.ResourceDelta: void setStatus(int)>
<org.eclipse.core.internal.events.ResourceDeltaFactory: org.eclipse.core.internal.events.NodeIDMap computeNodeIDMap(org.eclipse.core.internal.events.ResourceDelta,org.eclipse.core.internal.events.NodeIDMap)>
<org.eclipse.core.internal.events.ResourceDeltaFactory: org.eclipse.core.internal.events.ResourceDelta computeDelta(org.eclipse.core.internal.resources.Workspace,org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.runtime.IPath,long)>
<org.eclipse.core.internal.events.ResourceDeltaFactory: org.eclipse.core.internal.events.ResourceDelta createDelta(org.eclipse.core.internal.resources.Workspace,org.eclipse.core.internal.dtree.DeltaDataTree,org.eclipse.core.internal.events.ResourceDeltaInfo,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.events.ResourceDeltaFactory: void <clinit>()>
<org.eclipse.core.internal.events.ResourceDeltaFactory: void checkForOpen(org.eclipse.core.internal.events.ResourceDelta,int)>
<org.eclipse.core.internal.events.ResourceDeltaInfo: java.util.Map getMarkerDeltas()>
<org.eclipse.core.internal.events.ResourceDeltaInfo: org.eclipse.core.internal.events.NodeIDMap getNodeIDMap()>
<org.eclipse.core.internal.events.ResourceDeltaInfo: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.events.ResourceDeltaInfo: void <init>(org.eclipse.core.internal.resources.Workspace,java.util.Map,org.eclipse.core.internal.events.ResourceComparator)>
<org.eclipse.core.internal.events.ResourceDeltaInfo: void setNodeIDMap(org.eclipse.core.internal.events.NodeIDMap)>
<org.eclipse.core.internal.events.ResourceStats: void <clinit>()>
<org.eclipse.core.internal.jobs.DeadlockDetector: boolean checkWaitCycles(int[],int)>
<org.eclipse.core.internal.jobs.DeadlockDetector: int indexOf(java.lang.Thread,boolean)>
<org.eclipse.core.internal.jobs.DeadlockDetector: int indexOf(org.eclipse.core.runtime.jobs.ISchedulingRule,boolean)>
<org.eclipse.core.internal.jobs.DeadlockDetector: org.eclipse.core.internal.jobs.Deadlock lockWaitStart(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.DeadlockDetector: void <clinit>()>
<org.eclipse.core.internal.jobs.DeadlockDetector: void <init>()>
<org.eclipse.core.internal.jobs.DeadlockDetector: void fillPresentEntries(org.eclipse.core.runtime.jobs.ISchedulingRule,int)>
<org.eclipse.core.internal.jobs.DeadlockDetector: void lockAcquired(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.DeadlockDetector: void lockReleased(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.DeadlockDetector: void lockReleasedCompletely(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.DeadlockDetector: void reduceGraph(int,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.DeadlockDetector: void resizeGraph()>
<org.eclipse.core.internal.jobs.DeadlockDetector: void setToWait(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule,boolean)>
<org.eclipse.core.internal.jobs.ImplicitJobs: boolean isSuspended(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.ImplicitJobs: org.eclipse.core.internal.jobs.ThreadJob newThreadJob(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.ImplicitJobs: void <init>(org.eclipse.core.internal.jobs.JobManager)>
<org.eclipse.core.internal.jobs.ImplicitJobs: void begin(org.eclipse.core.runtime.jobs.ISchedulingRule,org.eclipse.core.runtime.IProgressMonitor,boolean)>
<org.eclipse.core.internal.jobs.ImplicitJobs: void end(org.eclipse.core.runtime.jobs.ISchedulingRule,boolean)>
<org.eclipse.core.internal.jobs.ImplicitJobs: void endJob(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.ImplicitJobs: void endThreadJob(org.eclipse.core.internal.jobs.ThreadJob,boolean)>
<org.eclipse.core.internal.jobs.ImplicitJobs: void recycle(org.eclipse.core.internal.jobs.ThreadJob)>
<org.eclipse.core.internal.jobs.InternalJob: boolean cancel()>
<org.eclipse.core.internal.jobs.InternalJob: boolean isConflicting(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.InternalJob: boolean sleep()>
<org.eclipse.core.internal.jobs.InternalJob: int compareTo(java.lang.Object)>
<org.eclipse.core.internal.jobs.InternalJob: int getPriority()>
<org.eclipse.core.internal.jobs.InternalJob: int getState()>
<org.eclipse.core.internal.jobs.InternalJob: int internalGetState()>
<org.eclipse.core.internal.jobs.InternalJob: java.lang.Thread getThread()>
<org.eclipse.core.internal.jobs.InternalJob: long getStartTime()>
<org.eclipse.core.internal.jobs.InternalJob: org.eclipse.core.internal.jobs.InternalJob next()>
<org.eclipse.core.internal.jobs.InternalJob: org.eclipse.core.internal.jobs.InternalJob previous()>
<org.eclipse.core.internal.jobs.InternalJob: org.eclipse.core.internal.jobs.InternalJob remove()>
<org.eclipse.core.internal.jobs.InternalJob: org.eclipse.core.internal.runtime.ListenerList getListeners()>
<org.eclipse.core.internal.jobs.InternalJob: org.eclipse.core.runtime.IProgressMonitor getProgressMonitor()>
<org.eclipse.core.internal.jobs.InternalJob: org.eclipse.core.runtime.jobs.ISchedulingRule getRule()>
<org.eclipse.core.internal.jobs.InternalJob: void <clinit>()>
<org.eclipse.core.internal.jobs.InternalJob: void <init>(java.lang.String)>
<org.eclipse.core.internal.jobs.InternalJob: void addLast(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.InternalJob: void internalSetPriority(int)>
<org.eclipse.core.internal.jobs.InternalJob: void internalSetRule(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.InternalJob: void internalSetState(int)>
<org.eclipse.core.internal.jobs.InternalJob: void schedule(long)>
<org.eclipse.core.internal.jobs.InternalJob: void setNext(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.InternalJob: void setPrevious(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.InternalJob: void setPriority(int)>
<org.eclipse.core.internal.jobs.InternalJob: void setProgressMonitor(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.InternalJob: void setResult(org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.jobs.InternalJob: void setRule(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.InternalJob: void setStartTime(long)>
<org.eclipse.core.internal.jobs.InternalJob: void setSystem(boolean)>
<org.eclipse.core.internal.jobs.InternalJob: void setThread(java.lang.Thread)>
<org.eclipse.core.internal.jobs.InternalJob: void setUser(boolean)>
<org.eclipse.core.internal.jobs.InternalJob: void wakeUp(long)>
<org.eclipse.core.internal.jobs.JobChangeEvent: org.eclipse.core.runtime.jobs.Job getJob()>
<org.eclipse.core.internal.jobs.JobChangeEvent: void <init>()>
<org.eclipse.core.internal.jobs.JobListeners$1: void <init>(org.eclipse.core.internal.jobs.JobListeners)>
<org.eclipse.core.internal.jobs.JobListeners$2: void <init>(org.eclipse.core.internal.jobs.JobListeners)>
<org.eclipse.core.internal.jobs.JobListeners$3: void <init>(org.eclipse.core.internal.jobs.JobListeners)>
<org.eclipse.core.internal.jobs.JobListeners$4: void <init>(org.eclipse.core.internal.jobs.JobListeners)>
<org.eclipse.core.internal.jobs.JobListeners$5: void <init>(org.eclipse.core.internal.jobs.JobListeners)>
<org.eclipse.core.internal.jobs.JobListeners$6: void <init>(org.eclipse.core.internal.jobs.JobListeners)>
<org.eclipse.core.internal.jobs.JobListeners: org.eclipse.core.internal.jobs.JobChangeEvent newEvent(org.eclipse.core.runtime.jobs.Job)>
<org.eclipse.core.internal.jobs.JobListeners: org.eclipse.core.internal.jobs.JobChangeEvent newEvent(org.eclipse.core.runtime.jobs.Job,long)>
<org.eclipse.core.internal.jobs.JobListeners: org.eclipse.core.internal.jobs.JobChangeEvent newEvent(org.eclipse.core.runtime.jobs.Job,org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.jobs.JobListeners: void <init>()>
<org.eclipse.core.internal.jobs.JobListeners: void aboutToRun(org.eclipse.core.runtime.jobs.Job)>
<org.eclipse.core.internal.jobs.JobListeners: void doNotify(org.eclipse.core.internal.jobs.JobListeners$IListenerDoit,org.eclipse.core.runtime.jobs.IJobChangeEvent)>
<org.eclipse.core.internal.jobs.JobListeners: void done(org.eclipse.core.runtime.jobs.Job,org.eclipse.core.runtime.IStatus,boolean)>
<org.eclipse.core.internal.jobs.JobListeners: void running(org.eclipse.core.runtime.jobs.Job)>
<org.eclipse.core.internal.jobs.JobListeners: void scheduled(org.eclipse.core.runtime.jobs.Job,long,boolean)>
<org.eclipse.core.internal.jobs.JobListeners: void sleeping(org.eclipse.core.runtime.jobs.Job)>
<org.eclipse.core.internal.jobs.JobManager$1: void <init>()>
<org.eclipse.core.internal.jobs.JobManager: boolean cancel(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.JobManager: boolean isActive()>
<org.eclipse.core.internal.jobs.JobManager: boolean runNow(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.JobManager: boolean sleep(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.JobManager: long delayFor(int)>
<org.eclipse.core.internal.jobs.JobManager: long sleepHint()>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.internal.jobs.InternalJob findBlockingJob(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.internal.jobs.JobManager getInstance()>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.internal.jobs.LockManager getLockManager()>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.runtime.IProgressMonitor createMonitor(org.eclipse.core.runtime.jobs.Job)>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.runtime.IProgressMonitor monitorFor(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.runtime.jobs.ILock newLock()>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.runtime.jobs.Job currentJob()>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.runtime.jobs.Job nextJob()>
<org.eclipse.core.internal.jobs.JobManager: org.eclipse.core.runtime.jobs.Job startJob()>
<org.eclipse.core.internal.jobs.JobManager: void <clinit>()>
<org.eclipse.core.internal.jobs.JobManager: void <init>()>
<org.eclipse.core.internal.jobs.JobManager: void beginRule(org.eclipse.core.runtime.jobs.ISchedulingRule,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.JobManager: void changeState(org.eclipse.core.internal.jobs.InternalJob,int)>
<org.eclipse.core.internal.jobs.JobManager: void doSchedule(org.eclipse.core.internal.jobs.InternalJob,long)>
<org.eclipse.core.internal.jobs.JobManager: void endJob(org.eclipse.core.internal.jobs.InternalJob,org.eclipse.core.runtime.IStatus,boolean)>
<org.eclipse.core.internal.jobs.JobManager: void endRule(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.JobManager: void reportBlocked(org.eclipse.core.runtime.IProgressMonitor,org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.JobManager: void reportUnblocked(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.JobManager: void schedule(org.eclipse.core.internal.jobs.InternalJob,long,boolean)>
<org.eclipse.core.internal.jobs.JobManager: void setPriority(org.eclipse.core.internal.jobs.InternalJob,int)>
<org.eclipse.core.internal.jobs.JobManager: void setRule(org.eclipse.core.internal.jobs.InternalJob,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.JobManager: void validateRule(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.JobManager: void wakeUp(org.eclipse.core.internal.jobs.InternalJob,long)>
<org.eclipse.core.internal.jobs.JobQueue$1: void <init>(org.eclipse.core.internal.jobs.JobQueue,java.lang.String)>
<org.eclipse.core.internal.jobs.JobQueue: boolean isEmpty()>
<org.eclipse.core.internal.jobs.JobQueue: org.eclipse.core.internal.jobs.InternalJob peek()>
<org.eclipse.core.internal.jobs.JobQueue: void <init>(boolean)>
<org.eclipse.core.internal.jobs.JobQueue: void enqueue(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.JobQueue: void remove(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.LockManager: boolean aboutToWait(java.lang.Thread)>
<org.eclipse.core.internal.jobs.LockManager: org.eclipse.core.internal.jobs.OrderedLock newLock()>
<org.eclipse.core.internal.jobs.LockManager: void <init>()>
<org.eclipse.core.internal.jobs.LockManager: void aboutToRelease()>
<org.eclipse.core.internal.jobs.LockManager: void addLockThread(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.LockManager: void addLockWaitThread(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.LockManager: void removeLockCompletely(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.LockManager: void removeLockThread(java.lang.Thread,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.LockManager: void resumeSuspendedLocks(java.lang.Thread)>
<org.eclipse.core.internal.jobs.OrderedLock: boolean acquire(long)>
<org.eclipse.core.internal.jobs.OrderedLock: boolean attempt()>
<org.eclipse.core.internal.jobs.OrderedLock: boolean doAcquire(org.eclipse.core.internal.jobs.Semaphore,long)>
<org.eclipse.core.internal.jobs.OrderedLock: boolean isConflicting(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.OrderedLock: int getDepth()>
<org.eclipse.core.internal.jobs.OrderedLock: org.eclipse.core.internal.jobs.Semaphore createSemaphore()>
<org.eclipse.core.internal.jobs.OrderedLock: org.eclipse.core.internal.jobs.Semaphore enqueue(org.eclipse.core.internal.jobs.Semaphore)>
<org.eclipse.core.internal.jobs.OrderedLock: void <clinit>()>
<org.eclipse.core.internal.jobs.OrderedLock: void <init>(org.eclipse.core.internal.jobs.LockManager)>
<org.eclipse.core.internal.jobs.OrderedLock: void acquire()>
<org.eclipse.core.internal.jobs.OrderedLock: void doRelease()>
<org.eclipse.core.internal.jobs.OrderedLock: void release()>
<org.eclipse.core.internal.jobs.OrderedLock: void setCurrentOperationThread(java.lang.Thread)>
<org.eclipse.core.internal.jobs.OrderedLock: void updateCurrentOperation()>
<org.eclipse.core.internal.jobs.Queue: boolean isEmpty()>
<org.eclipse.core.internal.jobs.Queue: int increment(int)>
<org.eclipse.core.internal.jobs.Queue: java.lang.Object dequeue()>
<org.eclipse.core.internal.jobs.Queue: java.lang.Object get(java.lang.Object)>
<org.eclipse.core.internal.jobs.Queue: java.lang.Object peek()>
<org.eclipse.core.internal.jobs.Queue: void <init>()>
<org.eclipse.core.internal.jobs.Queue: void <init>(int,boolean)>
<org.eclipse.core.internal.jobs.Queue: void enqueue(java.lang.Object)>
<org.eclipse.core.internal.jobs.Semaphore: boolean acquire(long)>
<org.eclipse.core.internal.jobs.Semaphore: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.jobs.Semaphore: void <init>(java.lang.Runnable)>
<org.eclipse.core.internal.jobs.Semaphore: void release()>
<org.eclipse.core.internal.jobs.ThreadJob: boolean isCanceled(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.ThreadJob: boolean isRunning()>
<org.eclipse.core.internal.jobs.ThreadJob: boolean pop(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.ThreadJob: boolean recycle()>
<org.eclipse.core.internal.jobs.ThreadJob: org.eclipse.core.internal.jobs.ThreadJob joinRun(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.ThreadJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.ThreadJob: void <init>(org.eclipse.core.internal.jobs.JobManager,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.ThreadJob: void push(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.jobs.ThreadJob: void setRealJob(org.eclipse.core.runtime.jobs.Job)>
<org.eclipse.core.internal.jobs.ThreadJob: void waitEnd(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.jobs.ThreadJob: void waitStart(org.eclipse.core.runtime.IProgressMonitor,org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.Worker: org.eclipse.core.runtime.jobs.Job currentJob()>
<org.eclipse.core.internal.jobs.Worker: void <clinit>()>
<org.eclipse.core.internal.jobs.Worker: void <init>(org.eclipse.core.internal.jobs.WorkerPool)>
<org.eclipse.core.internal.jobs.Worker: void run()>
<org.eclipse.core.internal.jobs.WorkerPool: boolean remove(org.eclipse.core.internal.jobs.Worker)>
<org.eclipse.core.internal.jobs.WorkerPool: org.eclipse.core.internal.jobs.InternalJob startJob(org.eclipse.core.internal.jobs.Worker)>
<org.eclipse.core.internal.jobs.WorkerPool: void <init>(org.eclipse.core.internal.jobs.JobManager)>
<org.eclipse.core.internal.jobs.WorkerPool: void add(org.eclipse.core.internal.jobs.Worker)>
<org.eclipse.core.internal.jobs.WorkerPool: void decrementBusyThreads()>
<org.eclipse.core.internal.jobs.WorkerPool: void endJob(org.eclipse.core.internal.jobs.InternalJob,org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.jobs.WorkerPool: void endWorker(org.eclipse.core.internal.jobs.Worker)>
<org.eclipse.core.internal.jobs.WorkerPool: void incrementBusyThreads()>
<org.eclipse.core.internal.jobs.WorkerPool: void jobQueued(org.eclipse.core.internal.jobs.InternalJob)>
<org.eclipse.core.internal.jobs.WorkerPool: void sleep(long)>
<org.eclipse.core.internal.localstore.BlobStore: void <clinit>()>
<org.eclipse.core.internal.localstore.BlobStore: void <init>(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.localstore.Bucket$Entry: void <init>(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.localstore.Bucket$Visitor: void <init>()>
<org.eclipse.core.internal.localstore.Bucket: int accept(org.eclipse.core.internal.localstore.Bucket$Visitor,org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.localstore.Bucket: java.lang.Object getEntryValue(java.lang.String)>
<org.eclipse.core.internal.localstore.Bucket: java.lang.String readEntryKey(java.io.DataInputStream)>
<org.eclipse.core.internal.localstore.Bucket: void <init>()>
<org.eclipse.core.internal.localstore.Bucket: void load(java.lang.String,java.io.File)>
<org.eclipse.core.internal.localstore.Bucket: void load(java.lang.String,java.io.File,boolean)>
<org.eclipse.core.internal.localstore.Bucket: void save()>
<org.eclipse.core.internal.localstore.Bucket: void setEntryValue(java.lang.String,java.lang.Object)>
<org.eclipse.core.internal.localstore.Bucket: void writeEntryKey(java.io.DataOutputStream,java.lang.String)>
<org.eclipse.core.internal.localstore.BucketTree: boolean internalAccept(org.eclipse.core.internal.localstore.Bucket$Visitor,org.eclipse.core.runtime.IPath,java.io.File,int,int)>
<org.eclipse.core.internal.localstore.BucketTree: java.io.File locationFor(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.localstore.BucketTree: java.lang.String translateSegment(java.lang.String)>
<org.eclipse.core.internal.localstore.BucketTree: org.eclipse.core.internal.localstore.Bucket getCurrent()>
<org.eclipse.core.internal.localstore.BucketTree: void <clinit>()>
<org.eclipse.core.internal.localstore.BucketTree: void <init>(org.eclipse.core.internal.resources.Workspace,org.eclipse.core.internal.localstore.Bucket)>
<org.eclipse.core.internal.localstore.BucketTree: void accept(org.eclipse.core.internal.localstore.Bucket$Visitor,org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.localstore.BucketTree: void loadBucketFor(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.localstore.CopyVisitor: boolean copy(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.CopyVisitor: boolean copyContents(org.eclipse.core.internal.localstore.UnifiedTreeNode,org.eclipse.core.internal.resources.Resource,org.eclipse.core.internal.resources.Resource)>
<org.eclipse.core.internal.localstore.CopyVisitor: boolean copyProperties(org.eclipse.core.internal.resources.Resource,org.eclipse.core.internal.resources.Resource)>
<org.eclipse.core.internal.localstore.CopyVisitor: boolean isSynchronized(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.CopyVisitor: boolean visit(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.CopyVisitor: org.eclipse.core.internal.resources.Resource getDestinationResource(org.eclipse.core.internal.resources.Resource,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.localstore.CopyVisitor: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.localstore.CopyVisitor: org.eclipse.core.runtime.IStatus getStatus()>
<org.eclipse.core.internal.localstore.CopyVisitor: void <init>(org.eclipse.core.resources.IResource,org.eclipse.core.resources.IResource,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean copyAttributes(java.lang.String,java.lang.String,boolean)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean isCaseSensitive()>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean isFile(long)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean isFolder(long)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean isReadOnly(java.lang.String)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean isReadOnly(long)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: boolean isSet(long,long)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: long getLastModified(java.lang.String)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: long getLastModified(long)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: long getStat(java.lang.String)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: org.eclipse.core.resources.ResourceAttributes getResourceAttributes(java.lang.String)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: void <clinit>()>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: void logMissingNativeLibrary(java.lang.UnsatisfiedLinkError)>
<org.eclipse.core.internal.localstore.CoreFileSystemLibrary: void setResourceAttributes(java.lang.String,org.eclipse.core.resources.ResourceAttributes)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: boolean hasSavedProject(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: boolean internalWrite(org.eclipse.core.resources.IProject,org.eclipse.core.resources.IProjectDescription,int,boolean,boolean)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: boolean isDescriptionSynchronized(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: boolean refresh(org.eclipse.core.resources.IResource,int,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: boolean refreshResource(org.eclipse.core.resources.IResource,int,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: java.io.InputStream read(org.eclipse.core.resources.IFile,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.internal.localstore.FileSystemStore getStore()>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.internal.localstore.IHistoryStore getHistoryStore()>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.internal.resources.ProjectDescription read(org.eclipse.core.resources.IProject,boolean)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.runtime.IPath getDescriptionLocationFor(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.runtime.IPath getProjectDefaultLocation(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: org.eclipse.core.runtime.IPath locationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: void copy(org.eclipse.core.resources.IResource,org.eclipse.core.resources.IResource,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: void updateLocalSync(org.eclipse.core.internal.resources.ResourceInfo,long)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: void write(org.eclipse.core.resources.IFile,org.eclipse.core.runtime.IPath,java.io.InputStream,boolean,boolean,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemResourceManager: void write(org.eclipse.core.resources.IFolder,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemStore: java.io.InputStream read(java.io.File)>
<org.eclipse.core.internal.localstore.FileSystemStore: java.io.OutputStream createStream(java.io.File,boolean)>
<org.eclipse.core.internal.localstore.FileSystemStore: void <init>()>
<org.eclipse.core.internal.localstore.FileSystemStore: void transferStreams(java.io.InputStream,java.io.OutputStream,java.lang.String,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemStore: void write(java.io.File,java.io.InputStream,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.FileSystemStore: void writeFolder(java.io.File)>
<org.eclipse.core.internal.localstore.HistoryBucket: java.lang.String getFileName()>
<org.eclipse.core.internal.localstore.HistoryBucket: void <init>()>
<org.eclipse.core.internal.localstore.HistoryStore2$2: void <init>(org.eclipse.core.internal.localstore.HistoryStore2,int,long)>
<org.eclipse.core.internal.localstore.HistoryStore2$4: void <init>(org.eclipse.core.internal.localstore.HistoryStore2,java.util.Set)>
<org.eclipse.core.internal.localstore.HistoryStore2$HistoryCopyVisitor: void <init>(org.eclipse.core.internal.localstore.HistoryStore2,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.localstore.HistoryStore2: void <init>(org.eclipse.core.internal.resources.Workspace,org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.localstore.HistoryStore2: void applyPolicy(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.localstore.HistoryStore2: void copyHistory(org.eclipse.core.resources.IResource,org.eclipse.core.resources.IResource,boolean)>
<org.eclipse.core.internal.localstore.HistoryStore2: void remove(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.ILocalStoreConstants: void <clinit>()>
<org.eclipse.core.internal.localstore.RefreshLocalAliasVisitor: void <init>(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.RefreshLocalAliasVisitor: void createResource(org.eclipse.core.internal.localstore.UnifiedTreeNode,org.eclipse.core.internal.resources.Resource)>
<org.eclipse.core.internal.localstore.RefreshLocalVisitor: boolean resourcesChanged()>
<org.eclipse.core.internal.localstore.RefreshLocalVisitor: boolean visit(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.RefreshLocalVisitor: int synchronizeExistence(org.eclipse.core.internal.localstore.UnifiedTreeNode,org.eclipse.core.internal.resources.Resource,int)>
<org.eclipse.core.internal.localstore.RefreshLocalVisitor: org.eclipse.core.runtime.IStatus getErrorStatus()>
<org.eclipse.core.internal.localstore.RefreshLocalVisitor: void <init>(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.localstore.RefreshLocalVisitor: void createResource(org.eclipse.core.internal.localstore.UnifiedTreeNode,org.eclipse.core.internal.resources.Resource)>
<org.eclipse.core.internal.localstore.SafeChunkyOutputStream: void <init>(java.io.File)>
<org.eclipse.core.internal.localstore.SafeChunkyOutputStream: void <init>(java.lang.String)>
<org.eclipse.core.internal.localstore.SafeChunkyOutputStream: void beginChunk()>
<org.eclipse.core.internal.localstore.SafeChunkyOutputStream: void endChunk()>
<org.eclipse.core.internal.localstore.SafeChunkyOutputStream: void succeed()>
<org.eclipse.core.internal.localstore.SafeChunkyOutputStream: void write(int)>
<org.eclipse.core.internal.localstore.SafeFileInputStream: java.io.InputStream getInputStream(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.localstore.SafeFileInputStream: void <init>(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.localstore.UnifiedTree: boolean isChildrenMarker(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: boolean isLevelMarker(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: boolean isValidLevel(int,int)>
<org.eclipse.core.internal.localstore.UnifiedTree: boolean setLevel(int,int)>
<org.eclipse.core.internal.localstore.UnifiedTree: int getLevel()>
<org.eclipse.core.internal.localstore.UnifiedTree: java.lang.Object[] getLocalList(org.eclipse.core.internal.localstore.UnifiedTreeNode,java.lang.String)>
<org.eclipse.core.internal.localstore.UnifiedTree: java.lang.String createChildLocation(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.localstore.UnifiedTree: org.eclipse.core.internal.localstore.UnifiedTreeNode createChildNodeFromFileSystem(org.eclipse.core.internal.localstore.UnifiedTreeNode,java.lang.String,java.lang.String)>
<org.eclipse.core.internal.localstore.UnifiedTree: org.eclipse.core.internal.localstore.UnifiedTreeNode createNode(org.eclipse.core.resources.IResource,long,java.lang.String,java.lang.String,boolean)>
<org.eclipse.core.internal.localstore.UnifiedTree: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.localstore.UnifiedTree: void <clinit>()>
<org.eclipse.core.internal.localstore.UnifiedTree: void <init>(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.localstore.UnifiedTree: void accept(org.eclipse.core.internal.localstore.IUnifiedTreeVisitor,int)>
<org.eclipse.core.internal.localstore.UnifiedTree: void addChildToTree(org.eclipse.core.internal.localstore.UnifiedTreeNode,org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: void addChildren(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: void addChildrenFromFileSystem(org.eclipse.core.internal.localstore.UnifiedTreeNode,java.lang.String,java.lang.Object[],int)>
<org.eclipse.core.internal.localstore.UnifiedTree: void addChildrenMarker()>
<org.eclipse.core.internal.localstore.UnifiedTree: void addElementToQueue(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: void addNodeChildrenToQueue(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: void addRootToQueue()>
<org.eclipse.core.internal.localstore.UnifiedTree: void initializeQueue()>
<org.eclipse.core.internal.localstore.UnifiedTree: void quickSort(java.lang.String[],int,int)>
<org.eclipse.core.internal.localstore.UnifiedTree: void removeNodeChildrenFromQueue(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.localstore.UnifiedTree: void setRoot(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: boolean existsInFileSystem()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: boolean existsInWorkspace()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: boolean isFile()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: boolean isFolder()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: int getLevel()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: java.lang.String getLocalLocation()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: java.lang.String getLocalName()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: long getLastModified()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: org.eclipse.core.internal.localstore.UnifiedTreeNode getFirstChild()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: void <init>(org.eclipse.core.internal.localstore.UnifiedTree,org.eclipse.core.resources.IResource,long,java.lang.String,java.lang.String,boolean)>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: void reuse(org.eclipse.core.internal.localstore.UnifiedTree,org.eclipse.core.resources.IResource,long,java.lang.String,java.lang.String,boolean)>
<org.eclipse.core.internal.localstore.UnifiedTreeNode: void setFirstChild(org.eclipse.core.internal.localstore.UnifiedTreeNode)>
<org.eclipse.core.internal.plugins.CompatibilityActivator: void <init>()>
<org.eclipse.core.internal.plugins.CompatibilityActivator: void start(org.osgi.framework.BundleContext)>
<org.eclipse.core.internal.plugins.InternalPlatform: org.eclipse.core.runtime.IPluginDescriptor getPluginDescriptor(java.lang.String)>
<org.eclipse.core.internal.plugins.InternalPlatform: org.eclipse.core.runtime.IPluginRegistry getPluginRegistry()>
<org.eclipse.core.internal.plugins.InternalPlatform: void <clinit>()>
<org.eclipse.core.internal.plugins.PluginDescriptor: boolean hasPluginObject()>
<org.eclipse.core.internal.plugins.PluginDescriptor: boolean pluginActivationEnter()>
<org.eclipse.core.internal.plugins.PluginDescriptor: java.lang.String getId()>
<org.eclipse.core.internal.plugins.PluginDescriptor: java.lang.String getPluginClass()>
<org.eclipse.core.internal.plugins.PluginDescriptor: java.lang.String getUniqueIdentifier()>
<org.eclipse.core.internal.plugins.PluginDescriptor: org.eclipse.core.runtime.Plugin getPlugin()>
<org.eclipse.core.internal.plugins.PluginDescriptor: org.osgi.framework.Bundle getBundle()>
<org.eclipse.core.internal.plugins.PluginDescriptor: void <init>(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.plugins.PluginDescriptor: void doPluginActivation()>
<org.eclipse.core.internal.plugins.PluginDescriptor: void internalDoPluginActivation()>
<org.eclipse.core.internal.plugins.PluginDescriptor: void pluginActivationExit(boolean)>
<org.eclipse.core.internal.plugins.PluginDescriptor: void setActive()>
<org.eclipse.core.internal.plugins.PluginDescriptor: void setPlugin(org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.plugins.PluginRegistry$RegistryListener: void <init>(org.eclipse.core.internal.plugins.PluginRegistry)>
<org.eclipse.core.internal.plugins.PluginRegistry$RegistryListener: void bundleChanged(org.osgi.framework.BundleEvent)>
<org.eclipse.core.internal.plugins.PluginRegistry: org.eclipse.core.internal.plugins.PluginDescriptor getPluginDescriptor(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.plugins.PluginRegistry: org.eclipse.core.runtime.IPluginDescriptor getPluginDescriptor(java.lang.String)>
<org.eclipse.core.internal.plugins.PluginRegistry: void <init>()>
<org.eclipse.core.internal.preferences.AbstractScope: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.preferences.AbstractScope: org.eclipse.core.runtime.preferences.IEclipsePreferences getNode(java.lang.String)>
<org.eclipse.core.internal.preferences.AbstractScope: void <init>()>
<org.eclipse.core.internal.preferences.DefaultPreferences: boolean isAlreadyLoaded(org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.core.internal.preferences.DefaultPreferences: org.eclipse.core.internal.preferences.EclipsePreferences internalCreate(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.DefaultPreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences getLoadLevel()>
<org.eclipse.core.internal.preferences.DefaultPreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences node(java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.DefaultPreferences: void <clinit>()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void <init>()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String)>
<org.eclipse.core.internal.preferences.DefaultPreferences: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.DefaultPreferences: void applyBundleDefaults()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void applyCommandLineDefaults()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void applyProductDefaults()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void applyRuntimeDefaults()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void flush()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void load()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void loadDefaults()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void loaded()>
<org.eclipse.core.internal.preferences.DefaultPreferences: void runInitializer(org.eclipse.core.runtime.IConfigurationElement)>
<org.eclipse.core.internal.preferences.EclipsePreferences$1: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,boolean,org.eclipse.core.runtime.preferences.IEclipsePreferences$INodeChangeListener,org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent)>
<org.eclipse.core.internal.preferences.EclipsePreferences$1: void run()>
<org.eclipse.core.internal.preferences.EclipsePreferences$2: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,org.eclipse.core.runtime.preferences.IEclipsePreferences$IPreferenceChangeListener,org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent)>
<org.eclipse.core.internal.preferences.EclipsePreferences$2: void run()>
<org.eclipse.core.internal.preferences.EclipsePreferences: boolean childExists(java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: boolean getBoolean(java.lang.String,boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: boolean isLoading()>
<org.eclipse.core.internal.preferences.EclipsePreferences: boolean nodeExists(java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: int getInt(java.lang.String,int)>
<org.eclipse.core.internal.preferences.EclipsePreferences: int getSegmentCount(java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String absolutePath()>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String encodePath(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String get(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String getSegment(java.lang.String,int)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String internalGet(java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String internalPut(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String name()>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String[] computeChildren(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String[] internalChildNames()>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.lang.String[] keys()>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.util.Properties convertToProperties(java.util.Properties,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: java.util.Properties loadProperties(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.preferences.EclipsePreferences: long getLong(java.lang.String,long)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.IPath computeLocation(org.eclipse.core.runtime.IPath,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences addChild(java.lang.String,org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences create(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences create(org.eclipse.core.runtime.preferences.IEclipsePreferences,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences getChild(java.lang.String,org.eclipse.core.runtime.Plugin,boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences internalNode(java.lang.String,boolean,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences[] getChildren(boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.osgi.service.prefs.Preferences node(java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: org.osgi.service.prefs.Preferences parent()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void <clinit>()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void accept(org.eclipse.core.runtime.preferences.IPreferenceNodeVisitor)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void addNodeChangeListener(org.eclipse.core.runtime.preferences.IEclipsePreferences$INodeChangeListener)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void addPreferenceChangeListener(org.eclipse.core.runtime.preferences.IEclipsePreferences$IPreferenceChangeListener)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void checkRemoved()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void convertFromProperties(org.eclipse.core.internal.preferences.EclipsePreferences,java.util.Properties,boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void fireNodeEvent(org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent,boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void firePreferenceEvent(java.lang.String,java.lang.Object,java.lang.Object)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void flush()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void internalRemove(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void load()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void load(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void loadLegacy()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void makeDirty()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void put(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void putBoolean(java.lang.String,boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void putInt(java.lang.String,int)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void putLong(java.lang.String,long)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void remove(java.lang.String)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void removeNode()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void removeNode(org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void save()>
<org.eclipse.core.internal.preferences.EclipsePreferences: void save(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void setLoading(boolean)>
<org.eclipse.core.internal.preferences.EclipsePreferences: void shareStrings(org.eclipse.core.internal.preferences.StringPool)>
<org.eclipse.core.internal.preferences.InstancePreferences: boolean isAlreadyLoaded(org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.core.internal.preferences.InstancePreferences: org.eclipse.core.internal.preferences.EclipsePreferences internalCreate(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.InstancePreferences: org.eclipse.core.runtime.IPath getBaseLocation()>
<org.eclipse.core.internal.preferences.InstancePreferences: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.preferences.InstancePreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences getLoadLevel()>
<org.eclipse.core.internal.preferences.InstancePreferences: void <clinit>()>
<org.eclipse.core.internal.preferences.InstancePreferences: void <init>()>
<org.eclipse.core.internal.preferences.InstancePreferences: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String)>
<org.eclipse.core.internal.preferences.InstancePreferences: void initializeChildren()>
<org.eclipse.core.internal.preferences.InstancePreferences: void loadLegacy()>
<org.eclipse.core.internal.preferences.InstancePreferences: void loaded()>
<org.eclipse.core.internal.preferences.PreferenceForwarder: boolean getBoolean(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: boolean getDefaultBoolean(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: int getInt(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: java.lang.Object getDefault(java.lang.String,java.lang.Object)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: java.lang.String getDefaultString(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: java.lang.String getString(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: long getLong(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: org.eclipse.core.internal.preferences.EclipsePreferences getPluginPreferences(boolean)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: org.eclipse.core.runtime.preferences.IEclipsePreferences getDefaultPreferences()>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void <clinit>()>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void <init>(org.eclipse.core.runtime.Plugin,java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void addPropertyChangeListener(org.eclipse.core.runtime.Preferences$IPropertyChangeListener)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void added(org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void flush()>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void preferenceChange(org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void setDefault(java.lang.String,int)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void setValue(java.lang.String,boolean)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void setValue(java.lang.String,int)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void setValue(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.preferences.PreferenceForwarder: void setValue(java.lang.String,long)>
<org.eclipse.core.internal.preferences.PreferencesService: java.lang.String get(java.lang.String,java.lang.String,org.osgi.service.prefs.Preferences[])>
<org.eclipse.core.internal.preferences.PreferencesService: org.eclipse.core.internal.preferences.PreferencesService getDefault()>
<org.eclipse.core.internal.preferences.PreferencesService: org.eclipse.core.runtime.preferences.IEclipsePreferences createNode(java.lang.String)>
<org.eclipse.core.internal.preferences.PreferencesService: org.eclipse.core.runtime.preferences.IEclipsePreferences getRootNode()>
<org.eclipse.core.internal.preferences.PreferencesService: void <clinit>()>
<org.eclipse.core.internal.preferences.PreferencesService: void <init>()>
<org.eclipse.core.internal.preferences.PreferencesService: void initializeScopes()>
<org.eclipse.core.internal.preferences.PreferencesService: void scopeAdded(org.eclipse.core.runtime.IConfigurationElement)>
<org.eclipse.core.internal.preferences.PreferencesService: void shareStrings()>
<org.eclipse.core.internal.preferences.RootPreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences getChild(java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.preferences.RootPreferences: org.osgi.service.prefs.Preferences node(java.lang.String)>
<org.eclipse.core.internal.preferences.RootPreferences: void <init>()>
<org.eclipse.core.internal.preferences.StringPool: java.lang.String add(java.lang.String)>
<org.eclipse.core.internal.preferences.StringPool: void <init>()>
<org.eclipse.core.internal.properties.PropertyBucket$1: int compare(java.lang.Object,java.lang.Object)>
<org.eclipse.core.internal.properties.PropertyBucket$1: void <init>()>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: int search(java.lang.String[][],org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: java.lang.String getProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: java.lang.String[][] access$1(java.lang.String[][],org.eclipse.core.runtime.QualifiedName,java.lang.String)>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: java.lang.String[][] access$2(java.lang.String[][],org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: java.lang.String[][] delete(java.lang.String[][],org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: java.lang.String[][] insert(java.lang.String[][],org.eclipse.core.runtime.QualifiedName,java.lang.String)>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: void <clinit>()>
<org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry: void <init>(org.eclipse.core.runtime.IPath,java.lang.String[][])>
<org.eclipse.core.internal.properties.PropertyBucket: byte getVersion()>
<org.eclipse.core.internal.properties.PropertyBucket: java.lang.Object readEntryValue(java.io.DataInputStream)>
<org.eclipse.core.internal.properties.PropertyBucket: java.lang.String getFileName()>
<org.eclipse.core.internal.properties.PropertyBucket: java.lang.String getProperty(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.properties.PropertyBucket: org.eclipse.core.internal.properties.PropertyBucket$PropertyEntry getEntry(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.properties.PropertyBucket: void <init>()>
<org.eclipse.core.internal.properties.PropertyBucket: void load(java.lang.String,java.io.File,boolean)>
<org.eclipse.core.internal.properties.PropertyBucket: void save()>
<org.eclipse.core.internal.properties.PropertyBucket: void setProperty(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.QualifiedName,java.lang.String)>
<org.eclipse.core.internal.properties.PropertyBucket: void writeEntryValue(java.io.DataOutputStream,java.lang.Object)>
<org.eclipse.core.internal.properties.PropertyManager2$1: void <init>(org.eclipse.core.internal.properties.PropertyManager2)>
<org.eclipse.core.internal.properties.PropertyManager2$PropertyCopyVisitor: void <init>(org.eclipse.core.internal.properties.PropertyManager2,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.properties.PropertyManager2: java.lang.String getProperty(org.eclipse.core.resources.IResource,org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.properties.PropertyManager2: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.properties.PropertyManager2: void copy(org.eclipse.core.resources.IResource,org.eclipse.core.resources.IResource,int)>
<org.eclipse.core.internal.properties.PropertyManager2: void copyProperties(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.properties.PropertyManager2: void deleteProperties(org.eclipse.core.resources.IResource,int)>
<org.eclipse.core.internal.properties.PropertyManager2: void deleteResource(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.properties.PropertyManager2: void setProperty(org.eclipse.core.resources.IResource,org.eclipse.core.runtime.QualifiedName,java.lang.String)>
<org.eclipse.core.internal.properties.PropertyManager2: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.refresh.MonitorManager: void <init>(org.eclipse.core.resources.IWorkspace,org.eclipse.core.internal.refresh.RefreshManager)>
<org.eclipse.core.internal.refresh.PollingMonitor: void <init>(org.eclipse.core.internal.refresh.RefreshManager)>
<org.eclipse.core.internal.refresh.RefreshJob: void <init>()>
<org.eclipse.core.internal.refresh.RefreshManager: void <clinit>()>
<org.eclipse.core.internal.refresh.RefreshManager: void <init>(org.eclipse.core.resources.IWorkspace)>
<org.eclipse.core.internal.refresh.RefreshManager: void propertyChange(org.eclipse.core.runtime.Preferences$PropertyChangeEvent)>
<org.eclipse.core.internal.refresh.RefreshManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.Object createExecutableExtension(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.Object createExecutableExtension(java.lang.String,java.lang.String,java.lang.Object,org.eclipse.core.internal.registry.ConfigurationElement,java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.Object createExecutableExtension(org.osgi.framework.Bundle,java.lang.String,java.lang.Object,org.eclipse.core.internal.registry.ConfigurationElement,java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.String getAttribute(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.String getAttributeAsIs(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.String getName()>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.String getNamespace()>
<org.eclipse.core.internal.registry.ConfigurationElement: java.lang.String getValueAsIs()>
<org.eclipse.core.internal.registry.ConfigurationElement: org.eclipse.core.internal.registry.ConfigurationElement[] getChildren(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: void <clinit>()>
<org.eclipse.core.internal.registry.ConfigurationElement: void <init>()>
<org.eclipse.core.internal.registry.ConfigurationElement: void setContributingBundle(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.registry.ConfigurationElement: void setName(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElement: void setParentId(int)>
<org.eclipse.core.internal.registry.ConfigurationElement: void setParentType(byte)>
<org.eclipse.core.internal.registry.ConfigurationElement: void setProperties(java.lang.String[])>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: java.lang.Object createExecutableExtension(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: java.lang.String getAttribute(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: java.lang.String getAttributeAsIs(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: java.lang.String getName()>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: java.lang.String getNamespace()>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: org.eclipse.core.internal.registry.ConfigurationElement getConfigurationElement()>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: org.eclipse.core.runtime.IConfigurationElement[] getChildren(java.lang.String)>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: void <clinit>()>
<org.eclipse.core.internal.registry.ConfigurationElementHandle: void <init>(org.eclipse.core.internal.registry.IObjectManager,int)>
<org.eclipse.core.internal.registry.Contribution: boolean compare(org.eclipse.core.internal.registry.KeyedElement)>
<org.eclipse.core.internal.registry.Contribution: int getKeyHashCode()>
<org.eclipse.core.internal.registry.Contribution: int[] getExtensionPoints()>
<org.eclipse.core.internal.registry.Contribution: int[] getExtensions()>
<org.eclipse.core.internal.registry.Contribution: java.lang.Object getKey()>
<org.eclipse.core.internal.registry.Contribution: java.lang.String getNamespace()>
<org.eclipse.core.internal.registry.Contribution: org.osgi.framework.Bundle getContributingBundle()>
<org.eclipse.core.internal.registry.Contribution: org.osgi.framework.Bundle getNamespaceBundle()>
<org.eclipse.core.internal.registry.Contribution: void <clinit>()>
<org.eclipse.core.internal.registry.Contribution: void <init>(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.registry.Contribution: void setRawChildren(int[])>
<org.eclipse.core.internal.registry.EclipseBundleListener: boolean isBundleResolved(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.registry.EclipseBundleListener: boolean isSingleton(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.registry.EclipseBundleListener: org.eclipse.core.internal.registry.Contribution getBundleModel(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.registry.EclipseBundleListener: void <init>(org.eclipse.core.internal.registry.ExtensionRegistry)>
<org.eclipse.core.internal.registry.EclipseBundleListener: void addBundle(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.registry.EclipseBundleListener: void bundleChanged(org.osgi.framework.BundleEvent)>
<org.eclipse.core.internal.registry.EclipseBundleListener: void processBundles(org.osgi.framework.Bundle[])>
<org.eclipse.core.internal.registry.Extension: java.lang.String getExtensionPointIdentifier()>
<org.eclipse.core.internal.registry.Extension: java.lang.String getLabel()>
<org.eclipse.core.internal.registry.Extension: java.lang.String getNamespace()>
<org.eclipse.core.internal.registry.Extension: java.lang.String getUniqueIdentifier()>
<org.eclipse.core.internal.registry.Extension: java.lang.String[] getExtraData()>
<org.eclipse.core.internal.registry.Extension: void <clinit>()>
<org.eclipse.core.internal.registry.Extension: void <init>()>
<org.eclipse.core.internal.registry.Extension: void ensureExtraInformationType()>
<org.eclipse.core.internal.registry.Extension: void setExtensionPointIdentifier(java.lang.String)>
<org.eclipse.core.internal.registry.Extension: void setLabel(java.lang.String)>
<org.eclipse.core.internal.registry.Extension: void setNamespace(java.lang.String)>
<org.eclipse.core.internal.registry.Extension: void setSimpleIdentifier(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionDelta: org.eclipse.core.runtime.IExtension getExtension()>
<org.eclipse.core.internal.registry.ExtensionDelta: void <init>()>
<org.eclipse.core.internal.registry.ExtensionDelta: void setContainingDelta(org.eclipse.core.internal.registry.RegistryDelta)>
<org.eclipse.core.internal.registry.ExtensionDelta: void setExtension(int)>
<org.eclipse.core.internal.registry.ExtensionDelta: void setExtensionPoint(int)>
<org.eclipse.core.internal.registry.ExtensionDelta: void setKind(int)>
<org.eclipse.core.internal.registry.ExtensionHandle: java.lang.String getExtensionPointUniqueIdentifier()>
<org.eclipse.core.internal.registry.ExtensionHandle: java.lang.String getLabel()>
<org.eclipse.core.internal.registry.ExtensionHandle: java.lang.String getNamespace()>
<org.eclipse.core.internal.registry.ExtensionHandle: java.lang.String getUniqueIdentifier()>
<org.eclipse.core.internal.registry.ExtensionHandle: org.eclipse.core.internal.registry.Extension getExtension()>
<org.eclipse.core.internal.registry.ExtensionHandle: org.eclipse.core.runtime.IConfigurationElement[] getConfigurationElements()>
<org.eclipse.core.internal.registry.ExtensionHandle: void <clinit>()>
<org.eclipse.core.internal.registry.ExtensionHandle: void <init>(org.eclipse.core.internal.registry.IObjectManager,int)>
<org.eclipse.core.internal.registry.ExtensionPoint: java.lang.String getLabel()>
<org.eclipse.core.internal.registry.ExtensionPoint: java.lang.String getNamespace()>
<org.eclipse.core.internal.registry.ExtensionPoint: java.lang.String getSimpleIdentifier()>
<org.eclipse.core.internal.registry.ExtensionPoint: java.lang.String getUniqueIdentifier()>
<org.eclipse.core.internal.registry.ExtensionPoint: java.lang.String[] getExtraData()>
<org.eclipse.core.internal.registry.ExtensionPoint: void <clinit>()>
<org.eclipse.core.internal.registry.ExtensionPoint: void <init>()>
<org.eclipse.core.internal.registry.ExtensionPoint: void ensureExtraInformationType()>
<org.eclipse.core.internal.registry.ExtensionPoint: void setBundleId(long)>
<org.eclipse.core.internal.registry.ExtensionPoint: void setLabel(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionPoint: void setNamespace(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionPoint: void setSchema(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionPoint: void setUniqueIdentifier(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionPointHandle: org.eclipse.core.internal.registry.ExtensionPoint getExtensionPoint()>
<org.eclipse.core.internal.registry.ExtensionPointHandle: org.eclipse.core.runtime.IConfigurationElement[] getConfigurationElements()>
<org.eclipse.core.internal.registry.ExtensionPointHandle: org.eclipse.core.runtime.IExtension getExtension(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionPointHandle: org.eclipse.core.runtime.IExtension[] getExtensions()>
<org.eclipse.core.internal.registry.ExtensionPointHandle: void <clinit>()>
<org.eclipse.core.internal.registry.ExtensionPointHandle: void <init>(org.eclipse.core.internal.registry.IObjectManager,int)>
<org.eclipse.core.internal.registry.ExtensionRegistry$1: boolean contains(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.registry.ExtensionRegistry$1: boolean isConflicting(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.registry.ExtensionRegistry$1: void <init>()>
<org.eclipse.core.internal.registry.ExtensionRegistry$ExtensionEventDispatcherJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.registry.ExtensionRegistry$ExtensionEventDispatcherJob: void <clinit>()>
<org.eclipse.core.internal.registry.ExtensionRegistry$ExtensionEventDispatcherJob: void <init>(java.lang.Object[],java.util.Map)>
<org.eclipse.core.internal.registry.ExtensionRegistry$ListenerInfo: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.registry.ExtensionRegistry$ListenerInfo: void <init>(org.eclipse.core.internal.registry.ExtensionRegistry,org.eclipse.core.runtime.IRegistryChangeListener,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: boolean hasNamespace(long)>
<org.eclipse.core.internal.registry.ExtensionRegistry: java.lang.String addExtension(int)>
<org.eclipse.core.internal.registry.ExtensionRegistry: java.lang.String addExtensionPoint(int)>
<org.eclipse.core.internal.registry.ExtensionRegistry: java.lang.String recordChange(org.eclipse.core.internal.registry.ExtensionPoint,int,int)>
<org.eclipse.core.internal.registry.ExtensionRegistry: java.lang.String recordChange(org.eclipse.core.internal.registry.ExtensionPoint,int[],int)>
<org.eclipse.core.internal.registry.ExtensionRegistry: java.util.Set addExtensionsAndExtensionPoints(org.eclipse.core.internal.registry.Contribution)>
<org.eclipse.core.internal.registry.ExtensionRegistry: org.eclipse.core.internal.registry.RegistryDelta getDelta(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: org.eclipse.core.internal.registry.RegistryObjectManager getObjectManager()>
<org.eclipse.core.internal.registry.ExtensionRegistry: org.eclipse.core.runtime.IConfigurationElement[] getConfigurationElementsFor(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: org.eclipse.core.runtime.IConfigurationElement[] getConfigurationElementsFor(java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: org.eclipse.core.runtime.IExtension getExtension(java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: org.eclipse.core.runtime.IExtensionPoint getExtensionPoint(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: void <init>()>
<org.eclipse.core.internal.registry.ExtensionRegistry: void add(org.eclipse.core.internal.registry.Contribution)>
<org.eclipse.core.internal.registry.ExtensionRegistry: void addRegistryChangeListener(org.eclipse.core.runtime.IRegistryChangeListener,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionRegistry: void basicAdd(org.eclipse.core.internal.registry.Contribution,boolean)>
<org.eclipse.core.internal.registry.ExtensionRegistry: void fireRegistryChangeEvent()>
<org.eclipse.core.internal.registry.ExtensionRegistry: void link(org.eclipse.core.internal.registry.ExtensionPoint,int[])>
<org.eclipse.core.internal.registry.ExtensionRegistry: void setObjectManagers(java.util.Set,org.eclipse.core.internal.registry.IObjectManager)>
<org.eclipse.core.internal.registry.ExtensionsParser: java.lang.String translate(java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionsParser: org.eclipse.core.internal.registry.Contribution parseManifest(org.osgi.util.tracker.ServiceTracker,org.xml.sax.InputSource,java.lang.String,java.lang.String,org.eclipse.core.internal.registry.RegistryObjectManager,org.eclipse.core.internal.registry.Contribution,java.util.ResourceBundle)>
<org.eclipse.core.internal.registry.ExtensionsParser: org.eclipse.core.internal.registry.Extension[] fixRenamedExtensionPoints(org.eclipse.core.internal.registry.Extension[])>
<org.eclipse.core.internal.registry.ExtensionsParser: void <clinit>()>
<org.eclipse.core.internal.registry.ExtensionsParser: void <init>(org.eclipse.core.runtime.MultiStatus)>
<org.eclipse.core.internal.registry.ExtensionsParser: void characters(char[],int,int)>
<org.eclipse.core.internal.registry.ExtensionsParser: void endDocument()>
<org.eclipse.core.internal.registry.ExtensionsParser: void endElement(java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionsParser: void handleBundleState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.ExtensionsParser: void handleExtensionState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.ExtensionsParser: void handleInitialState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.ExtensionsParser: void initializeExtensionPointMap()>
<org.eclipse.core.internal.registry.ExtensionsParser: void parseConfigurationElementAttributes(org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.ExtensionsParser: void parseExtensionAttributes(org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.ExtensionsParser: void parseExtensionPointAttributes(org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.ExtensionsParser: void processingInstruction(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.ExtensionsParser: void setDocumentLocator(org.xml.sax.Locator)>
<org.eclipse.core.internal.registry.ExtensionsParser: void startDocument()>
<org.eclipse.core.internal.registry.ExtensionsParser: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.internal.registry.Handle: int getId()>
<org.eclipse.core.internal.registry.Handle: void <init>(org.eclipse.core.internal.registry.IObjectManager,int)>
<org.eclipse.core.internal.registry.HashtableOfInt: void <init>()>
<org.eclipse.core.internal.registry.HashtableOfInt: void <init>(int)>
<org.eclipse.core.internal.registry.HashtableOfStringAndInt: int get(java.lang.String)>
<org.eclipse.core.internal.registry.HashtableOfStringAndInt: int put(java.lang.String,int)>
<org.eclipse.core.internal.registry.HashtableOfStringAndInt: void <init>()>
<org.eclipse.core.internal.registry.HashtableOfStringAndInt: void <init>(int)>
<org.eclipse.core.internal.registry.HashtableOfStringAndInt: void rehash()>
<org.eclipse.core.internal.registry.KeyedHashSet: boolean add(org.eclipse.core.internal.registry.KeyedElement)>
<org.eclipse.core.internal.registry.KeyedHashSet: boolean shouldGrow()>
<org.eclipse.core.internal.registry.KeyedHashSet: int hash(org.eclipse.core.internal.registry.KeyedElement)>
<org.eclipse.core.internal.registry.KeyedHashSet: int keyHash(java.lang.Object)>
<org.eclipse.core.internal.registry.KeyedHashSet: org.eclipse.core.internal.registry.KeyedElement getByKey(java.lang.Object)>
<org.eclipse.core.internal.registry.KeyedHashSet: void <init>()>
<org.eclipse.core.internal.registry.KeyedHashSet: void <init>(int)>
<org.eclipse.core.internal.registry.KeyedHashSet: void <init>(int,boolean)>
<org.eclipse.core.internal.registry.KeyedHashSet: void expand()>
<org.eclipse.core.internal.registry.ReadWriteMonitor: void <init>()>
<org.eclipse.core.internal.registry.ReadWriteMonitor: void enterRead()>
<org.eclipse.core.internal.registry.ReadWriteMonitor: void enterWrite()>
<org.eclipse.core.internal.registry.ReadWriteMonitor: void exitRead()>
<org.eclipse.core.internal.registry.ReadWriteMonitor: void exitWrite()>
<org.eclipse.core.internal.registry.ReferenceMap$SoftRef: int getKey()>
<org.eclipse.core.internal.registry.ReferenceMap$SoftRef: java.lang.Object getValue()>
<org.eclipse.core.internal.registry.ReferenceMap$SoftRef: org.eclipse.core.internal.registry.ReferenceMap$IEntry getNext()>
<org.eclipse.core.internal.registry.ReferenceMap$SoftRef: void <init>(int,java.lang.Object,org.eclipse.core.internal.registry.ReferenceMap$IEntry,java.lang.ref.ReferenceQueue)>
<org.eclipse.core.internal.registry.ReferenceMap$SoftRef: void setNext(org.eclipse.core.internal.registry.ReferenceMap$IEntry)>
<org.eclipse.core.internal.registry.ReferenceMap: int indexFor(int)>
<org.eclipse.core.internal.registry.ReferenceMap: java.lang.Object get(int)>
<org.eclipse.core.internal.registry.ReferenceMap: org.eclipse.core.internal.registry.ReferenceMap$IEntry newEntry(int,java.lang.Object,org.eclipse.core.internal.registry.ReferenceMap$IEntry)>
<org.eclipse.core.internal.registry.ReferenceMap: void <init>(int,int,float)>
<org.eclipse.core.internal.registry.ReferenceMap: void purge()>
<org.eclipse.core.internal.registry.ReferenceMap: void put(int,java.lang.Object)>
<org.eclipse.core.internal.registry.RegistryChangeEvent: org.eclipse.core.internal.registry.RegistryDelta getHostDelta(java.lang.String)>
<org.eclipse.core.internal.registry.RegistryChangeEvent: org.eclipse.core.runtime.IExtensionDelta[] getExtensionDeltas(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.registry.RegistryChangeEvent: void <init>(java.util.Map,java.lang.String)>
<org.eclipse.core.internal.registry.RegistryDelta: org.eclipse.core.internal.registry.IObjectManager getObjectManager()>
<org.eclipse.core.internal.registry.RegistryDelta: org.eclipse.core.runtime.IExtensionDelta[] getExtensionDeltas(java.lang.String)>
<org.eclipse.core.internal.registry.RegistryDelta: void <init>()>
<org.eclipse.core.internal.registry.RegistryDelta: void addExtensionDelta(org.eclipse.core.runtime.IExtensionDelta)>
<org.eclipse.core.internal.registry.RegistryDelta: void setObjectManager(org.eclipse.core.internal.registry.IObjectManager)>
<org.eclipse.core.internal.registry.RegistryObject: boolean compare(org.eclipse.core.internal.registry.KeyedElement)>
<org.eclipse.core.internal.registry.RegistryObject: int getKeyHashCode()>
<org.eclipse.core.internal.registry.RegistryObject: int getObjectId()>
<org.eclipse.core.internal.registry.RegistryObject: int[] getRawChildren()>
<org.eclipse.core.internal.registry.RegistryObject: void <init>()>
<org.eclipse.core.internal.registry.RegistryObject: void setObjectId(int)>
<org.eclipse.core.internal.registry.RegistryObject: void setRawChildren(int[])>
<org.eclipse.core.internal.registry.RegistryObjectManager: boolean hasContribution(long)>
<org.eclipse.core.internal.registry.RegistryObjectManager: int[] getExtensionPointsFrom(long)>
<org.eclipse.core.internal.registry.RegistryObjectManager: int[] getExtensionsFrom(long)>
<org.eclipse.core.internal.registry.RegistryObjectManager: int[] removeOrphans(java.lang.String)>
<org.eclipse.core.internal.registry.RegistryObjectManager: java.lang.Object basicGetObject(int,byte)>
<org.eclipse.core.internal.registry.RegistryObjectManager: java.lang.Object getObject(int,byte)>
<org.eclipse.core.internal.registry.RegistryObjectManager: java.util.Map getAssociatedObjects(long)>
<org.eclipse.core.internal.registry.RegistryObjectManager: java.util.Map getOrphans()>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.ExtensionPoint getExtensionPointObject(java.lang.String)>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.ExtensionPointHandle getExtensionPointHandle(java.lang.String)>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.Handle getHandle(int,byte)>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.Handle[] getHandles(int[],byte)>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.IObjectManager createDelegatingObjectManager(java.util.Map)>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.KeyedHashSet getFormerContributions()>
<org.eclipse.core.internal.registry.RegistryObjectManager: org.eclipse.core.internal.registry.RegistryObject[] getObjects(int[],byte)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void <clinit>()>
<org.eclipse.core.internal.registry.RegistryObjectManager: void <init>()>
<org.eclipse.core.internal.registry.RegistryObjectManager: void add(org.eclipse.core.internal.registry.RegistryObject,boolean)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void addContribution(org.eclipse.core.internal.registry.Contribution)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void addExtensionPoint(org.eclipse.core.internal.registry.ExtensionPoint,boolean)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void addOrphan(java.lang.String,int)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void collectChildren(org.eclipse.core.internal.registry.RegistryObject,int,java.util.Map)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void hold(org.eclipse.core.internal.registry.RegistryObject)>
<org.eclipse.core.internal.registry.RegistryObjectManager: void markOrphansHasDirty(java.util.Map)>
<org.eclipse.core.internal.registry.TemporaryObjectManager: java.lang.Object getObject(int,byte)>
<org.eclipse.core.internal.registry.TemporaryObjectManager: void <init>(java.util.Map,org.eclipse.core.internal.registry.RegistryObjectManager)>
<org.eclipse.core.internal.registry.TemporaryObjectManager: void close()>
<org.eclipse.core.internal.resources.AliasManager$1: int compare(java.lang.Object,java.lang.Object)>
<org.eclipse.core.internal.resources.AliasManager$1: void <init>(org.eclipse.core.internal.resources.AliasManager)>
<org.eclipse.core.internal.resources.AliasManager$AddToCollectionDoit: void <init>(org.eclipse.core.internal.resources.AliasManager)>
<org.eclipse.core.internal.resources.AliasManager$FindAliasesDoit: void <init>(org.eclipse.core.internal.resources.AliasManager)>
<org.eclipse.core.internal.resources.AliasManager$LocationMap: boolean add(org.eclipse.core.runtime.IPath,org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.AliasManager$LocationMap: boolean remove(org.eclipse.core.runtime.IPath,org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.AliasManager$LocationMap: void <init>(org.eclipse.core.internal.resources.AliasManager)>
<org.eclipse.core.internal.resources.AliasManager$LocationMap: void clear()>
<org.eclipse.core.internal.resources.AliasManager: boolean hasNoAliases(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.AliasManager: java.util.Comparator getComparator()>
<org.eclipse.core.internal.resources.AliasManager: org.eclipse.core.resources.IResource[] computeAliases(org.eclipse.core.resources.IResource,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.AliasManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.AliasManager: void addToLocationsMap(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.AliasManager: void buildAliasedProjectsSet()>
<org.eclipse.core.internal.resources.AliasManager: void buildLocationsMap()>
<org.eclipse.core.internal.resources.AliasManager: void handleEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.resources.AliasManager: void removeFromLocationsMap(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.AliasManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.AliasManager: void updateAliases(org.eclipse.core.resources.IResource,org.eclipse.core.runtime.IPath,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.AliasManager: void updateStructureChanges()>
<org.eclipse.core.internal.resources.CharsetDeltaJob: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.CharsetDeltaJob: void startup()>
<org.eclipse.core.internal.resources.CharsetManager$CharsetManagerJob: void <init>(org.eclipse.core.internal.resources.CharsetManager)>
<org.eclipse.core.internal.resources.CharsetManager$CharsetManagerJob: void addChanges(java.util.Set)>
<org.eclipse.core.internal.resources.CharsetManager$Listener: void <init>(org.eclipse.core.internal.resources.CharsetManager)>
<org.eclipse.core.internal.resources.CharsetManager$Listener: void processEntryChanges(org.eclipse.core.resources.IResourceDelta,java.util.Set)>
<org.eclipse.core.internal.resources.CharsetManager$Listener: void resourceChanged(org.eclipse.core.resources.IResourceChangeEvent)>
<org.eclipse.core.internal.resources.CharsetManager: java.lang.String getCharsetFor(org.eclipse.core.runtime.IPath,boolean)>
<org.eclipse.core.internal.resources.CharsetManager: org.osgi.service.prefs.Preferences getPreferences(org.eclipse.core.resources.IProject,boolean)>
<org.eclipse.core.internal.resources.CharsetManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.CharsetManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Container: java.lang.String getDefaultCharset()>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IFile getFile(java.lang.String)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IFile getFile(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IFolder getFolder(java.lang.String)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IFolder getFolder(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource findMember(java.lang.String)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource findMember(java.lang.String,boolean)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource findMember(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource findMember(org.eclipse.core.runtime.IPath,boolean)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource[] getChildren(int)>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource[] members()>
<org.eclipse.core.internal.resources.Container: org.eclipse.core.resources.IResource[] members(int)>
<org.eclipse.core.internal.resources.Container: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$1: boolean visitElement(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.IPathRequestor,java.lang.Object)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$1: void <init>(org.eclipse.core.internal.resources.ContentDescriptionManager,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$FlushJob: org.eclipse.core.runtime.IPath[] getPathsToFlush()>
<org.eclipse.core.internal.resources.ContentDescriptionManager$FlushJob: org.eclipse.core.runtime.IStatus runInWorkspace(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$FlushJob: void <init>(org.eclipse.core.internal.resources.ContentDescriptionManager)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$FlushJob: void flush(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream: int read(byte[],int,int)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream: void <init>(org.eclipse.core.internal.resources.ContentDescriptionManager,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream: void close()>
<org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream: void ensureOpened()>
<org.eclipse.core.internal.resources.ContentDescriptionManager: byte getCacheState()>
<org.eclipse.core.internal.resources.ContentDescriptionManager: long getCacheTimestamp()>
<org.eclipse.core.internal.resources.ContentDescriptionManager: org.eclipse.core.runtime.content.IContentDescription getDescriptionFor(org.eclipse.core.internal.resources.File,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: org.eclipse.core.runtime.content.IContentDescription readDescription(org.eclipse.core.internal.resources.File)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: org.eclipse.core.runtime.content.IContentTypeMatcher getContentTypeMatcher(org.eclipse.core.internal.resources.Project)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void <clinit>()>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void <init>()>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void clearContentFlags(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void doFlushCache(org.eclipse.core.runtime.IProgressMonitor,org.eclipse.core.runtime.IPath[])>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void handleEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void invalidateCache(boolean,org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void setCacheState(byte)>
<org.eclipse.core.internal.resources.ContentDescriptionManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.DelayedSnapshotJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.DelayedSnapshotJob: void <clinit>()>
<org.eclipse.core.internal.resources.DelayedSnapshotJob: void <init>(org.eclipse.core.internal.resources.SaveManager)>
<org.eclipse.core.internal.resources.File: int getType()>
<org.eclipse.core.internal.resources.File: java.io.InputStream getContents(boolean)>
<org.eclipse.core.internal.resources.File: java.lang.String getCharset()>
<org.eclipse.core.internal.resources.File: java.lang.String getCharset(boolean)>
<org.eclipse.core.internal.resources.File: java.lang.String internalGetCharset(boolean,org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.resources.File: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.File: void create(java.io.InputStream,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.File: void ensureClosed(java.io.InputStream)>
<org.eclipse.core.internal.resources.File: void internalSetContents(java.io.InputStream,org.eclipse.core.runtime.IPath,boolean,boolean,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.File: void updateMetadataFiles()>
<org.eclipse.core.internal.resources.Folder: int getType()>
<org.eclipse.core.internal.resources.Folder: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.Folder: void assertCreateRequirements(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.resources.Folder: void create(boolean,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Folder: void create(int,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Folder: void internalCreate(boolean,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.ICoreConstants: void <clinit>()>
<org.eclipse.core.internal.resources.InternalTeamHook: void <init>()>
<org.eclipse.core.internal.resources.InternalWorkspaceJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.InternalWorkspaceJob: void <init>(java.lang.String)>
<org.eclipse.core.internal.resources.LocalMetaArea: boolean hasSavedWorkspace()>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.internal.resources.WorkspaceDescription readOldWorkspace()>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getBackupLocationFor(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getHistoryStoreLocation()>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getMarkersLocationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getMarkersSnapshotLocationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getOldWorkspaceDescriptionLocation()>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getSafeTableLocationFor(java.lang.String)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getSnapshotLocationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getSyncInfoLocationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getSyncInfoSnapshotLocationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getTreeLocationFor(org.eclipse.core.resources.IResource,boolean)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath getWorkingLocation(org.eclipse.core.resources.IResource,java.lang.String)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath locationFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.LocalMetaArea: org.eclipse.core.runtime.IPath locationFor(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.LocalMetaArea: void <init>()>
<org.eclipse.core.internal.resources.LocalMetaArea: void create(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.LocalMetaArea: void delete(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.LocalMetaArea: void writePrivateDescription(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.Marker: java.lang.Object getAttribute(java.lang.String)>
<org.eclipse.core.internal.resources.Marker: long getId()>
<org.eclipse.core.internal.resources.Marker: org.eclipse.core.internal.resources.MarkerInfo getInfo()>
<org.eclipse.core.internal.resources.Marker: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.resources.Marker: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.core.internal.resources.Marker: void <init>(org.eclipse.core.resources.IResource,long)>
<org.eclipse.core.internal.resources.Marker: void checkInfo(org.eclipse.core.internal.resources.MarkerInfo)>
<org.eclipse.core.internal.resources.Marker: void delete()>
<org.eclipse.core.internal.resources.Marker: void setAttributes(java.lang.String[],java.lang.Object[])>
<org.eclipse.core.internal.resources.MarkerAttributeMap: java.lang.Object get(java.lang.Object)>
<org.eclipse.core.internal.resources.MarkerAttributeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<org.eclipse.core.internal.resources.MarkerAttributeMap: void <init>()>
<org.eclipse.core.internal.resources.MarkerAttributeMap: void shareStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.resources.MarkerDelta: int getKind()>
<org.eclipse.core.internal.resources.MarkerDelta: java.util.Map merge(java.util.Map,java.util.Map)>
<org.eclipse.core.internal.resources.MarkerDelta: long getId()>
<org.eclipse.core.internal.resources.MarkerDelta: org.eclipse.core.internal.resources.MarkerSet merge(org.eclipse.core.internal.resources.MarkerSet,org.eclipse.core.internal.resources.IMarkerSetElement[])>
<org.eclipse.core.internal.resources.MarkerDelta: void <init>(int,org.eclipse.core.resources.IResource,org.eclipse.core.internal.resources.MarkerInfo)>
<org.eclipse.core.internal.resources.MarkerDeltaManager: java.util.Map assembleDeltas(long)>
<org.eclipse.core.internal.resources.MarkerDeltaManager: java.util.Map newGeneration(long)>
<org.eclipse.core.internal.resources.MarkerDeltaManager: void <init>()>
<org.eclipse.core.internal.resources.MarkerDeltaManager: void resetDeltas(long)>
<org.eclipse.core.internal.resources.MarkerInfo: java.lang.Object getAttribute(java.lang.String)>
<org.eclipse.core.internal.resources.MarkerInfo: java.lang.String getType()>
<org.eclipse.core.internal.resources.MarkerInfo: long getId()>
<org.eclipse.core.internal.resources.MarkerInfo: void <init>()>
<org.eclipse.core.internal.resources.MarkerInfo: void checkValidAttribute(java.lang.Object)>
<org.eclipse.core.internal.resources.MarkerInfo: void setAttribute(java.lang.String,java.lang.Object)>
<org.eclipse.core.internal.resources.MarkerInfo: void setAttributes(java.lang.String[],java.lang.Object[])>
<org.eclipse.core.internal.resources.MarkerInfo: void setCreationTime(long)>
<org.eclipse.core.internal.resources.MarkerInfo: void setId(long)>
<org.eclipse.core.internal.resources.MarkerInfo: void setType(java.lang.String)>
<org.eclipse.core.internal.resources.MarkerInfo: void shareStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.resources.MarkerManager$4: boolean visitElement(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.IPathRequestor,java.lang.Object)>
<org.eclipse.core.internal.resources.MarkerManager$4: void <init>(org.eclipse.core.internal.resources.MarkerManager,java.lang.String,boolean)>
<org.eclipse.core.internal.resources.MarkerManager: boolean hasDelta(org.eclipse.core.runtime.IPath,long)>
<org.eclipse.core.internal.resources.MarkerManager: boolean isPersistent(org.eclipse.core.internal.resources.MarkerInfo)>
<org.eclipse.core.internal.resources.MarkerManager: java.util.Map getMarkerDeltas(long)>
<org.eclipse.core.internal.resources.MarkerManager: long getChangeId()>
<org.eclipse.core.internal.resources.MarkerManager: org.eclipse.core.internal.resources.MarkerInfo findMarkerInfo(org.eclipse.core.resources.IResource,long)>
<org.eclipse.core.internal.resources.MarkerManager: org.eclipse.core.internal.resources.MarkerInfo[] basicFindMatching(org.eclipse.core.internal.resources.MarkerSet,java.lang.String,boolean)>
<org.eclipse.core.internal.resources.MarkerManager: org.eclipse.core.resources.IMarker[] findMarkers(org.eclipse.core.resources.IResource,java.lang.String,boolean,int)>
<org.eclipse.core.internal.resources.MarkerManager: void <clinit>()>
<org.eclipse.core.internal.resources.MarkerManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.MarkerManager: void add(org.eclipse.core.resources.IResource,org.eclipse.core.internal.resources.MarkerInfo)>
<org.eclipse.core.internal.resources.MarkerManager: void basicAdd(org.eclipse.core.resources.IResource,org.eclipse.core.internal.resources.MarkerSet,org.eclipse.core.internal.resources.MarkerInfo)>
<org.eclipse.core.internal.resources.MarkerManager: void basicRemoveMarkers(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.watson.IPathRequestor,java.lang.String,boolean)>
<org.eclipse.core.internal.resources.MarkerManager: void buildMarkers(org.eclipse.core.internal.resources.IMarkerSetElement[],org.eclipse.core.runtime.IPath,int,java.util.ArrayList)>
<org.eclipse.core.internal.resources.MarkerManager: void changedMarkers(org.eclipse.core.resources.IResource,org.eclipse.core.internal.resources.IMarkerSetElement[])>
<org.eclipse.core.internal.resources.MarkerManager: void recursiveFindMarkers(org.eclipse.core.runtime.IPath,java.util.ArrayList,java.lang.String,boolean,int)>
<org.eclipse.core.internal.resources.MarkerManager: void removeMarker(org.eclipse.core.resources.IResource,long)>
<org.eclipse.core.internal.resources.MarkerManager: void removeMarkers(org.eclipse.core.resources.IResource,int)>
<org.eclipse.core.internal.resources.MarkerManager: void removeMarkers(org.eclipse.core.resources.IResource,java.lang.String,boolean,int)>
<org.eclipse.core.internal.resources.MarkerManager: void resetMarkerDeltas(long)>
<org.eclipse.core.internal.resources.MarkerManager: void restore(org.eclipse.core.resources.IResource,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.MarkerManager: void restoreFromSave(org.eclipse.core.resources.IResource,boolean)>
<org.eclipse.core.internal.resources.MarkerManager: void restoreFromSnap(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.MarkerManager: void snap(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.watson.IPathRequestor,java.io.DataOutputStream)>
<org.eclipse.core.internal.resources.MarkerManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.MarkerManager: void visitorRemoveMarkers(org.eclipse.core.runtime.IPath,java.lang.String,boolean)>
<org.eclipse.core.internal.resources.MarkerSet: boolean isEmpty()>
<org.eclipse.core.internal.resources.MarkerSet: boolean shouldGrow()>
<org.eclipse.core.internal.resources.MarkerSet: int hashFor(long)>
<org.eclipse.core.internal.resources.MarkerSet: int size()>
<org.eclipse.core.internal.resources.MarkerSet: java.lang.Object clone()>
<org.eclipse.core.internal.resources.MarkerSet: org.eclipse.core.internal.resources.IMarkerSetElement get(long)>
<org.eclipse.core.internal.resources.MarkerSet: org.eclipse.core.internal.resources.IMarkerSetElement[] elements()>
<org.eclipse.core.internal.resources.MarkerSet: void <init>(int)>
<org.eclipse.core.internal.resources.MarkerSet: void add(org.eclipse.core.internal.resources.IMarkerSetElement)>
<org.eclipse.core.internal.resources.MarkerSet: void expand()>
<org.eclipse.core.internal.resources.MarkerSet: void rehashTo(int)>
<org.eclipse.core.internal.resources.MarkerSet: void remove(long)>
<org.eclipse.core.internal.resources.MarkerSet: void remove(org.eclipse.core.internal.resources.IMarkerSetElement)>
<org.eclipse.core.internal.resources.MarkerSet: void shareStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.resources.MarkerTypeDefinitionCache$MarkerTypeDefinition: void <init>(org.eclipse.core.runtime.IExtension)>
<org.eclipse.core.internal.resources.MarkerTypeDefinitionCache: boolean isPersistent(java.lang.String)>
<org.eclipse.core.internal.resources.MarkerTypeDefinitionCache: java.util.Set computeSuperTypes(java.lang.String,java.util.Set)>
<org.eclipse.core.internal.resources.MarkerTypeDefinitionCache: void <init>()>
<org.eclipse.core.internal.resources.MarkerTypeDefinitionCache: void loadDefinitions()>
<org.eclipse.core.internal.resources.MarkerWriter: void <init>(org.eclipse.core.internal.resources.MarkerManager)>
<org.eclipse.core.internal.resources.MarkerWriter: void snap(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.watson.IPathRequestor,java.io.DataOutputStream)>
<org.eclipse.core.internal.resources.ModelObject: java.lang.Object clone()>
<org.eclipse.core.internal.resources.ModelObject: java.lang.String getName()>
<org.eclipse.core.internal.resources.ModelObject: void <init>()>
<org.eclipse.core.internal.resources.ModelObject: void <init>(java.lang.String)>
<org.eclipse.core.internal.resources.ModelObject: void setName(java.lang.String)>
<org.eclipse.core.internal.resources.MoveDeleteHook: boolean deleteProject(org.eclipse.core.resources.team.IResourceTree,org.eclipse.core.resources.IProject,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.MoveDeleteHook: void <init>()>
<org.eclipse.core.internal.resources.NatureManager: void <init>()>
<org.eclipse.core.internal.resources.NatureManager: void configureNatures(org.eclipse.core.internal.resources.Project,org.eclipse.core.internal.resources.ProjectDescription,org.eclipse.core.internal.resources.ProjectDescription,org.eclipse.core.runtime.MultiStatus)>
<org.eclipse.core.internal.resources.NatureManager: void flushEnablements(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.NatureManager: void handleEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.resources.NatureManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.OS: boolean isNameValid(java.lang.String)>
<org.eclipse.core.internal.resources.OS: void <clinit>()>
<org.eclipse.core.internal.resources.PathVariableManager: org.eclipse.core.runtime.IPath resolvePath(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.PathVariableManager: void <init>()>
<org.eclipse.core.internal.resources.PathVariableManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.PlatformURLResourceConnection: void startup(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.PreferenceInitializer: void <init>()>
<org.eclipse.core.internal.resources.PreferenceInitializer: void initializeDefaultPreferences()>
<org.eclipse.core.internal.resources.Project: boolean hasNature(java.lang.String)>
<org.eclipse.core.internal.resources.Project: boolean isAccessible()>
<org.eclipse.core.internal.resources.Project: boolean isLocal(int,int)>
<org.eclipse.core.internal.resources.Project: boolean isOpen()>
<org.eclipse.core.internal.resources.Project: boolean isOpen(int)>
<org.eclipse.core.internal.resources.Project: int getType()>
<org.eclipse.core.internal.resources.Project: org.eclipse.core.internal.resources.ProjectDescription internalGetDescription()>
<org.eclipse.core.internal.resources.Project: org.eclipse.core.resources.IProject getProject()>
<org.eclipse.core.internal.resources.Project: org.eclipse.core.resources.IProjectDescription getDescription()>
<org.eclipse.core.internal.resources.Project: org.eclipse.core.runtime.IPath getWorkingLocation(java.lang.String)>
<org.eclipse.core.internal.resources.Project: org.eclipse.core.runtime.IStatus reconcileLinks(org.eclipse.core.internal.resources.ProjectDescription)>
<org.eclipse.core.internal.resources.Project: org.eclipse.core.runtime.MultiStatus basicSetDescription(org.eclipse.core.internal.resources.ProjectDescription,int)>
<org.eclipse.core.internal.resources.Project: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.Project: void build(int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void checkAccessible(int)>
<org.eclipse.core.internal.resources.Project: void checkDescription(org.eclipse.core.resources.IProject,org.eclipse.core.resources.IProjectDescription,boolean)>
<org.eclipse.core.internal.resources.Project: void create(org.eclipse.core.resources.IProjectDescription,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void create(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void delete(boolean,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void internalSetDescription(org.eclipse.core.resources.IProjectDescription,boolean)>
<org.eclipse.core.internal.resources.Project: void open(int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void open(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void setDescription(org.eclipse.core.resources.IProjectDescription,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void setDescription(org.eclipse.core.resources.IProjectDescription,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Project: void startup()>
<org.eclipse.core.internal.resources.Project: void updateDescription()>
<org.eclipse.core.internal.resources.Project: void writeDescription(org.eclipse.core.resources.IProjectDescription,int,boolean,boolean)>
<org.eclipse.core.internal.resources.ProjectContentTypes$ProjectContentTypeSelectionPolicy: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.resources.ProjectContentTypes$ProjectContentTypeSelectionPolicy: java.lang.String getName()>
<org.eclipse.core.internal.resources.ProjectContentTypes$ProjectContentTypeSelectionPolicy: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.resources.ProjectContentTypes$ProjectContentTypeSelectionPolicy: org.eclipse.core.runtime.content.IContentType[] select(org.eclipse.core.runtime.content.IContentType[],boolean,boolean)>
<org.eclipse.core.internal.resources.ProjectContentTypes$ProjectContentTypeSelectionPolicy: org.eclipse.core.runtime.preferences.IScopeContext getDelegate()>
<org.eclipse.core.internal.resources.ProjectContentTypes$ProjectContentTypeSelectionPolicy: void <init>(org.eclipse.core.internal.resources.ProjectContentTypes,org.eclipse.core.internal.resources.Project)>
<org.eclipse.core.internal.resources.ProjectContentTypes: boolean usesContentTypePreferences(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectContentTypes: org.eclipse.core.runtime.content.IContentTypeMatcher createMatcher(org.eclipse.core.internal.resources.Project)>
<org.eclipse.core.internal.resources.ProjectContentTypes: org.eclipse.core.runtime.content.IContentTypeMatcher getMatcherFor(org.eclipse.core.internal.resources.Project)>
<org.eclipse.core.internal.resources.ProjectContentTypes: org.eclipse.core.runtime.content.IContentType[] select(org.eclipse.core.internal.resources.Project,org.eclipse.core.runtime.content.IContentType[],boolean,boolean)>
<org.eclipse.core.internal.resources.ProjectContentTypes: void <clinit>()>
<org.eclipse.core.internal.resources.ProjectContentTypes: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.ProjectDescription: boolean hasNature(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescription: boolean hasPrivateChanges(org.eclipse.core.internal.resources.ProjectDescription)>
<org.eclipse.core.internal.resources.ProjectDescription: boolean hasPublicChanges(org.eclipse.core.internal.resources.ProjectDescription)>
<org.eclipse.core.internal.resources.ProjectDescription: java.lang.Object clone()>
<org.eclipse.core.internal.resources.ProjectDescription: java.lang.String getComment()>
<org.eclipse.core.internal.resources.ProjectDescription: java.lang.String[] getNatureIds(boolean)>
<org.eclipse.core.internal.resources.ProjectDescription: java.util.HashMap getLinks()>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.resources.ICommand[] getBuildSpec(boolean)>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.resources.IProject[] copyAndRemoveDuplicates(org.eclipse.core.resources.IProject[])>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.resources.IProject[] getDynamicReferences()>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.resources.IProject[] getDynamicReferences(boolean)>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.resources.IProject[] getReferencedProjects()>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.resources.IProject[] getReferencedProjects(boolean)>
<org.eclipse.core.internal.resources.ProjectDescription: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.resources.ProjectDescription: void <clinit>()>
<org.eclipse.core.internal.resources.ProjectDescription: void <init>()>
<org.eclipse.core.internal.resources.ProjectDescription: void setBuildSpec(org.eclipse.core.resources.ICommand[])>
<org.eclipse.core.internal.resources.ProjectDescription: void setComment(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescription: void setDynamicReferences(org.eclipse.core.resources.IProject[])>
<org.eclipse.core.internal.resources.ProjectDescription: void setName(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescription: void setNatureIds(java.lang.String[])>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: org.eclipse.core.internal.resources.ProjectDescription read(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: org.eclipse.core.internal.resources.ProjectDescription read(org.xml.sax.InputSource)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void <init>()>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void characters(char[],int,int)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void endBuildCommandElement(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void endBuildSpecElement(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void endElement(java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void endNaturesElement(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void endProjectsElement(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void parseProjectDescription(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectDescriptionReader: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.internal.resources.ProjectInfo: org.eclipse.core.internal.resources.ProjectDescription getDescription()>
<org.eclipse.core.internal.resources.ProjectInfo: org.eclipse.core.runtime.content.IContentTypeMatcher getMatcher()>
<org.eclipse.core.internal.resources.ProjectInfo: void <init>()>
<org.eclipse.core.internal.resources.ProjectInfo: void setDescription(org.eclipse.core.internal.resources.ProjectDescription)>
<org.eclipse.core.internal.resources.ProjectInfo: void setMatcher(org.eclipse.core.runtime.content.IContentTypeMatcher)>
<org.eclipse.core.internal.resources.ProjectPreferences: boolean isAlreadyLoaded(org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.core.internal.resources.ProjectPreferences: boolean nodeExists(java.lang.String)>
<org.eclipse.core.internal.resources.ProjectPreferences: java.lang.String[] computeChildren()>
<org.eclipse.core.internal.resources.ProjectPreferences: org.eclipse.core.internal.preferences.EclipsePreferences internalCreate(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.resources.ProjectPreferences: org.eclipse.core.resources.IFile getFile()>
<org.eclipse.core.internal.resources.ProjectPreferences: org.eclipse.core.resources.IFile getFile(org.eclipse.core.resources.IProject,java.lang.String)>
<org.eclipse.core.internal.resources.ProjectPreferences: org.eclipse.core.runtime.preferences.IEclipsePreferences getLoadLevel()>
<org.eclipse.core.internal.resources.ProjectPreferences: void <clinit>()>
<org.eclipse.core.internal.resources.ProjectPreferences: void <init>()>
<org.eclipse.core.internal.resources.ProjectPreferences: void <init>(org.eclipse.core.internal.preferences.EclipsePreferences,java.lang.String)>
<org.eclipse.core.internal.resources.ProjectPreferences: void deleted(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.ProjectPreferences: void deleted(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.ProjectPreferences: void flush()>
<org.eclipse.core.internal.resources.ProjectPreferences: void load()>
<org.eclipse.core.internal.resources.ProjectPreferences: void loaded()>
<org.eclipse.core.internal.resources.ProjectPreferences: void removeNode(org.osgi.service.prefs.Preferences)>
<org.eclipse.core.internal.resources.Resource$1: boolean visitElement(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.IPathRequestor,java.lang.Object)>
<org.eclipse.core.internal.resources.Resource$1: void <init>(org.eclipse.core.internal.resources.Resource,int,org.eclipse.core.internal.resources.ResourceProxy,org.eclipse.core.resources.IResourceProxyVisitor)>
<org.eclipse.core.internal.resources.Resource: boolean contains(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.resources.Resource: boolean equals(java.lang.Object)>
<org.eclipse.core.internal.resources.Resource: boolean exists()>
<org.eclipse.core.internal.resources.Resource: boolean exists(int,boolean)>
<org.eclipse.core.internal.resources.Resource: boolean isAccessible()>
<org.eclipse.core.internal.resources.Resource: boolean isConflicting(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.resources.Resource: boolean isLinked()>
<org.eclipse.core.internal.resources.Resource: boolean isLocal(int,int)>
<org.eclipse.core.internal.resources.Resource: boolean isMember(int,int)>
<org.eclipse.core.internal.resources.Resource: boolean isUnderLink()>
<org.eclipse.core.internal.resources.Resource: int countResources(int,boolean)>
<org.eclipse.core.internal.resources.Resource: int getFlags(org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.resources.Resource: int hashCode()>
<org.eclipse.core.internal.resources.Resource: java.lang.Object getSessionProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.resources.Resource: java.lang.String getName()>
<org.eclipse.core.internal.resources.Resource: java.lang.String getPersistentProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.internal.localstore.FileSystemResourceManager getLocalManager()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.internal.properties.IPropertyManager getPropertyManager()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.internal.resources.MarkerManager getMarkerManager()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.internal.resources.ResourceInfo getResourceInfo(boolean,boolean)>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.resources.IContainer getParent()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.resources.IMarker createMarker(java.lang.String)>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.resources.IMarker[] findMarkers(java.lang.String,boolean,int)>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.resources.IProject getProject()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.resources.IWorkspace getWorkspace()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.resources.ResourceAttributes getResourceAttributes()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.runtime.IPath getFullPath()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.runtime.IPath makePathAbsolute(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.Resource: org.eclipse.core.runtime.IStatus checkCopyRequirements(org.eclipse.core.runtime.IPath,int,int)>
<org.eclipse.core.internal.resources.Resource: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.Resource: void accept(org.eclipse.core.resources.IResourceProxyVisitor,int)>
<org.eclipse.core.internal.resources.Resource: void assertCopyRequirements(org.eclipse.core.runtime.IPath,int,int)>
<org.eclipse.core.internal.resources.Resource: void checkAccessible(int)>
<org.eclipse.core.internal.resources.Resource: void checkDoesNotExist()>
<org.eclipse.core.internal.resources.Resource: void checkDoesNotExist(int,boolean)>
<org.eclipse.core.internal.resources.Resource: void checkExists(int,boolean)>
<org.eclipse.core.internal.resources.Resource: void checkLocal(int,int)>
<org.eclipse.core.internal.resources.Resource: void checkValidPath(org.eclipse.core.runtime.IPath,int,boolean)>
<org.eclipse.core.internal.resources.Resource: void clearHistory(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Resource: void copy(org.eclipse.core.runtime.IPath,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Resource: void delete(int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Resource: void deleteMarkers(java.lang.String,boolean,int)>
<org.eclipse.core.internal.resources.Resource: void deleteResource(boolean,org.eclipse.core.runtime.MultiStatus)>
<org.eclipse.core.internal.resources.Resource: void internalSetLocal(boolean,int)>
<org.eclipse.core.internal.resources.Resource: void refreshLocal(int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Resource: void setDerived(boolean)>
<org.eclipse.core.internal.resources.Resource: void setLocal(boolean,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Resource: void setPersistentProperty(org.eclipse.core.runtime.QualifiedName,java.lang.String)>
<org.eclipse.core.internal.resources.Resource: void setResourceAttributes(org.eclipse.core.resources.ResourceAttributes)>
<org.eclipse.core.internal.resources.Resource: void setSessionProperty(org.eclipse.core.runtime.QualifiedName,java.lang.Object)>
<org.eclipse.core.internal.resources.Resource: void unprotectedDelete(org.eclipse.core.internal.resources.ResourceTree,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.ResourceException: void <init>(int,org.eclipse.core.runtime.IPath,java.lang.String,java.lang.Throwable)>
<org.eclipse.core.internal.resources.ResourceInfo: boolean isSet(int)>
<org.eclipse.core.internal.resources.ResourceInfo: boolean isSet(int,int)>
<org.eclipse.core.internal.resources.ResourceInfo: int getBits(int,int,int)>
<org.eclipse.core.internal.resources.ResourceInfo: int getCharsetGenerationCount()>
<org.eclipse.core.internal.resources.ResourceInfo: int getContentId()>
<org.eclipse.core.internal.resources.ResourceInfo: int getFlags()>
<org.eclipse.core.internal.resources.ResourceInfo: int getMarkerGenerationCount()>
<org.eclipse.core.internal.resources.ResourceInfo: int getSyncInfoGenerationCount()>
<org.eclipse.core.internal.resources.ResourceInfo: int getType()>
<org.eclipse.core.internal.resources.ResourceInfo: int getType(int)>
<org.eclipse.core.internal.resources.ResourceInfo: java.lang.Object clone()>
<org.eclipse.core.internal.resources.ResourceInfo: java.lang.Object getSessionProperty(org.eclipse.core.runtime.QualifiedName)>
<org.eclipse.core.internal.resources.ResourceInfo: long getLocalSyncInfo()>
<org.eclipse.core.internal.resources.ResourceInfo: long getModificationStamp()>
<org.eclipse.core.internal.resources.ResourceInfo: long getNodeId()>
<org.eclipse.core.internal.resources.ResourceInfo: org.eclipse.core.internal.resources.MarkerSet getMarkers(boolean)>
<org.eclipse.core.internal.resources.ResourceInfo: void <init>()>
<org.eclipse.core.internal.resources.ResourceInfo: void clear(int)>
<org.eclipse.core.internal.resources.ResourceInfo: void clearModificationStamp()>
<org.eclipse.core.internal.resources.ResourceInfo: void incrementContentId()>
<org.eclipse.core.internal.resources.ResourceInfo: void incrementMarkerGenerationCount()>
<org.eclipse.core.internal.resources.ResourceInfo: void incrementModificationStamp()>
<org.eclipse.core.internal.resources.ResourceInfo: void set(int)>
<org.eclipse.core.internal.resources.ResourceInfo: void setBits(int,int,int)>
<org.eclipse.core.internal.resources.ResourceInfo: void setLocalSyncInfo(long)>
<org.eclipse.core.internal.resources.ResourceInfo: void setMarkers(org.eclipse.core.internal.resources.MarkerSet)>
<org.eclipse.core.internal.resources.ResourceInfo: void setNodeId(long)>
<org.eclipse.core.internal.resources.ResourceInfo: void setSessionProperty(org.eclipse.core.runtime.QualifiedName,java.lang.Object)>
<org.eclipse.core.internal.resources.ResourceInfo: void setSyncInfo(org.eclipse.core.internal.utils.ObjectMap)>
<org.eclipse.core.internal.resources.ResourceInfo: void setType(int)>
<org.eclipse.core.internal.resources.ResourceInfo: void shareStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.resources.ResourceInfo: void writeTo(java.io.DataOutput)>
<org.eclipse.core.internal.resources.ResourceProxy: int getType()>
<org.eclipse.core.internal.resources.ResourceProxy: java.lang.String getName()>
<org.eclipse.core.internal.resources.ResourceProxy: org.eclipse.core.resources.IResource requestResource()>
<org.eclipse.core.internal.resources.ResourceProxy: org.eclipse.core.runtime.IPath requestFullPath()>
<org.eclipse.core.internal.resources.ResourceProxy: void <init>()>
<org.eclipse.core.internal.resources.ResourceProxy: void reset()>
<org.eclipse.core.internal.resources.ResourceStatus: int getSeverity(int)>
<org.eclipse.core.internal.resources.ResourceStatus: void <init>(int,int,org.eclipse.core.runtime.IPath,java.lang.String,java.lang.Throwable)>
<org.eclipse.core.internal.resources.ResourceStatus: void <init>(int,org.eclipse.core.runtime.IPath,java.lang.String,java.lang.Throwable)>
<org.eclipse.core.internal.resources.ResourceTree: org.eclipse.core.runtime.IStatus getStatus()>
<org.eclipse.core.internal.resources.ResourceTree: void <init>(org.eclipse.core.runtime.jobs.ILock,org.eclipse.core.runtime.MultiStatus,int)>
<org.eclipse.core.internal.resources.ResourceTree: void deletedProject(org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.ResourceTree: void makeInvalid()>
<org.eclipse.core.internal.resources.ResourceTree: void standardDeleteProject(org.eclipse.core.resources.IProject,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.ResourcesCompatibilityHelper: org.eclipse.core.internal.localstore.IHistoryStore createHistoryStore(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.resources.ResourcesCompatibilityHelper: org.eclipse.core.internal.localstore.IHistoryStore createHistoryStore(org.eclipse.core.runtime.IPath,int,boolean,boolean,boolean)>
<org.eclipse.core.internal.resources.ResourcesCompatibilityHelper: org.eclipse.core.internal.properties.IPropertyManager createPropertyManager()>
<org.eclipse.core.internal.resources.ResourcesCompatibilityHelper: org.eclipse.core.internal.properties.IPropertyManager createPropertyManager(boolean,boolean)>
<org.eclipse.core.internal.resources.RootInfo: void <init>()>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.resources.IResourceRuleFactory factoryFor(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule buildRule()>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule copyRule(org.eclipse.core.resources.IResource,org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule createRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule deleteRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule markerRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule modifyRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: org.eclipse.core.runtime.jobs.ISchedulingRule refreshRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Rules: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.Rules: void handleEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.resources.Rules: void setRuleFactory(org.eclipse.core.resources.IProject,org.eclipse.core.resources.IResourceRuleFactory)>
<org.eclipse.core.internal.resources.SafeFileTable: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.resources.SafeFileTable: void <init>(java.lang.String)>
<org.eclipse.core.internal.resources.SafeFileTable: void restore()>
<org.eclipse.core.internal.resources.SaveContext: int getKind()>
<org.eclipse.core.internal.resources.SaveContext: org.eclipse.core.internal.resources.Workspace getWorkspace()>
<org.eclipse.core.internal.resources.SaveContext: org.eclipse.core.resources.IProject getProject()>
<org.eclipse.core.internal.resources.SaveContext: void <init>(org.eclipse.core.runtime.Plugin,int,org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.SaveContext: void commit()>
<org.eclipse.core.internal.resources.SaveManager$1: void <init>(org.eclipse.core.internal.resources.SaveManager,org.eclipse.core.runtime.MultiStatus,java.util.Iterator,int,org.eclipse.core.resources.ISaveParticipant,org.eclipse.core.internal.resources.SaveContext)>
<org.eclipse.core.internal.resources.SaveManager$1: void run()>
<org.eclipse.core.internal.resources.SaveManager$4: boolean visitElement(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.IPathRequestor,java.lang.Object)>
<org.eclipse.core.internal.resources.SaveManager$4: void <init>(org.eclipse.core.internal.resources.SaveManager,org.eclipse.core.internal.resources.MarkerManager,java.io.DataOutputStream,long[],java.io.DataOutputStream,org.eclipse.core.internal.resources.Synchronizer,org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.SaveManager: int getSaveNumber(java.lang.String)>
<org.eclipse.core.internal.resources.SaveManager: java.util.Map computeSaveContexts(org.eclipse.core.runtime.Plugin[],int,org.eclipse.core.resources.IProject)>
<org.eclipse.core.internal.resources.SaveManager: java.util.Properties getMasterTable()>
<org.eclipse.core.internal.resources.SaveManager: org.eclipse.core.resources.ISavedState addParticipant(org.eclipse.core.runtime.Plugin,org.eclipse.core.resources.ISaveParticipant)>
<org.eclipse.core.internal.resources.SaveManager: org.eclipse.core.runtime.IStatus save(int,org.eclipse.core.internal.resources.Project,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: org.eclipse.core.runtime.IStatus saveMetaInfo(org.eclipse.core.internal.resources.Project,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: org.eclipse.core.runtime.Plugin[] getSaveParticipantPlugins()>
<org.eclipse.core.internal.resources.SaveManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.SaveManager: void broadcastLifecycle(int,java.util.Map,org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void clearSavedDelta()>
<org.eclipse.core.internal.resources.SaveManager: void collapseTrees()>
<org.eclipse.core.internal.resources.SaveManager: void commit(java.util.Map)>
<org.eclipse.core.internal.resources.SaveManager: void executeLifecycle(int,org.eclipse.core.resources.ISaveParticipant,org.eclipse.core.internal.resources.SaveContext)>
<org.eclipse.core.internal.resources.SaveManager: void hookEndSave(int,org.eclipse.core.resources.IProject,long)>
<org.eclipse.core.internal.resources.SaveManager: void hookStartSave(int,org.eclipse.core.internal.resources.Project)>
<org.eclipse.core.internal.resources.SaveManager: void initSnap(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void requestSnapshot()>
<org.eclipse.core.internal.resources.SaveManager: void restore(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void restoreMarkers(org.eclipse.core.resources.IResource,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void restoreMasterTable()>
<org.eclipse.core.internal.resources.SaveManager: void restoreMetaInfo(org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void restoreSnapshots(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void restoreSyncInfo(org.eclipse.core.resources.IResource,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void restoreTree(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void saveMasterTable()>
<org.eclipse.core.internal.resources.SaveManager: void saveMasterTable(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.SaveManager: void saveMetaInfo(org.eclipse.core.runtime.MultiStatus,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void shareStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.resources.SaveManager: void snapTree(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void snapshotIfNeeded(boolean)>
<org.eclipse.core.internal.resources.SaveManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SaveManager: void visitAndSnap(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.SaveManager: void writeElement(org.eclipse.core.runtime.IPath,java.lang.Object,java.io.DataOutput)>
<org.eclipse.core.internal.resources.SaveManager: void writeWorkspaceFields(java.io.DataOutputStream,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.SyncInfoWriter: void <init>(org.eclipse.core.internal.resources.Workspace,org.eclipse.core.internal.resources.Synchronizer)>
<org.eclipse.core.internal.resources.SyncInfoWriter: void savePartners(java.io.DataOutputStream)>
<org.eclipse.core.internal.resources.SyncInfoWriter: void snapSyncInfo(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.watson.IPathRequestor,java.io.DataOutputStream)>
<org.eclipse.core.internal.resources.Synchronizer: java.util.Set getRegistry()>
<org.eclipse.core.internal.resources.Synchronizer: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.Synchronizer: void restore(org.eclipse.core.resources.IResource,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Synchronizer: void restoreFromSave(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Synchronizer: void restoreFromSnap(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Synchronizer: void savePartners(java.io.DataOutputStream)>
<org.eclipse.core.internal.resources.Synchronizer: void snapSyncInfo(org.eclipse.core.internal.resources.ResourceInfo,org.eclipse.core.internal.watson.IPathRequestor,java.io.DataOutputStream)>
<org.eclipse.core.internal.resources.WorkManager$NotifyRule: void <init>(org.eclipse.core.internal.resources.WorkManager)>
<org.eclipse.core.internal.resources.WorkManager: boolean checkInFailed(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.resources.WorkManager: boolean isBalanced()>
<org.eclipse.core.internal.resources.WorkManager: boolean shouldBuild()>
<org.eclipse.core.internal.resources.WorkManager: int beginUnprotected()>
<org.eclipse.core.internal.resources.WorkManager: int getPreparedOperationDepth()>
<org.eclipse.core.internal.resources.WorkManager: org.eclipse.core.runtime.jobs.ILock getLock()>
<org.eclipse.core.internal.resources.WorkManager: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.WorkManager: void checkIn(org.eclipse.core.runtime.jobs.ISchedulingRule,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.WorkManager: void checkOut(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.resources.WorkManager: void decrementPreparedOperations()>
<org.eclipse.core.internal.resources.WorkManager: void endUnprotected(int)>
<org.eclipse.core.internal.resources.WorkManager: void incrementNestedOperations()>
<org.eclipse.core.internal.resources.WorkManager: void incrementPreparedOperations()>
<org.eclipse.core.internal.resources.WorkManager: void rebalanceNestedOperations()>
<org.eclipse.core.internal.resources.WorkManager: void setBuild(boolean)>
<org.eclipse.core.internal.resources.WorkManager: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace$2: boolean visitElement(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.IPathRequestor,java.lang.Object)>
<org.eclipse.core.internal.resources.Workspace$2: void <init>(org.eclipse.core.internal.resources.Workspace,boolean,int[])>
<org.eclipse.core.internal.resources.Workspace$3: void <init>(org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.resources.Workspace: boolean canCreateExtensions()>
<org.eclipse.core.internal.resources.Workspace: boolean clear(java.io.File)>
<org.eclipse.core.internal.resources.Workspace: boolean clearChildren(java.io.File)>
<org.eclipse.core.internal.resources.Workspace: boolean isAutoBuilding()>
<org.eclipse.core.internal.resources.Workspace: boolean isOpen()>
<org.eclipse.core.internal.resources.Workspace: boolean isTreeLocked()>
<org.eclipse.core.internal.resources.Workspace: boolean refreshRequested()>
<org.eclipse.core.internal.resources.Workspace: int countResources(org.eclipse.core.runtime.IPath,int,boolean)>
<org.eclipse.core.internal.resources.Workspace: long nextMarkerId()>
<org.eclipse.core.internal.resources.Workspace: long nextNodeId()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.events.BuildManager getBuildManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.localstore.FileSystemResourceManager getFileSystemManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.properties.IPropertyManager getPropertyManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.AliasManager getAliasManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.CharsetManager getCharsetManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.ContentDescriptionManager getContentDescriptionManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.LocalMetaArea getMetaArea()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.MarkerManager getMarkerManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.NatureManager getNatureManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.Resource newResource(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.ResourceInfo createResource(org.eclipse.core.resources.IResource,boolean)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.ResourceInfo createResource(org.eclipse.core.resources.IResource,org.eclipse.core.internal.resources.ResourceInfo,boolean,boolean,boolean)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.ResourceInfo getResourceInfo(org.eclipse.core.runtime.IPath,boolean,boolean)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.ResourceInfo newElement(int)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.SaveManager getSaveManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.WorkManager getWorkManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.WorkspaceDescription defaultWorkspaceDescription()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.resources.WorkspaceDescription internalGetDescription()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.watson.ElementTree getElementTree()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.internal.watson.ElementTree newWorkingTree()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.IPathVariableManager getPathVariableManager()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.IResourceRuleFactory getRuleFactory()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.ISavedState addSaveParticipant(org.eclipse.core.runtime.Plugin,org.eclipse.core.resources.ISaveParticipant)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.ISynchronizer getSynchronizer()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.IWorkspaceDescription getDescription()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.IWorkspaceRoot getRoot()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.team.IMoveDeleteHook getMoveDeleteHook()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.resources.team.TeamHook getTeamHook()>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.runtime.IStatus open(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.runtime.IStatus validateName(java.lang.String,int)>
<org.eclipse.core.internal.resources.Workspace: org.eclipse.core.runtime.IStatus validatePath(org.eclipse.core.runtime.IPath,int,boolean)>
<org.eclipse.core.internal.resources.Workspace: void <clinit>()>
<org.eclipse.core.internal.resources.Workspace: void <init>()>
<org.eclipse.core.internal.resources.Workspace: void aboutToBuild(java.lang.Object,int)>
<org.eclipse.core.internal.resources.Workspace: void addLifecycleListener(org.eclipse.core.internal.events.ILifecycleListener)>
<org.eclipse.core.internal.resources.Workspace: void addResourceChangeListener(org.eclipse.core.resources.IResourceChangeListener,int)>
<org.eclipse.core.internal.resources.Workspace: void beginOperation(boolean)>
<org.eclipse.core.internal.resources.Workspace: void broadcastBuildEvent(java.lang.Object,int,int)>
<org.eclipse.core.internal.resources.Workspace: void broadcastEvent(org.eclipse.core.internal.events.LifecycleEvent)>
<org.eclipse.core.internal.resources.Workspace: void broadcastPostChange()>
<org.eclipse.core.internal.resources.Workspace: void deleteResource(org.eclipse.core.resources.IResource)>
<org.eclipse.core.internal.resources.Workspace: void endOperation(org.eclipse.core.runtime.jobs.ISchedulingRule,boolean,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace: void flushBuildOrder()>
<org.eclipse.core.internal.resources.Workspace: void initializeMoveDeleteHook()>
<org.eclipse.core.internal.resources.Workspace: void initializeTeamHook()>
<org.eclipse.core.internal.resources.Workspace: void prepareOperation(org.eclipse.core.runtime.jobs.ISchedulingRule,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace: void run(org.eclipse.core.resources.IWorkspaceRunnable,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace: void run(org.eclipse.core.resources.IWorkspaceRunnable,org.eclipse.core.runtime.jobs.ISchedulingRule,int,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace: void setDescription(org.eclipse.core.resources.IWorkspaceDescription)>
<org.eclipse.core.internal.resources.Workspace: void setTreeLocked(boolean)>
<org.eclipse.core.internal.resources.Workspace: void startup(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.resources.Workspace: void updateModificationStamp(org.eclipse.core.internal.resources.ResourceInfo)>
<org.eclipse.core.internal.resources.WorkspaceDescription: boolean isAutoBuilding()>
<org.eclipse.core.internal.resources.WorkspaceDescription: int getMaxBuildIterations()>
<org.eclipse.core.internal.resources.WorkspaceDescription: int getMaxFileStates()>
<org.eclipse.core.internal.resources.WorkspaceDescription: int getOperationsPerSnapshot()>
<org.eclipse.core.internal.resources.WorkspaceDescription: java.lang.String[] getBuildOrder()>
<org.eclipse.core.internal.resources.WorkspaceDescription: java.lang.String[] getBuildOrder(boolean)>
<org.eclipse.core.internal.resources.WorkspaceDescription: long getDeltaExpiration()>
<org.eclipse.core.internal.resources.WorkspaceDescription: long getFileStateLongevity()>
<org.eclipse.core.internal.resources.WorkspaceDescription: long getMaxFileStateSize()>
<org.eclipse.core.internal.resources.WorkspaceDescription: long getSnapshotInterval()>
<org.eclipse.core.internal.resources.WorkspaceDescription: void <init>(java.lang.String)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setAutoBuilding(boolean)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setBuildOrder(java.lang.String[])>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setDeltaExpiration(long)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setFileStateLongevity(long)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setMaxBuildIterations(int)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setMaxFileStateSize(long)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setMaxFileStates(int)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setOperationsPerSnapshot(int)>
<org.eclipse.core.internal.resources.WorkspaceDescription: void setSnapshotInterval(long)>
<org.eclipse.core.internal.resources.WorkspaceDescriptionReader: java.lang.Object read(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.resources.WorkspaceDescriptionReader: void <clinit>()>
<org.eclipse.core.internal.resources.WorkspaceDescriptionReader: void <init>()>
<org.eclipse.core.internal.resources.WorkspacePreferences$1: void <init>(org.eclipse.core.internal.resources.WorkspacePreferences)>
<org.eclipse.core.internal.resources.WorkspacePreferences$1: void propertyChange(org.eclipse.core.runtime.Preferences$PropertyChangeEvent)>
<org.eclipse.core.internal.resources.WorkspacePreferences: java.lang.String convertStringArraytoString(java.lang.String[])>
<org.eclipse.core.internal.resources.WorkspacePreferences: java.lang.String[] getBuildOrder()>
<org.eclipse.core.internal.resources.WorkspacePreferences: java.lang.String[] getBuildOrder(boolean)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void <init>()>
<org.eclipse.core.internal.resources.WorkspacePreferences: void copyFrom(org.eclipse.core.internal.resources.WorkspaceDescription)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void copyFromTo(org.eclipse.core.internal.resources.WorkspaceDescription,org.eclipse.core.internal.resources.WorkspaceDescription)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void copyTo(org.eclipse.core.internal.resources.WorkspaceDescription)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setAutoBuilding(boolean)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setBuildOrder(java.lang.String[])>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setDeltaExpiration(long)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setFileStateLongevity(long)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setMaxBuildIterations(int)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setMaxFileStateSize(long)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setMaxFileStates(int)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setOperationsPerSnapshot(int)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void setSnapshotInterval(long)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void synchronizeWithPreferences(java.lang.String)>
<org.eclipse.core.internal.resources.WorkspacePreferences: void upgradeVersion(java.lang.String)>
<org.eclipse.core.internal.resources.WorkspaceRoot: boolean exists(int,boolean)>
<org.eclipse.core.internal.resources.WorkspaceRoot: boolean isLocal(int,int)>
<org.eclipse.core.internal.resources.WorkspaceRoot: int getType()>
<org.eclipse.core.internal.resources.WorkspaceRoot: java.lang.String getDefaultCharset(boolean)>
<org.eclipse.core.internal.resources.WorkspaceRoot: org.eclipse.core.resources.IProject getProject(java.lang.String)>
<org.eclipse.core.internal.resources.WorkspaceRoot: org.eclipse.core.resources.IProject[] getProjects()>
<org.eclipse.core.internal.resources.WorkspaceRoot: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.resources.WorkspaceRoot: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.internal.resources.Workspace)>
<org.eclipse.core.internal.runtime.Assert: boolean isLegal(boolean)>
<org.eclipse.core.internal.runtime.Assert: boolean isLegal(boolean,java.lang.String)>
<org.eclipse.core.internal.runtime.Assert: boolean isTrue(boolean)>
<org.eclipse.core.internal.runtime.Assert: boolean isTrue(boolean,java.lang.String)>
<org.eclipse.core.internal.runtime.Assert: void isNotNull(java.lang.Object)>
<org.eclipse.core.internal.runtime.Assert: void isNotNull(java.lang.Object,java.lang.String)>
<org.eclipse.core.internal.runtime.AuthorizationHandler: void <clinit>()>
<org.eclipse.core.internal.runtime.AuthorizationHandler: void setKeyringFile(java.lang.String)>
<org.eclipse.core.internal.runtime.AuthorizationHandler: void setPassword(java.lang.String)>
<org.eclipse.core.internal.runtime.CompatibilityHelper: boolean hasPluginObject(org.eclipse.core.runtime.IPluginDescriptor)>
<org.eclipse.core.internal.runtime.CompatibilityHelper: org.eclipse.core.runtime.IPluginDescriptor getPluginDescriptor(java.lang.String)>
<org.eclipse.core.internal.runtime.CompatibilityHelper: org.osgi.framework.Bundle initializeCompatibility()>
<org.eclipse.core.internal.runtime.CompatibilityHelper: void <clinit>()>
<org.eclipse.core.internal.runtime.CompatibilityHelper: void setActive(org.eclipse.core.runtime.IPluginDescriptor)>
<org.eclipse.core.internal.runtime.CompatibilityHelper: void setPlugin(org.eclipse.core.runtime.IPluginDescriptor,org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.runtime.DataArea: org.eclipse.core.runtime.IPath getMetadataLocation()>
<org.eclipse.core.internal.runtime.DataArea: org.eclipse.core.runtime.IPath getPreferenceLocation(java.lang.String,boolean)>
<org.eclipse.core.internal.runtime.DataArea: org.eclipse.core.runtime.IPath getStateLocation(java.lang.String)>
<org.eclipse.core.internal.runtime.DataArea: org.eclipse.core.runtime.IPath getStateLocation(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.DataArea: void <init>()>
<org.eclipse.core.internal.runtime.DataArea: void assertLocationInitialized()>
<org.eclipse.core.internal.runtime.DataArea: void createLocation()>
<org.eclipse.core.internal.runtime.DataArea: void initializeLocation()>
<org.eclipse.core.internal.runtime.FindSupport: java.lang.String[] buildNLVariants(java.lang.String)>
<org.eclipse.core.internal.runtime.FindSupport: java.net.URL find(org.osgi.framework.Bundle,org.eclipse.core.runtime.IPath,java.util.Map)>
<org.eclipse.core.internal.runtime.FindSupport: java.net.URL findInFragments(org.osgi.framework.Bundle,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.runtime.FindSupport: java.net.URL findInPlugin(org.osgi.framework.Bundle,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.runtime.FindSupport: void <clinit>()>
<org.eclipse.core.internal.runtime.HashMapOfString: int size()>
<org.eclipse.core.internal.runtime.HashMapOfString: java.lang.String get(java.lang.String)>
<org.eclipse.core.internal.runtime.HashMapOfString: java.lang.String put(java.lang.String,java.lang.String)>
<org.eclipse.core.internal.runtime.HashMapOfString: java.lang.String removeKey(java.lang.String)>
<org.eclipse.core.internal.runtime.HashMapOfString: java.lang.String[] keys()>
<org.eclipse.core.internal.runtime.HashMapOfString: void <init>()>
<org.eclipse.core.internal.runtime.HashMapOfString: void <init>(int)>
<org.eclipse.core.internal.runtime.HashMapOfString: void rehash(int)>
<org.eclipse.core.internal.runtime.HashMapOfString: void shareStrings(org.eclipse.core.internal.preferences.StringPool)>
<org.eclipse.core.internal.runtime.InternalPlatform$2: void <init>(org.eclipse.core.internal.runtime.InternalPlatform,org.eclipse.core.runtime.ILogListener,org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.runtime.InternalPlatform$2: void run()>
<org.eclipse.core.internal.runtime.InternalPlatform: boolean getBooleanOption(java.lang.String,boolean)>
<org.eclipse.core.internal.runtime.InternalPlatform: boolean isFragment(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.InternalPlatform: boolean isRunning()>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.Runnable getSplashHandler()>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String getBundleId(java.lang.Object)>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String getNL()>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String getOS()>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String getOption(java.lang.String)>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String[] getApplicationArgs()>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String[] getCommandLineArgs()>
<org.eclipse.core.internal.runtime.InternalPlatform: java.lang.String[] processCommandLine(java.lang.String[])>
<org.eclipse.core.internal.runtime.InternalPlatform: java.net.URL asActualURL(java.net.URL)>
<org.eclipse.core.internal.runtime.InternalPlatform: java.net.URL asLocalURL(java.net.URL)>
<org.eclipse.core.internal.runtime.InternalPlatform: java.net.URL getInstallURL()>
<org.eclipse.core.internal.runtime.InternalPlatform: long getStateTimeStamp()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.internal.runtime.DataArea getMetaArea()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.internal.runtime.InternalPlatform getDefault()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.IExtensionRegistry getRegistry()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.ILog getLog(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.IPath getStateLocation(org.osgi.framework.Bundle,boolean)>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.IProduct getProduct()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.Plugin getRuntimeInstance()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.adaptor.FileManager getRuntimeFileManager()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.content.IContentTypeManager getContentTypeManager()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.jobs.IJobManager getJobManager()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.core.runtime.preferences.IPreferencesService getPreferencesService()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.osgi.framework.log.FrameworkLog getFrameworkLog()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.osgi.service.datalocation.Location getConfigurationLocation()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.osgi.service.datalocation.Location getInstallLocation()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.osgi.service.datalocation.Location getInstanceLocation()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.eclipse.osgi.service.resolver.PlatformAdmin getPlatformAdmin()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.osgi.framework.Bundle getBundle(java.lang.String)>
<org.eclipse.core.internal.runtime.InternalPlatform: org.osgi.framework.BundleContext getBundleContext()>
<org.eclipse.core.internal.runtime.InternalPlatform: org.osgi.framework.Bundle[] getFragments(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.InternalPlatform: void <clinit>()>
<org.eclipse.core.internal.runtime.InternalPlatform: void <init>()>
<org.eclipse.core.internal.runtime.InternalPlatform: void addLogListener(org.eclipse.core.runtime.ILogListener)>
<org.eclipse.core.internal.runtime.InternalPlatform: void assertInitialized()>
<org.eclipse.core.internal.runtime.InternalPlatform: void handleException(org.eclipse.core.runtime.ISafeRunnable,java.lang.Throwable)>
<org.eclipse.core.internal.runtime.InternalPlatform: void initializeAuthorizationHandler()>
<org.eclipse.core.internal.runtime.InternalPlatform: void initializeDebugFlags()>
<org.eclipse.core.internal.runtime.InternalPlatform: void initializeLocationTrackers()>
<org.eclipse.core.internal.runtime.InternalPlatform: void initializeRuntimeFileManager()>
<org.eclipse.core.internal.runtime.InternalPlatform: void log(org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.runtime.InternalPlatform: void registerBundleGroupProvider(org.eclipse.core.runtime.IBundleGroupProvider)>
<org.eclipse.core.internal.runtime.InternalPlatform: void run(org.eclipse.core.runtime.ISafeRunnable)>
<org.eclipse.core.internal.runtime.InternalPlatform: void setExtensionRegistry(org.eclipse.core.runtime.IExtensionRegistry)>
<org.eclipse.core.internal.runtime.InternalPlatform: void setRuntimeInstance(org.eclipse.core.runtime.Plugin)>
<org.eclipse.core.internal.runtime.InternalPlatform: void start(org.osgi.framework.BundleContext)>
<org.eclipse.core.internal.runtime.ListenerList: boolean isEmpty()>
<org.eclipse.core.internal.runtime.ListenerList: boolean same(java.lang.Object,java.lang.Object)>
<org.eclipse.core.internal.runtime.ListenerList: int size()>
<org.eclipse.core.internal.runtime.ListenerList: java.lang.Object[] getListeners()>
<org.eclipse.core.internal.runtime.ListenerList: void <clinit>()>
<org.eclipse.core.internal.runtime.ListenerList: void <init>()>
<org.eclipse.core.internal.runtime.ListenerList: void <init>(int)>
<org.eclipse.core.internal.runtime.ListenerList: void add(java.lang.Object)>
<org.eclipse.core.internal.runtime.Log: void <init>(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.Log: void log(org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.runtime.Messages: void <clinit>()>
<org.eclipse.core.internal.runtime.Messages: void reloadMessages()>
<org.eclipse.core.internal.runtime.PlatformActivator$1: java.lang.Object run(java.lang.Object)>
<org.eclipse.core.internal.runtime.PlatformActivator$1: void <init>(org.eclipse.core.internal.runtime.PlatformActivator)>
<org.eclipse.core.internal.runtime.PlatformActivator: void <init>()>
<org.eclipse.core.internal.runtime.PlatformActivator: void acquireFrameworkLogService()>
<org.eclipse.core.internal.runtime.PlatformActivator: void acquireInfoService()>
<org.eclipse.core.internal.runtime.PlatformActivator: void acquirePackageAdminService()>
<org.eclipse.core.internal.runtime.PlatformActivator: void acquireURLConverterService()>
<org.eclipse.core.internal.runtime.PlatformActivator: void installPlatformURLSupport()>
<org.eclipse.core.internal.runtime.PlatformActivator: void registerApplicationService()>
<org.eclipse.core.internal.runtime.PlatformActivator: void start(org.osgi.framework.BundleContext)>
<org.eclipse.core.internal.runtime.PlatformActivator: void startInternalPlatform()>
<org.eclipse.core.internal.runtime.PlatformActivator: void startRegistry(org.osgi.framework.BundleContext)>
<org.eclipse.core.internal.runtime.PlatformLogWriter: org.eclipse.osgi.framework.log.FrameworkLogEntry getLog(org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.internal.runtime.PlatformLogWriter: void <init>(org.eclipse.osgi.framework.log.FrameworkLog)>
<org.eclipse.core.internal.runtime.PlatformLogWriter: void logging(org.eclipse.core.runtime.IStatus,java.lang.String)>
<org.eclipse.core.internal.runtime.PlatformURLConfigConnection: void <clinit>()>
<org.eclipse.core.internal.runtime.PlatformURLConfigConnection: void startup()>
<org.eclipse.core.internal.runtime.PlatformURLFragmentConnection: void <clinit>()>
<org.eclipse.core.internal.runtime.PlatformURLFragmentConnection: void startup()>
<org.eclipse.core.internal.runtime.PlatformURLMetaConnection: void <clinit>()>
<org.eclipse.core.internal.runtime.PlatformURLMetaConnection: void startup()>
<org.eclipse.core.internal.runtime.PlatformURLPluginConnection: void <clinit>()>
<org.eclipse.core.internal.runtime.PlatformURLPluginConnection: void startup()>
<org.eclipse.core.internal.runtime.Policy: org.eclipse.core.runtime.IProgressMonitor monitorFor(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.runtime.ResourceTranslator: boolean hasRuntime21(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.ResourceTranslator: java.lang.String getResourceString(org.osgi.framework.Bundle,java.lang.String,java.util.ResourceBundle)>
<org.eclipse.core.internal.runtime.ResourceTranslator: java.util.ResourceBundle getResourceBundle(org.osgi.framework.Bundle)>
<org.eclipse.core.internal.runtime.ResourceTranslator: void start()>
<org.eclipse.core.internal.utils.Assert: boolean isLegal(boolean)>
<org.eclipse.core.internal.utils.Assert: boolean isLegal(boolean,java.lang.String)>
<org.eclipse.core.internal.utils.Assert: boolean isTrue(boolean)>
<org.eclipse.core.internal.utils.Assert: boolean isTrue(boolean,java.lang.String)>
<org.eclipse.core.internal.utils.Assert: void isNotNull(java.lang.Object)>
<org.eclipse.core.internal.utils.Assert: void isNotNull(java.lang.Object,java.lang.String)>
<org.eclipse.core.internal.utils.Cache: org.eclipse.core.internal.utils.Cache$Entry getEntry(java.lang.Object)>
<org.eclipse.core.internal.utils.Cache: org.eclipse.core.internal.utils.Cache$Entry getEntry(java.lang.Object,boolean)>
<org.eclipse.core.internal.utils.Cache: void <init>(int,int,double)>
<org.eclipse.core.internal.utils.Cache: void discardAll()>
<org.eclipse.core.internal.utils.KeyedHashSet: org.eclipse.core.internal.utils.KeyedHashSet$KeyedElement getByKey(java.lang.Object)>
<org.eclipse.core.internal.utils.KeyedHashSet: void <init>(int)>
<org.eclipse.core.internal.utils.KeyedHashSet: void <init>(int,boolean)>
<org.eclipse.core.internal.utils.KeyedHashSet: void clear()>
<org.eclipse.core.internal.utils.Messages: void <clinit>()>
<org.eclipse.core.internal.utils.Policy: org.eclipse.core.runtime.IProgressMonitor monitorFor(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.utils.Policy: org.eclipse.core.runtime.IProgressMonitor subMonitorFor(org.eclipse.core.runtime.IProgressMonitor,int)>
<org.eclipse.core.internal.utils.Policy: org.eclipse.core.runtime.IProgressMonitor subMonitorFor(org.eclipse.core.runtime.IProgressMonitor,int,int)>
<org.eclipse.core.internal.utils.Policy: void <clinit>()>
<org.eclipse.core.internal.utils.Policy: void checkCanceled(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.utils.Queue: boolean isEmpty()>
<org.eclipse.core.internal.utils.Queue: int increment(int)>
<org.eclipse.core.internal.utils.Queue: int size()>
<org.eclipse.core.internal.utils.Queue: java.lang.Object peek()>
<org.eclipse.core.internal.utils.Queue: java.lang.Object remove()>
<org.eclipse.core.internal.utils.Queue: void <init>()>
<org.eclipse.core.internal.utils.Queue: void <init>(int,boolean)>
<org.eclipse.core.internal.utils.Queue: void add(java.lang.Object)>
<org.eclipse.core.internal.utils.Queue: void grow()>
<org.eclipse.core.internal.utils.StringPool: int getSavedStringCount()>
<org.eclipse.core.internal.utils.StringPool: java.lang.String add(java.lang.String)>
<org.eclipse.core.internal.utils.StringPool: void <init>()>
<org.eclipse.core.internal.utils.StringPoolJob$1: void <init>(org.eclipse.core.internal.utils.StringPoolJob,org.eclipse.core.internal.utils.IStringPoolParticipant,org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.utils.StringPoolJob$1: void run()>
<org.eclipse.core.internal.utils.StringPoolJob: int shareStrings(org.eclipse.core.internal.utils.IStringPoolParticipant[],org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.utils.StringPoolJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.core.internal.utils.StringPoolJob: void <init>()>
<org.eclipse.core.internal.utils.StringPoolJob: void addStringPoolParticipant(org.eclipse.core.internal.utils.IStringPoolParticipant,org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.internal.watson.ElementTree$ChildIDsCache: void <init>(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath[])>
<org.eclipse.core.internal.watson.ElementTree: boolean hasChanges(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.IElementComparator,boolean)>
<org.eclipse.core.internal.watson.ElementTree: boolean includes(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTree: boolean isImmutable()>
<org.eclipse.core.internal.watson.ElementTree: java.lang.Object getElementData(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTree: java.lang.Object openElementData(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTree: org.eclipse.core.internal.dtree.DeltaDataTree getDataTree()>
<org.eclipse.core.internal.watson.ElementTree: org.eclipse.core.internal.watson.ElementTree getParent()>
<org.eclipse.core.internal.watson.ElementTree: org.eclipse.core.internal.watson.ElementTree newEmptyDelta()>
<org.eclipse.core.internal.watson.ElementTree: org.eclipse.core.internal.watson.IElementTreeData getTreeData()>
<org.eclipse.core.internal.watson.ElementTree: org.eclipse.core.runtime.IPath[] getChildIDs(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTree: org.eclipse.core.runtime.IPath[] getChildren(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTree: void <clinit>()>
<org.eclipse.core.internal.watson.ElementTree: void <init>()>
<org.eclipse.core.internal.watson.ElementTree: void <init>(org.eclipse.core.internal.watson.ElementTree)>
<org.eclipse.core.internal.watson.ElementTree: void createElement(org.eclipse.core.runtime.IPath,java.lang.Object)>
<org.eclipse.core.internal.watson.ElementTree: void deleteElement(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTree: void immutable()>
<org.eclipse.core.internal.watson.ElementTree: void initialize(org.eclipse.core.internal.dtree.DeltaDataTree)>
<org.eclipse.core.internal.watson.ElementTree: void setTreeData(org.eclipse.core.internal.watson.IElementTreeData)>
<org.eclipse.core.internal.watson.ElementTree: void shareStrings(org.eclipse.core.internal.utils.StringPool)>
<org.eclipse.core.internal.watson.ElementTreeIterator: java.lang.String requestName()>
<org.eclipse.core.internal.watson.ElementTreeIterator: org.eclipse.core.runtime.IPath requestPath()>
<org.eclipse.core.internal.watson.ElementTreeIterator: void <init>(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.internal.watson.ElementTreeIterator: void doIteration(org.eclipse.core.internal.dtree.DataTreeNode,org.eclipse.core.internal.watson.IElementContentVisitor)>
<org.eclipse.core.internal.watson.ElementTreeIterator: void grow()>
<org.eclipse.core.internal.watson.ElementTreeIterator: void iterate(org.eclipse.core.internal.watson.IElementContentVisitor)>
<org.eclipse.core.internal.watson.ElementTreeIterator: void push(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.core.internal.watson.ElementTreeWriter$1: void <init>(org.eclipse.core.internal.watson.ElementTreeWriter,org.eclipse.core.internal.watson.IElementInfoFlattener)>
<org.eclipse.core.internal.watson.ElementTreeWriter$1: void writeData(org.eclipse.core.runtime.IPath,java.lang.Object,java.io.DataOutput)>
<org.eclipse.core.internal.watson.ElementTreeWriter: void <init>(org.eclipse.core.internal.watson.IElementInfoFlattener)>
<org.eclipse.core.internal.watson.ElementTreeWriter: void writeDelta(org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.internal.watson.ElementTree,org.eclipse.core.runtime.IPath,int,java.io.DataOutput,org.eclipse.core.internal.watson.IElementComparator)>
<org.eclipse.core.internal.watson.ElementTreeWriter: void writeNumber(int,java.io.DataOutput)>
<org.eclipse.core.resources.IncrementalProjectBuilder: org.eclipse.core.resources.ICommand getCommand()>
<org.eclipse.core.resources.IncrementalProjectBuilder: org.eclipse.core.resources.IProject getProject()>
<org.eclipse.core.resources.IncrementalProjectBuilder: void <init>()>
<org.eclipse.core.resources.IncrementalProjectBuilder: void setInitializationData(org.eclipse.core.runtime.IConfigurationElement,java.lang.String,java.lang.Object)>
<org.eclipse.core.resources.IncrementalProjectBuilder: void startupOnInitialize()>
<org.eclipse.core.resources.ProjectScope: org.eclipse.core.runtime.preferences.IEclipsePreferences getNode(java.lang.String)>
<org.eclipse.core.resources.ProjectScope: void <init>(org.eclipse.core.resources.IProject)>
<org.eclipse.core.resources.ResourceAttributes: void <init>()>
<org.eclipse.core.resources.ResourceAttributes: void setReadOnly(boolean)>
<org.eclipse.core.resources.ResourcesPlugin: java.lang.String getEncoding()>
<org.eclipse.core.resources.ResourcesPlugin: org.eclipse.core.resources.IWorkspace getWorkspace()>
<org.eclipse.core.resources.ResourcesPlugin: org.eclipse.core.resources.ResourcesPlugin getPlugin()>
<org.eclipse.core.resources.ResourcesPlugin: void <clinit>()>
<org.eclipse.core.resources.ResourcesPlugin: void <init>(org.eclipse.core.runtime.IPluginDescriptor)>
<org.eclipse.core.resources.ResourcesPlugin: void startup()>
<org.eclipse.core.resources.WorkspaceJob: void <init>(java.lang.String)>
<org.eclipse.core.resources.team.ResourceRuleFactory: org.eclipse.core.runtime.jobs.ISchedulingRule copyRule(org.eclipse.core.resources.IResource,org.eclipse.core.resources.IResource)>
<org.eclipse.core.resources.team.ResourceRuleFactory: org.eclipse.core.runtime.jobs.ISchedulingRule createRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.resources.team.ResourceRuleFactory: org.eclipse.core.runtime.jobs.ISchedulingRule deleteRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.resources.team.ResourceRuleFactory: org.eclipse.core.runtime.jobs.ISchedulingRule modifyRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.resources.team.ResourceRuleFactory: org.eclipse.core.runtime.jobs.ISchedulingRule parent(org.eclipse.core.resources.IResource)>
<org.eclipse.core.resources.team.ResourceRuleFactory: org.eclipse.core.runtime.jobs.ISchedulingRule refreshRule(org.eclipse.core.resources.IResource)>
<org.eclipse.core.resources.team.ResourceRuleFactory: void <init>()>
<org.eclipse.core.resources.team.TeamHook: org.eclipse.core.resources.IResourceRuleFactory getRuleFactory(org.eclipse.core.resources.IProject)>
<org.eclipse.core.resources.team.TeamHook: void <init>()>
<org.eclipse.core.runtime.CoreException: org.eclipse.core.runtime.IStatus getStatus()>
<org.eclipse.core.runtime.CoreException: void <init>(org.eclipse.core.runtime.IStatus)>
<org.eclipse.core.runtime.MultiStatus: void <init>(java.lang.String,int,java.lang.String,java.lang.Throwable)>
<org.eclipse.core.runtime.NullProgressMonitor: boolean isCanceled()>
<org.eclipse.core.runtime.NullProgressMonitor: void <init>()>
<org.eclipse.core.runtime.NullProgressMonitor: void beginTask(java.lang.String,int)>
<org.eclipse.core.runtime.NullProgressMonitor: void done()>
<org.eclipse.core.runtime.NullProgressMonitor: void setCanceled(boolean)>
<org.eclipse.core.runtime.NullProgressMonitor: void subTask(java.lang.String)>
<org.eclipse.core.runtime.NullProgressMonitor: void worked(int)>
<org.eclipse.core.runtime.Path: boolean canonicalize()>
<org.eclipse.core.runtime.Path: boolean equals(java.lang.Object)>
<org.eclipse.core.runtime.Path: boolean hasTrailingSeparator()>
<org.eclipse.core.runtime.Path: boolean isAbsolute()>
<org.eclipse.core.runtime.Path: boolean isEmpty()>
<org.eclipse.core.runtime.Path: boolean isPrefixOf(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.runtime.Path: boolean isRoot()>
<org.eclipse.core.runtime.Path: boolean isValidSegment(java.lang.String)>
<org.eclipse.core.runtime.Path: int computeHashCode()>
<org.eclipse.core.runtime.Path: int computeLength()>
<org.eclipse.core.runtime.Path: int computeSegmentCount(java.lang.String)>
<org.eclipse.core.runtime.Path: int hashCode()>
<org.eclipse.core.runtime.Path: int matchingFirstSegments(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.runtime.Path: int segmentCount()>
<org.eclipse.core.runtime.Path: java.io.File toFile()>
<org.eclipse.core.runtime.Path: java.lang.String collapseSlashes(java.lang.String)>
<org.eclipse.core.runtime.Path: java.lang.String getDevice()>
<org.eclipse.core.runtime.Path: java.lang.String lastSegment()>
<org.eclipse.core.runtime.Path: java.lang.String segment(int)>
<org.eclipse.core.runtime.Path: java.lang.String toOSString()>
<org.eclipse.core.runtime.Path: java.lang.String toPortableString()>
<org.eclipse.core.runtime.Path: java.lang.String toString()>
<org.eclipse.core.runtime.Path: java.lang.String[] computeSegments(java.lang.String)>
<org.eclipse.core.runtime.Path: java.lang.String[] segments()>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath addFileExtension(java.lang.String)>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath addTrailingSeparator()>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath append(java.lang.String)>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath append(org.eclipse.core.runtime.IPath)>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath initialize(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath makeAbsolute()>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath makeRelative()>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath removeFirstSegments(int)>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath removeLastSegments(int)>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath removeTrailingSeparator()>
<org.eclipse.core.runtime.Path: org.eclipse.core.runtime.IPath setDevice(java.lang.String)>
<org.eclipse.core.runtime.Path: void <clinit>()>
<org.eclipse.core.runtime.Path: void <init>(java.lang.String)>
<org.eclipse.core.runtime.Path: void <init>(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.Path: void <init>(java.lang.String,java.lang.String[],int)>
<org.eclipse.core.runtime.Path: void collapseParentReferences()>
<org.eclipse.core.runtime.PerformanceStats: boolean isEnabled(java.lang.String)>
<org.eclipse.core.runtime.PerformanceStats: void <clinit>()>
<org.eclipse.core.runtime.PerformanceStats: void <init>(java.lang.String,java.lang.Object)>
<org.eclipse.core.runtime.PerformanceStats: void <init>(java.lang.String,java.lang.Object,java.lang.String)>
<org.eclipse.core.runtime.Platform: boolean isFragment(org.osgi.framework.Bundle)>
<org.eclipse.core.runtime.Platform: boolean isRunning()>
<org.eclipse.core.runtime.Platform: java.lang.String getOS()>
<org.eclipse.core.runtime.Platform: java.lang.String[] getCommandLineArgs()>
<org.eclipse.core.runtime.Platform: java.net.URL asLocalURL(java.net.URL)>
<org.eclipse.core.runtime.Platform: java.net.URL find(org.osgi.framework.Bundle,org.eclipse.core.runtime.IPath)>
<org.eclipse.core.runtime.Platform: long getStateStamp()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.IExtensionRegistry getExtensionRegistry()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.IPluginRegistry getPluginRegistry()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.IProduct getProduct()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.content.IContentTypeManager getContentTypeManager()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.jobs.IJobManager getJobManager()>
<org.eclipse.core.runtime.Platform: org.eclipse.core.runtime.preferences.IPreferencesService getPreferencesService()>
<org.eclipse.core.runtime.Platform: org.eclipse.osgi.service.datalocation.Location getConfigurationLocation()>
<org.eclipse.core.runtime.Platform: org.eclipse.osgi.service.datalocation.Location getInstallLocation()>
<org.eclipse.core.runtime.Platform: org.eclipse.osgi.service.datalocation.Location getInstanceLocation()>
<org.eclipse.core.runtime.Platform: org.osgi.framework.Bundle getBundle(java.lang.String)>
<org.eclipse.core.runtime.Platform: void <clinit>()>
<org.eclipse.core.runtime.Platform: void registerBundleGroupProvider(org.eclipse.core.runtime.IBundleGroupProvider)>
<org.eclipse.core.runtime.Platform: void run(org.eclipse.core.runtime.ISafeRunnable)>
<org.eclipse.core.runtime.PlatformObject: void <init>()>
<org.eclipse.core.runtime.Plugin: boolean isDebugging()>
<org.eclipse.core.runtime.Plugin: org.eclipse.core.runtime.ILog getLog()>
<org.eclipse.core.runtime.Plugin: org.eclipse.core.runtime.IPath getStateLocation()>
<org.eclipse.core.runtime.Plugin: org.eclipse.core.runtime.IPluginDescriptor getDescriptor()>
<org.eclipse.core.runtime.Plugin: org.eclipse.core.runtime.IPluginDescriptor initializeDescriptor(java.lang.String)>
<org.eclipse.core.runtime.Plugin: org.eclipse.core.runtime.Preferences getPluginPreferences()>
<org.eclipse.core.runtime.Plugin: org.osgi.framework.Bundle getBundle()>
<org.eclipse.core.runtime.Plugin: void <init>()>
<org.eclipse.core.runtime.Plugin: void <init>(org.eclipse.core.runtime.IPluginDescriptor)>
<org.eclipse.core.runtime.Plugin: void initializeDefaultPluginPreferences()>
<org.eclipse.core.runtime.Plugin: void internalInitializeDefaultPluginPreferences()>
<org.eclipse.core.runtime.Plugin: void savePluginPreferences()>
<org.eclipse.core.runtime.Plugin: void start(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.Preferences$1: void <init>(org.eclipse.core.runtime.Preferences,org.eclipse.core.runtime.Preferences$IPropertyChangeListener,org.eclipse.core.runtime.Preferences$PropertyChangeEvent)>
<org.eclipse.core.runtime.Preferences$1: void run()>
<org.eclipse.core.runtime.Preferences$PropertyChangeEvent: java.lang.Object getNewValue()>
<org.eclipse.core.runtime.Preferences$PropertyChangeEvent: java.lang.Object getOldValue()>
<org.eclipse.core.runtime.Preferences$PropertyChangeEvent: java.lang.String getProperty()>
<org.eclipse.core.runtime.Preferences$PropertyChangeEvent: void <init>(java.lang.Object,java.lang.String,java.lang.Object,java.lang.Object)>
<org.eclipse.core.runtime.Preferences: void <clinit>()>
<org.eclipse.core.runtime.Preferences: void <init>()>
<org.eclipse.core.runtime.Preferences: void firePropertyChangeEvent(java.lang.String,java.lang.Object,java.lang.Object)>
<org.eclipse.core.runtime.QualifiedName: boolean equals(java.lang.Object)>
<org.eclipse.core.runtime.QualifiedName: int hashCode()>
<org.eclipse.core.runtime.QualifiedName: java.lang.String getLocalName()>
<org.eclipse.core.runtime.QualifiedName: java.lang.String getQualifier()>
<org.eclipse.core.runtime.QualifiedName: void <init>(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.Status: boolean isMultiStatus()>
<org.eclipse.core.runtime.Status: boolean isOK()>
<org.eclipse.core.runtime.Status: int getCode()>
<org.eclipse.core.runtime.Status: int getSeverity()>
<org.eclipse.core.runtime.Status: java.lang.String getMessage()>
<org.eclipse.core.runtime.Status: java.lang.String getPlugin()>
<org.eclipse.core.runtime.Status: java.lang.Throwable getException()>
<org.eclipse.core.runtime.Status: void <clinit>()>
<org.eclipse.core.runtime.Status: void <init>(int,java.lang.String,int,java.lang.String,java.lang.Throwable)>
<org.eclipse.core.runtime.Status: void setCode(int)>
<org.eclipse.core.runtime.Status: void setException(java.lang.Throwable)>
<org.eclipse.core.runtime.Status: void setMessage(java.lang.String)>
<org.eclipse.core.runtime.Status: void setPlugin(java.lang.String)>
<org.eclipse.core.runtime.Status: void setSeverity(int)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor$DomParsingService: void <init>(org.eclipse.core.runtime.adaptor.EclipseAdaptor)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor$SaxParsingService: java.lang.Object getService(org.osgi.framework.Bundle,org.osgi.framework.ServiceRegistration)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor$SaxParsingService: void <init>(org.eclipse.core.runtime.adaptor.EclipseAdaptor)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: boolean canWrite()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: java.io.File[] findStateFiles()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: java.io.InputStream findBundleDataFile()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: org.eclipse.core.runtime.adaptor.FileManager initFileManager(java.io.File,java.lang.String,boolean)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: org.eclipse.osgi.framework.adaptor.BundleData[] getInstalledBundles()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: org.eclipse.osgi.framework.adaptor.core.AdaptorElementFactory getElementFactory()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: org.eclipse.osgi.framework.adaptor.core.StateManager createStateManager()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: org.eclipse.osgi.framework.log.FrameworkLog createFrameworkLog()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: org.eclipse.osgi.framework.log.FrameworkLog createPerformanceLog()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void <init>(java.lang.String[])>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void frameworkStart(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void initBundleStoreRootDir()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void initialize(org.eclipse.osgi.framework.adaptor.EventPublisher)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void initializeMetadata()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void persistNextBundleID(long)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void readHeaders()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void registerEndorsedXMLParser(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void registerPerformanceLog(org.osgi.framework.Bundle)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void saveMetaDataFor(org.eclipse.core.runtime.adaptor.EclipseBundleData)>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void setDebugOptions()>
<org.eclipse.core.runtime.adaptor.EclipseAdaptor: void setLog(org.eclipse.osgi.framework.log.FrameworkLog)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: boolean hasPackageInfo(java.net.URL)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: boolean isAutoStart()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: boolean isAutoStartable()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: boolean isComplete(java.util.Dictionary)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.io.File getParentGenerationDir()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.lang.String findLibrary(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.lang.String searchVariants(java.lang.String[],java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.lang.String[] buildLibraryVariants()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.lang.String[] getAutoStartExceptions()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.util.Dictionary generateManifest(java.util.Dictionary)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.util.Dictionary getManifest()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.util.Dictionary getManifest(boolean)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.util.Dictionary loadManifest()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: java.util.Dictionary loadManifestFrom(java.net.URL)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: org.eclipse.osgi.framework.util.Headers basicCheckManifest(java.lang.String,java.lang.String,java.lang.String,byte)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: org.eclipse.osgi.framework.util.Headers checkManifestAndParent(java.lang.String,java.lang.String,java.lang.String,byte)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void <clinit>()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void <init>(org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor,long)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void loadFromManifest()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void parseAutoStart(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void save()>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void setManifestTimeStamp(long)>
<org.eclipse.core.runtime.adaptor.EclipseBundleData: void setManifestType(byte)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader$EclipseClasspathEntry: boolean hasPackageInfo()>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader$EclipseClasspathEntry: java.util.jar.Manifest getManifest()>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader$EclipseClasspathEntry: void <init>(org.eclipse.core.runtime.adaptor.EclipseClassLoader,org.eclipse.osgi.framework.adaptor.core.BundleFile,java.security.ProtectionDomain)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: boolean isAutoStartable(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: boolean shouldActivateFor(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: java.lang.Class basicFindLocalClass(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: java.lang.Class defineClass(java.lang.String,byte[],int,int,org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: java.lang.Class findLocalClass(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: java.lang.String hasPrefix(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: java.lang.String[] buildNLJarVariants(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: java.net.URL getResource(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry createClassPathEntry(org.eclipse.osgi.framework.adaptor.core.BundleFile,java.security.ProtectionDomain)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: void <clinit>()>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: void <init>(org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate,java.security.ProtectionDomain,java.lang.String[],java.lang.ClassLoader,org.eclipse.osgi.framework.adaptor.BundleData)>
<org.eclipse.core.runtime.adaptor.EclipseClassLoader: void findClassPathEntry(java.util.ArrayList,java.lang.String,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData,java.security.ProtectionDomain)>
<org.eclipse.core.runtime.adaptor.EclipseElementFactory: org.eclipse.osgi.framework.adaptor.BundleClassLoader createClassLoader(org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate,org.eclipse.osgi.framework.adaptor.BundleProtectionDomain,java.lang.String[],org.eclipse.osgi.framework.adaptor.core.AbstractBundleData)>
<org.eclipse.core.runtime.adaptor.EclipseElementFactory: org.eclipse.osgi.framework.adaptor.core.AbstractBundleData createBundleData(org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor,long)>
<org.eclipse.core.runtime.adaptor.EclipseElementFactory: void <init>()>
<org.eclipse.core.runtime.adaptor.EclipseLog: boolean checkLogFileSize()>
<org.eclipse.core.runtime.adaptor.EclipseLog: java.io.Writer logForStream(java.io.OutputStream)>
<org.eclipse.core.runtime.adaptor.EclipseLog: java.lang.String getDate(java.util.Date)>
<org.eclipse.core.runtime.adaptor.EclipseLog: java.lang.String getSessionTimestamp()>
<org.eclipse.core.runtime.adaptor.EclipseLog: java.lang.String getStackTrace(java.lang.Throwable)>
<org.eclipse.core.runtime.adaptor.EclipseLog: java.lang.Throwable getRoot(java.lang.Throwable)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void <clinit>()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void <init>(java.io.File)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void closeFile()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void log(org.eclipse.osgi.framework.log.FrameworkLogEntry)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void openFile()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void readLogProperties()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void setFile(java.io.File,boolean)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void setOutput(java.io.File,java.io.Writer,boolean)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void write(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeArgs(java.lang.String,java.lang.String[])>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeEntry(int,org.eclipse.osgi.framework.log.FrameworkLogEntry)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeLog(int,org.eclipse.osgi.framework.log.FrameworkLogEntry)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeMessage(org.eclipse.osgi.framework.log.FrameworkLogEntry)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeSession()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeSpace()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeStack(org.eclipse.osgi.framework.log.FrameworkLogEntry)>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeln()>
<org.eclipse.core.runtime.adaptor.EclipseLog: void writeln(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseStarter$1: void <init>(java.lang.Runnable)>
<org.eclipse.core.runtime.adaptor.EclipseStarter$2: void <init>(org.eclipse.core.runtime.internal.adaptor.Semaphore)>
<org.eclipse.core.runtime.adaptor.EclipseStarter$2: void frameworkEvent(org.osgi.framework.FrameworkEvent)>
<org.eclipse.core.runtime.adaptor.EclipseStarter$4: void <init>(org.osgi.service.startlevel.StartLevel,int,org.eclipse.core.runtime.internal.adaptor.Semaphore)>
<org.eclipse.core.runtime.adaptor.EclipseStarter$4: void frameworkEvent(org.osgi.framework.FrameworkEvent)>
<org.eclipse.core.runtime.adaptor.EclipseStarter$InitialBundle: void <init>(java.lang.String,java.net.URL,int,boolean)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: boolean isRunning()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: int getStartLevel()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.io.File makeRelative(java.io.File,java.io.File)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.Object run(java.lang.Object)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.Object[] getVersionElements(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.String getSysPath()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.String getSysPathFromURL(java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.String searchFor(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.String[] getArrayFromList(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.lang.String[] processCommandLine(java.lang.String[])>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.net.URL makeRelative(java.net.URL,java.net.URL)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.net.URL searchForBundle(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: java.util.Properties loadProperties(java.net.URL)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: org.eclipse.core.runtime.adaptor.EclipseStarter$InitialBundle[] getInitialBundles(java.lang.String[])>
<org.eclipse.core.runtime.adaptor.EclipseStarter: org.eclipse.osgi.framework.adaptor.FrameworkAdaptor createAdaptor()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: org.eclipse.osgi.framework.log.FrameworkLog createFrameworkLog()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: org.osgi.framework.Bundle getBundleByLocation(java.lang.String,org.osgi.framework.Bundle[])>
<org.eclipse.core.runtime.adaptor.EclipseStarter: org.osgi.framework.Bundle[] getCurrentBundles(boolean)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: org.osgi.framework.Bundle[] loadBasicBundles()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void <clinit>()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void ensureBundlesActive(org.osgi.framework.Bundle[])>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void finalizeProperties()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void initializeApplicationTracker()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void initializeContextFinder()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void installBundles(org.eclipse.core.runtime.adaptor.EclipseStarter$InitialBundle[],org.osgi.framework.Bundle[],java.util.ArrayList,java.util.List)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void loadConfigurationInfo()>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void mergeProperties(java.util.Properties,java.util.Properties)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void publishSplashScreen(java.lang.Runnable)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void refreshPackages(org.osgi.framework.Bundle[])>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void setStartLevel(int)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void startBundles(org.osgi.framework.Bundle[])>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void startup(java.lang.String[],java.lang.Runnable)>
<org.eclipse.core.runtime.adaptor.EclipseStarter: void uninstallBundles(org.osgi.framework.Bundle[],org.eclipse.core.runtime.adaptor.EclipseStarter$InitialBundle[],java.util.List)>
<org.eclipse.core.runtime.adaptor.FileManager$Entry: int getFileType()>
<org.eclipse.core.runtime.adaptor.FileManager$Entry: int getReadId()>
<org.eclipse.core.runtime.adaptor.FileManager$Entry: int getWriteId()>
<org.eclipse.core.runtime.adaptor.FileManager$Entry: void <init>(org.eclipse.core.runtime.adaptor.FileManager,int,int,int)>
<org.eclipse.core.runtime.adaptor.FileManager: boolean isReadOnly()>
<org.eclipse.core.runtime.adaptor.FileManager: boolean lock(boolean)>
<org.eclipse.core.runtime.adaptor.FileManager: int findOldestGeneration(java.lang.String)>
<org.eclipse.core.runtime.adaptor.FileManager: java.io.File lookup(java.lang.String,boolean)>
<org.eclipse.core.runtime.adaptor.FileManager: java.lang.String getAbsolutePath(java.lang.String)>
<org.eclipse.core.runtime.adaptor.FileManager: void <clinit>()>
<org.eclipse.core.runtime.adaptor.FileManager: void <init>(java.io.File,java.lang.String,boolean)>
<org.eclipse.core.runtime.adaptor.FileManager: void add(java.lang.String)>
<org.eclipse.core.runtime.adaptor.FileManager: void add(java.lang.String,int)>
<org.eclipse.core.runtime.adaptor.FileManager: void initializeInstanceFile()>
<org.eclipse.core.runtime.adaptor.FileManager: void open(boolean)>
<org.eclipse.core.runtime.adaptor.FileManager: void release()>
<org.eclipse.core.runtime.adaptor.FileManager: void save()>
<org.eclipse.core.runtime.adaptor.FileManager: void updateTable()>
<org.eclipse.core.runtime.adaptor.LocationManager: boolean canWrite(java.io.File)>
<org.eclipse.core.runtime.adaptor.LocationManager: java.io.File getConfigurationFile(java.lang.String)>
<org.eclipse.core.runtime.adaptor.LocationManager: java.io.File getOSGiConfigurationDir()>
<org.eclipse.core.runtime.adaptor.LocationManager: java.lang.String computeDefaultConfigurationLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: java.net.URL adjustTrailingSlash(java.net.URL,boolean)>
<org.eclipse.core.runtime.adaptor.LocationManager: java.net.URL buildURL(java.lang.String,boolean)>
<org.eclipse.core.runtime.adaptor.LocationManager: java.net.URL computeInstallConfigurationLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: java.net.URL computeSharedConfigurationLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: org.eclipse.osgi.service.datalocation.Location buildLocation(java.lang.String,java.net.URL,java.lang.String,boolean)>
<org.eclipse.core.runtime.adaptor.LocationManager: org.eclipse.osgi.service.datalocation.Location getConfigurationLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: org.eclipse.osgi.service.datalocation.Location getInstallLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: org.eclipse.osgi.service.datalocation.Location getInstanceLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: org.eclipse.osgi.service.datalocation.Location getUserLocation()>
<org.eclipse.core.runtime.adaptor.LocationManager: void <clinit>()>
<org.eclipse.core.runtime.adaptor.LocationManager: void initializeDerivedConfigurationLocations()>
<org.eclipse.core.runtime.adaptor.LocationManager: void initializeLocations()>
<org.eclipse.core.runtime.adaptor.LocationManager: void mungeConfigurationLocation()>
<org.eclipse.core.runtime.adaptor.StreamManager: java.io.InputStream getInputStream(java.lang.String,int)>
<org.eclipse.core.runtime.adaptor.StreamManager: void <clinit>()>
<org.eclipse.core.runtime.adaptor.StreamManager: void <init>(org.eclipse.core.runtime.adaptor.FileManager)>
<org.eclipse.core.runtime.content.IContentDescription: void <clinit>()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: boolean isReadOnly()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: boolean isRunningWithNio()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: boolean isSet()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: boolean setURL(java.net.URL,boolean)>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: java.net.URL getURL()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: org.eclipse.core.runtime.internal.adaptor.Locker createLocker(java.io.File,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: org.eclipse.osgi.service.datalocation.Location getParentLocation()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: void <clinit>()>
<org.eclipse.core.runtime.internal.adaptor.BasicLocation: void <init>(java.lang.String,java.net.URL,boolean)>
<org.eclipse.core.runtime.internal.adaptor.BundleLocalizationImpl: java.util.ResourceBundle getLocalization(org.osgi.framework.Bundle,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.BundleLocalizationImpl: void <init>()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder$1: java.lang.Object run()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder$1: void <init>()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder$Finder: java.lang.Class[] getClassContext()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder$Finder: void <init>()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: boolean checkClassLoader(java.lang.ClassLoader)>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: java.lang.Class loadClass(java.lang.String,boolean)>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: java.lang.ClassLoader basicFindClassLoader()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: java.lang.ClassLoader findClassLoader()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: java.net.URL findResource(java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: void <clinit>()>
<org.eclipse.core.runtime.internal.adaptor.ContextFinder: void <init>(java.lang.ClassLoader)>
<org.eclipse.core.runtime.internal.adaptor.EclipseBundleInstaller: void <init>(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.internal.adaptor.EclipseCommandProvider: void <init>(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: java.lang.String getNL()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: java.lang.String getOS()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: java.lang.String getOSArch()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: java.lang.String getWS()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: java.lang.String[] getCommandLineArgs()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: java.lang.String[] getNonFrameworkArgs()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo getDefault()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: void <init>()>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: void setAllArgs(java.lang.String[])>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: void setAppArgs(java.lang.String[])>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: void setFrameworkArgs(java.lang.String[])>
<org.eclipse.core.runtime.internal.adaptor.EclipseEnvironmentInfo: void setupSystemContext()>
<org.eclipse.core.runtime.internal.adaptor.Locker_JavaNio: boolean lock()>
<org.eclipse.core.runtime.internal.adaptor.Locker_JavaNio: void <init>(java.io.File)>
<org.eclipse.core.runtime.internal.adaptor.Locker_JavaNio: void release()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: boolean isValidPackageName(java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: boolean requireRuntimeCompatibility()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: boolean upToDate(java.io.File,java.io.File,byte)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.lang.String getStringFromArray(java.lang.String[],java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.lang.String getStringFromCollection(java.util.Collection,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.lang.String getSymbolicNameEntry()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.lang.String getVersionRange(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.lang.String splitOnComma(java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.net.URL findPluginManifest(java.io.File)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.util.Dictionary convertManifest(java.io.File,boolean,java.lang.String,boolean,java.util.Dictionary)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.util.Set filterExport(java.util.Collection,java.util.Collection)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.util.Set getExports()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: java.util.Set getExportsFromJAR(java.io.File)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: long getTimeStamp(java.io.File,byte)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: org.eclipse.core.runtime.internal.adaptor.IPluginInfo parsePluginInfo(java.net.URL)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl getDefault()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void <clinit>()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void <init>(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void fillManifest(boolean,boolean)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void fillPluginInfo(java.io.File)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateActivator()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateClasspath()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateEclipseHeaders()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateHeaders()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateLocalizationEntry()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateManifestVersion()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generatePluginClass()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateProvidePackage()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateRequireBundle()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void generateTimestamp()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void init()>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void writeEntry(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginConverterImpl: void writeManifest(java.io.File,java.util.Dictionary,boolean)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: boolean hasExtensionExtensionPoints()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: boolean isFragment()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: boolean isSingleton()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String getPluginClass()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String getPluginName()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String getProviderName()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String getUniqueId()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String getVersion()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String validateForm()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.lang.String[] getLibrariesName()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.util.ArrayList access$15(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.util.ArrayList access$3(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.util.ArrayList getRequires()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.util.Map access$0(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: java.util.Map getLibraries()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void <init>(org.eclipse.core.runtime.internal.adaptor.PluginParser)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$1(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.util.Map)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$10(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$14(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$16(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.util.ArrayList)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$17(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,boolean)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$19(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$2(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.util.ArrayList)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$7(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$8(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo: void access$9(org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$Prerequisite: boolean isExported()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$Prerequisite: boolean isOptional()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$Prerequisite: java.lang.String getMatch()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$Prerequisite: java.lang.String getName()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$Prerequisite: java.lang.String getVersion()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser$Prerequisite: void <init>(org.eclipse.core.runtime.internal.adaptor.PluginParser,java.lang.String,java.lang.String,boolean,boolean,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: java.lang.String access$0(org.eclipse.core.runtime.internal.adaptor.PluginParser)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: javax.xml.parsers.SAXParserFactory acquireXMLParsing(org.osgi.framework.BundleContext)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: org.eclipse.core.runtime.internal.adaptor.PluginParser$PluginInfo parsePlugin(java.io.InputStream)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void <clinit>()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void <init>(org.osgi.framework.BundleContext,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void endDocument()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void endElement(java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void handleInitialState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void handleLibraryState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void handlePluginState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void handleRequiresState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void handleRuntimeState(java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void parseLibraryAttributes(org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void parsePluginAttributes(org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void parsePluginRequiresImport(org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void parseRequiresAttributes(org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void processingInstruction(java.lang.String,java.lang.String)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void setDocumentLocator(org.xml.sax.Locator)>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void startDocument()>
<org.eclipse.core.runtime.internal.adaptor.PluginParser: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.core.runtime.internal.adaptor.Semaphore: void <init>(int)>
<org.eclipse.core.runtime.internal.adaptor.Semaphore: void acquire()>
<org.eclipse.core.runtime.internal.adaptor.Semaphore: void release()>
<org.eclipse.core.runtime.internal.adaptor.URLConverterImpl: java.net.URL convertToFileURL(java.net.URL)>
<org.eclipse.core.runtime.internal.adaptor.URLConverterImpl: void <init>()>
<org.eclipse.core.runtime.internal.stats.StatsManager: void <clinit>()>
<org.eclipse.core.runtime.internal.stats.StatsManager: void setDebugOptions()>
<org.eclipse.core.runtime.jobs.Job: boolean cancel()>
<org.eclipse.core.runtime.jobs.Job: boolean shouldRun()>
<org.eclipse.core.runtime.jobs.Job: boolean shouldSchedule()>
<org.eclipse.core.runtime.jobs.Job: boolean sleep()>
<org.eclipse.core.runtime.jobs.Job: int getPriority()>
<org.eclipse.core.runtime.jobs.Job: int getState()>
<org.eclipse.core.runtime.jobs.Job: java.lang.Thread getThread()>
<org.eclipse.core.runtime.jobs.Job: org.eclipse.core.runtime.jobs.ISchedulingRule getRule()>
<org.eclipse.core.runtime.jobs.Job: void <clinit>()>
<org.eclipse.core.runtime.jobs.Job: void <init>(java.lang.String)>
<org.eclipse.core.runtime.jobs.Job: void schedule()>
<org.eclipse.core.runtime.jobs.Job: void schedule(long)>
<org.eclipse.core.runtime.jobs.Job: void setPriority(int)>
<org.eclipse.core.runtime.jobs.Job: void setRule(org.eclipse.core.runtime.jobs.ISchedulingRule)>
<org.eclipse.core.runtime.jobs.Job: void setSystem(boolean)>
<org.eclipse.core.runtime.jobs.Job: void setThread(java.lang.Thread)>
<org.eclipse.core.runtime.jobs.Job: void setUser(boolean)>
<org.eclipse.core.runtime.jobs.Job: void wakeUp()>
<org.eclipse.core.runtime.jobs.Job: void wakeUp(long)>
<org.eclipse.core.runtime.jobs.MultiRule: org.eclipse.core.runtime.jobs.ISchedulingRule combine(org.eclipse.core.runtime.jobs.ISchedulingRule[])>
<org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer: void <init>()>
<org.eclipse.core.runtime.preferences.DefaultScope: java.lang.String getName()>
<org.eclipse.core.runtime.preferences.DefaultScope: void <init>()>
<org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent: org.osgi.service.prefs.Preferences getChild()>
<org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent: void <init>(org.osgi.service.prefs.Preferences,org.osgi.service.prefs.Preferences)>
<org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent: java.lang.Object getNewValue()>
<org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent: java.lang.Object getOldValue()>
<org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent: java.lang.String getKey()>
<org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent: void <init>(java.lang.Object,java.lang.String,java.lang.Object,java.lang.Object)>
<org.eclipse.core.runtime.preferences.InstanceScope: java.lang.String getName()>
<org.eclipse.core.runtime.preferences.InstanceScope: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.core.runtime.preferences.InstanceScope: void <init>()>
<org.eclipse.debug.core.DebugPlugin$EventDispatchJob: void <init>(org.eclipse.debug.core.DebugPlugin)>
<org.eclipse.debug.core.DebugPlugin$EventNotifier: void <init>(org.eclipse.debug.core.DebugPlugin)>
<org.eclipse.debug.core.DebugPlugin: org.eclipse.debug.core.DebugPlugin getDefault()>
<org.eclipse.debug.core.DebugPlugin: org.eclipse.debug.core.ILaunchManager getLaunchManager()>
<org.eclipse.debug.core.DebugPlugin: void <clinit>()>
<org.eclipse.debug.core.DebugPlugin: void <init>()>
<org.eclipse.debug.core.DebugPlugin: void addDebugEventListener(org.eclipse.debug.core.IDebugEventSetListener)>
<org.eclipse.debug.core.DebugPlugin: void setDefault(org.eclipse.debug.core.DebugPlugin)>
<org.eclipse.debug.internal.core.DebugCoreMessages: void <clinit>()>
<org.eclipse.debug.internal.core.LaunchManager: void <clinit>()>
<org.eclipse.debug.internal.core.LaunchManager: void <init>()>
<org.eclipse.debug.internal.core.LaunchManager: void addLaunchListener(org.eclipse.debug.core.ILaunchesListener)>
<org.eclipse.debug.internal.core.ListenerList: void <clinit>()>
<org.eclipse.debug.internal.core.ListenerList: void <init>(int)>
<org.eclipse.debug.internal.core.ListenerList: void add(java.lang.Object)>
<org.eclipse.jdt.core.ClasspathVariableInitializer: void <init>()>
<org.eclipse.jdt.core.ElementChangedEvent: void <init>(org.eclipse.jdt.core.IJavaElementDelta,int)>
<org.eclipse.jdt.core.JavaConventions: char[] scannedIdentifier(java.lang.String)>
<org.eclipse.jdt.core.JavaConventions: org.eclipse.core.runtime.IStatus validateIdentifier(java.lang.String)>
<org.eclipse.jdt.core.JavaConventions: void <clinit>()>
<org.eclipse.jdt.core.JavaCore: java.lang.String getEncoding()>
<org.eclipse.jdt.core.JavaCore: java.lang.String getOption(java.lang.String)>
<org.eclipse.jdt.core.JavaCore: java.util.Hashtable getDefaultOptions()>
<org.eclipse.jdt.core.JavaCore: java.util.Hashtable getOptions()>
<org.eclipse.jdt.core.JavaCore: org.eclipse.core.runtime.IPath getClasspathVariable(java.lang.String)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.core.runtime.IPath getResolvedVariablePath(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.core.runtime.Plugin getPlugin()>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.ClasspathVariableInitializer getClasspathVariableInitializer(java.lang.String)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IClasspathEntry getResolvedClasspathEntry(org.eclipse.jdt.core.IClasspathEntry)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IClasspathEntry newLibraryEntry(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,org.eclipse.jdt.core.IAccessRule[],org.eclipse.jdt.core.IClasspathAttribute[],boolean)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IClasspathEntry newProjectEntry(org.eclipse.core.runtime.IPath,org.eclipse.jdt.core.IAccessRule[],boolean,org.eclipse.jdt.core.IClasspathAttribute[],boolean)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IClasspathEntry newSourceEntry(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IPath,org.eclipse.jdt.core.IClasspathAttribute[])>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IClasspathEntry newVariableEntry(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,org.eclipse.jdt.core.IAccessRule[],org.eclipse.jdt.core.IClasspathAttribute[],boolean)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IJavaElement create(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IJavaModel create(org.eclipse.core.resources.IWorkspaceRoot)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.IJavaProject create(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.core.JavaCore: org.eclipse.jdt.core.JavaCore getJavaCore()>
<org.eclipse.jdt.core.JavaCore: void <clinit>()>
<org.eclipse.jdt.core.JavaCore: void <init>()>
<org.eclipse.jdt.core.JavaCore: void run(org.eclipse.core.resources.IWorkspaceRunnable,org.eclipse.core.runtime.jobs.ISchedulingRule,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.core.JavaCore: void setClasspathVariable(java.lang.String,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.core.JavaCore: void setClasspathVariables(java.lang.String[],org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.core.JavaCore: void setOptions(java.util.Hashtable)>
<org.eclipse.jdt.core.JavaCore: void start(org.osgi.framework.BundleContext)>
<org.eclipse.jdt.core.JavaModelException: void <init>(org.eclipse.core.runtime.CoreException)>
<org.eclipse.jdt.core.JavaModelException: void <init>(org.eclipse.jdt.core.IJavaModelStatus)>
<org.eclipse.jdt.core.compiler.CharOperation: boolean equals(char[],char[])>
<org.eclipse.jdt.core.compiler.CharOperation: char[] concat(char[],char[])>
<org.eclipse.jdt.core.compiler.CharOperation: char[] concatWith(char[][],char)>
<org.eclipse.jdt.core.compiler.CharOperation: char[] lastSegment(char[],char)>
<org.eclipse.jdt.core.compiler.CharOperation: char[] replaceOnCopy(char[],char,char)>
<org.eclipse.jdt.core.compiler.CharOperation: char[] subarray(char[],int,int)>
<org.eclipse.jdt.core.compiler.CharOperation: char[][] splitAndTrimOn(char,char[])>
<org.eclipse.jdt.core.compiler.CharOperation: char[][] splitOn(char,char[])>
<org.eclipse.jdt.core.compiler.CharOperation: int hashCode(char[])>
<org.eclipse.jdt.core.compiler.CharOperation: int indexOf(char,char[])>
<org.eclipse.jdt.core.compiler.CharOperation: int indexOf(char,char[],int)>
<org.eclipse.jdt.core.compiler.CharOperation: int lastIndexOf(char,char[])>
<org.eclipse.jdt.core.compiler.CharOperation: void <clinit>()>
<org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants: java.util.Map getEclipseDefaultSettings()>
<org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants: void <clinit>()>
<org.eclipse.jdt.core.search.SearchDocument: java.lang.String getPath()>
<org.eclipse.jdt.core.search.SearchDocument: void <init>(java.lang.String,org.eclipse.jdt.core.search.SearchParticipant)>
<org.eclipse.jdt.core.search.SearchDocument: void addIndexEntry(char[],char[])>
<org.eclipse.jdt.core.search.SearchDocument: void removeAllIndexEntries()>
<org.eclipse.jdt.core.search.SearchEngine: org.eclipse.jdt.core.search.SearchParticipant getDefaultSearchParticipant()>
<org.eclipse.jdt.core.search.SearchParticipant: void <init>()>
<org.eclipse.jdt.core.tests.builder.TestingEnvironment: void <init>()>
<org.eclipse.jdt.core.tests.builder.TestingEnvironment: void close()>
<org.eclipse.jdt.core.tests.builder.TestingEnvironment: void closeWorkspace()>
<org.eclipse.jdt.core.tests.builder.TestingEnvironment: void openEmptyWorkspace()>
<org.eclipse.jdt.core.tests.builder.TestingEnvironment: void openWorkspace()>
<org.eclipse.jdt.core.tests.builder.TestingEnvironment: void setup()>
<org.eclipse.jdt.internal.compiler.ASTVisitor: void <init>()>
<org.eclipse.jdt.internal.compiler.CompilationResult: void <init>(org.eclipse.jdt.internal.compiler.env.ICompilationUnit,int,int,int)>
<org.eclipse.jdt.internal.compiler.Compiler: void <clinit>()>
<org.eclipse.jdt.internal.compiler.Compiler: void <init>(org.eclipse.jdt.internal.compiler.env.INameEnvironment,org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy,java.util.Map,org.eclipse.jdt.internal.compiler.ICompilerRequestor,org.eclipse.jdt.internal.compiler.IProblemFactory)>
<org.eclipse.jdt.internal.compiler.Compiler: void initializeParser()>
<org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies$1: void <init>()>
<org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies$4: void <init>()>
<org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies: org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy exitAfterAllProblems()>
<org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies: org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy proceedWithAllProblems()>
<org.eclipse.jdt.internal.compiler.SourceElementParser$1: void <init>(org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy,org.eclipse.jdt.internal.compiler.impl.CompilerOptions,org.eclipse.jdt.internal.compiler.IProblemFactory,org.eclipse.jdt.internal.compiler.ISourceElementRequestor)>
<org.eclipse.jdt.internal.compiler.SourceElementParser$LocalDeclarationVisitor: void <init>(org.eclipse.jdt.internal.compiler.SourceElementParser)>
<org.eclipse.jdt.internal.compiler.SourceElementParser: org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration parseCompilationUnit(org.eclipse.jdt.internal.compiler.env.ICompilationUnit,boolean)>
<org.eclipse.jdt.internal.compiler.SourceElementParser: org.eclipse.jdt.internal.compiler.ast.TypeReference getTypeReference(int)>
<org.eclipse.jdt.internal.compiler.SourceElementParser: void <init>(org.eclipse.jdt.internal.compiler.ISourceElementRequestor,org.eclipse.jdt.internal.compiler.IProblemFactory,org.eclipse.jdt.internal.compiler.impl.CompilerOptions,boolean,boolean)>
<org.eclipse.jdt.internal.compiler.SourceElementParser: void checkComment()>
<org.eclipse.jdt.internal.compiler.SourceElementParser: void consumeExitVariableWithInitialization()>
<org.eclipse.jdt.internal.compiler.ast.ASTNode: void <clinit>()>
<org.eclipse.jdt.internal.compiler.ast.ASTNode: void <init>()>
<org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration: void <init>()>
<org.eclipse.jdt.internal.compiler.ast.ArrayInitializer: void <init>()>
<org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference: void <init>(char[],int,long)>
<org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration: void <init>(org.eclipse.jdt.internal.compiler.problem.ProblemReporter,org.eclipse.jdt.internal.compiler.CompilationResult,int)>
<org.eclipse.jdt.internal.compiler.ast.Expression: void <init>()>
<org.eclipse.jdt.internal.compiler.ast.FieldDeclaration: void <init>(char[],int,int)>
<org.eclipse.jdt.internal.compiler.ast.ImportReference: void <init>(char[][],long[],boolean,int)>
<org.eclipse.jdt.internal.compiler.ast.IntLiteral: void <clinit>()>
<org.eclipse.jdt.internal.compiler.ast.IntLiteral: void <init>(char[],int,int)>
<org.eclipse.jdt.internal.compiler.ast.IntLiteral: void <init>(char[],int,int,int)>
<org.eclipse.jdt.internal.compiler.ast.Literal: void <init>(int,int)>
<org.eclipse.jdt.internal.compiler.ast.NumberLiteral: void <init>(char[],int,int)>
<org.eclipse.jdt.internal.compiler.ast.NumberLiteral: void <init>(int,int)>
<org.eclipse.jdt.internal.compiler.ast.SingleTypeReference: char[][] getTypeName()>
<org.eclipse.jdt.internal.compiler.ast.SingleTypeReference: void <init>(char[],long)>
<org.eclipse.jdt.internal.compiler.ast.Statement: void <init>()>
<org.eclipse.jdt.internal.compiler.ast.StringLiteral: void <init>(char[],int,int)>
<org.eclipse.jdt.internal.compiler.ast.StringLiteral: void <init>(int,int)>
<org.eclipse.jdt.internal.compiler.ast.TypeDeclaration: void <clinit>()>
<org.eclipse.jdt.internal.compiler.ast.TypeDeclaration: void <init>(org.eclipse.jdt.internal.compiler.CompilationResult)>
<org.eclipse.jdt.internal.compiler.ast.TypeReference: char[][] getParameterizedTypeName()>
<org.eclipse.jdt.internal.compiler.ast.TypeReference: org.eclipse.jdt.internal.compiler.ast.TypeReference baseTypeReference(int,int)>
<org.eclipse.jdt.internal.compiler.ast.TypeReference: void <init>()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: boolean isAnonymous()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: boolean isLocal()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: boolean isNestedType()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[] getConstantClassNameAt(int)>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[] getEnclosingTypeName()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[] getGenericSignature()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[] getInnerSourceName()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[] getName()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[] getSuperclassName()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: char[][] getInterfaceNames()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: int getKind()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: int getModifiers()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: int[] getConstantPoolOffsets()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: org.eclipse.jdt.internal.compiler.env.IBinaryField[] getFields()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: org.eclipse.jdt.internal.compiler.env.IBinaryMethod[] getMethods()>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: void <init>(byte[],char[])>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader: void <init>(byte[],char[],boolean)>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct: char[] utf8At(int,int)>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct: int u1At(int)>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct: int u2At(int)>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct: long u4At(int)>
<org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct: void <init>(byte[],int)>
<org.eclipse.jdt.internal.compiler.classfmt.FieldInfo: char[] getName()>
<org.eclipse.jdt.internal.compiler.classfmt.FieldInfo: char[] getTypeName()>
<org.eclipse.jdt.internal.compiler.classfmt.FieldInfo: int sizeInBytes()>
<org.eclipse.jdt.internal.compiler.classfmt.FieldInfo: void <init>(byte[],int[],int)>
<org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo: char[] getEnclosingTypeName()>
<org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo: char[] getSourceName()>
<org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo: int getModifiers()>
<org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo: void <init>(byte[],int[],int)>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: boolean isClinit()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: boolean isConstructor()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: char[] getMethodDescriptor()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: char[] getSelector()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: char[][] getExceptionTypeNames()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: int sizeInBytes()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: void <clinit>()>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: void <init>(byte[],int[],int)>
<org.eclipse.jdt.internal.compiler.classfmt.MethodInfo: void readExceptionAttributes()>
<org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants: void <clinit>()>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: int getSeverity(long)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: java.lang.String getSeverityString(long)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: java.lang.String getVisibilityString(int)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: java.lang.String versionFromJdkLevel(long)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: java.util.Map getMap()>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: long versionToJdkLevel(java.lang.Object)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: void <init>()>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: void <init>(java.util.Map)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: void set(java.util.Map)>
<org.eclipse.jdt.internal.compiler.impl.CompilerOptions: void updateSeverity(long,java.lang.Object)>
<org.eclipse.jdt.internal.compiler.impl.Constant: void <clinit>()>
<org.eclipse.jdt.internal.compiler.impl.Constant: void <init>()>
<org.eclipse.jdt.internal.compiler.impl.DoubleConstant: void <init>(double)>
<org.eclipse.jdt.internal.compiler.impl.IntConstant: void <init>(int)>
<org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding: void <init>(int,char[],char[])>
<org.eclipse.jdt.internal.compiler.lookup.BaseTypes: void <clinit>()>
<org.eclipse.jdt.internal.compiler.lookup.Binding: void <init>()>
<org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment: void <clinit>()>
<org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment: void <init>(org.eclipse.jdt.internal.compiler.impl.ITypeRequestor,org.eclipse.jdt.internal.compiler.impl.CompilerOptions,org.eclipse.jdt.internal.compiler.problem.ProblemReporter,org.eclipse.jdt.internal.compiler.env.INameEnvironment)>
<org.eclipse.jdt.internal.compiler.lookup.PackageBinding: void <init>()>
<org.eclipse.jdt.internal.compiler.lookup.PackageBinding: void <init>(char[][],org.eclipse.jdt.internal.compiler.lookup.PackageBinding,org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment)>
<org.eclipse.jdt.internal.compiler.lookup.PackageBinding: void <init>(org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment)>
<org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding: void <init>(char[],int)>
<org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding: void <init>(char[][],int)>
<org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding: void <init>(char[],org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding,int)>
<org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding: void <init>(char[][],org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding,int)>
<org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding$1: void <init>()>
<org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding: void <clinit>()>
<org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding: void <init>()>
<org.eclipse.jdt.internal.compiler.lookup.TypeBinding: void <init>()>
<org.eclipse.jdt.internal.compiler.lookup.TypeConstants: void <clinit>()>
<org.eclipse.jdt.internal.compiler.parser.AbstractCommentParser: void <clinit>()>
<org.eclipse.jdt.internal.compiler.parser.AbstractCommentParser: void <init>(org.eclipse.jdt.internal.compiler.parser.Parser)>
<org.eclipse.jdt.internal.compiler.parser.JavadocParser: void <init>(org.eclipse.jdt.internal.compiler.parser.Parser)>
<org.eclipse.jdt.internal.compiler.parser.Parser: byte[] readByteTable(java.lang.String)>
<org.eclipse.jdt.internal.compiler.parser.Parser: char[] readTable(java.lang.String)>
<org.eclipse.jdt.internal.compiler.parser.Parser: int getFirstToken()>
<org.eclipse.jdt.internal.compiler.parser.Parser: int ntAction(int,int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: int tAction(int,int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: java.lang.String[] readNameTable(java.lang.String)>
<org.eclipse.jdt.internal.compiler.parser.Parser: java.lang.String[] readReadableNameTable(java.lang.String)>
<org.eclipse.jdt.internal.compiler.parser.Parser: long[] readLongTable(java.lang.String)>
<org.eclipse.jdt.internal.compiler.parser.Parser: org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration parse(org.eclipse.jdt.internal.compiler.env.ICompilationUnit,org.eclipse.jdt.internal.compiler.CompilationResult)>
<org.eclipse.jdt.internal.compiler.parser.Parser: org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration parse(org.eclipse.jdt.internal.compiler.env.ICompilationUnit,org.eclipse.jdt.internal.compiler.CompilationResult,int,int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: org.eclipse.jdt.internal.compiler.ast.FieldDeclaration createFieldDeclaration(char[],int,int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void <clinit>()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void <init>(org.eclipse.jdt.internal.compiler.problem.ProblemReporter,boolean)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void arrayInitializer(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void checkAndSetModifiers(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void checkNonExternalizedStringLiteral()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void concatExpressionLists()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void concatNodeLists()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeArrayInitializer()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeDefaultModifiers()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeDims()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeEmptyDimsopt()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeEnterCompilationUnit()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeEnterVariable()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeExitVariableWithInitialization()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeFieldDeclaration()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeForceNoDiet()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeInterfaceHeader()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeInterfaceHeaderName1()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeInterfaceMemberDeclarations()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeInterfaceMemberDeclarationsopt()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeModifiers()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeNameArrayType()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeNestedType()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeOneDimLoop()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumePackageComment()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumePackageDeclaration()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumePackageDeclarationName()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumePrimitiveType()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumePushLeftBrace()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeQualifiedName()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeRestoreDiet()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeRule(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeToken(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void consumeVariableInitializers()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void goForCompilationUnit()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void initTables()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void initialize()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void initializeScanner()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void parse()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushIdentifier()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushIdentifier(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushOnAstStack(org.eclipse.jdt.internal.compiler.ast.ASTNode)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushOnExpressionStack(org.eclipse.jdt.internal.compiler.ast.Expression)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushOnExpressionStackLengthStack(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushOnGenericsIdentifiersLengthStack(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushOnGenericsLengthStack(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void pushOnIntStack(int)>
<org.eclipse.jdt.internal.compiler.parser.Parser: void recoveryExitFromVariable()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void resetModifiers()>
<org.eclipse.jdt.internal.compiler.parser.Parser: void updateSourceDeclarationParts(int)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: boolean getNextChar(char)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: boolean getNextCharAsDigit()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: boolean isDigit(char)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] getCurrentIdentifierSource()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] getCurrentTokenSource()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] getCurrentTokenSourceString()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] optimizedCurrentTokenSource2()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] optimizedCurrentTokenSource3()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] optimizedCurrentTokenSource4()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] optimizedCurrentTokenSource5()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: char[] optimizedCurrentTokenSource6()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: int getNextChar(char,char)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: int getNextToken()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: int scanIdentifierOrKeyword()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: int scanNumber(boolean)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void <clinit>()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void <init>()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void <init>(boolean,boolean,boolean,long,char[][],char[][],boolean)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void <init>(boolean,boolean,boolean,long,long,char[][],char[][],boolean)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void checkNonExternalizedString()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void pushLineSeparator()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void recordComment(int)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void scanEscapeCharacter()>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void setSource(char[])>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void unicodeInitializeBuffer(int)>
<org.eclipse.jdt.internal.compiler.parser.Scanner: void unicodeStore()>
<org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory: int keyFromID(int)>
<org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory: org.eclipse.jdt.internal.compiler.util.HashtableOfInt loadMessageTemplates(java.util.Locale)>
<org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory: void <clinit>()>
<org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory: void <init>(java.util.Locale)>
<org.eclipse.jdt.internal.compiler.problem.ProblemHandler: void <clinit>()>
<org.eclipse.jdt.internal.compiler.problem.ProblemHandler: void <init>(org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy,org.eclipse.jdt.internal.compiler.impl.CompilerOptions,org.eclipse.jdt.internal.compiler.IProblemFactory)>
<org.eclipse.jdt.internal.compiler.problem.ProblemReporter: void <init>(org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy,org.eclipse.jdt.internal.compiler.impl.CompilerOptions,org.eclipse.jdt.internal.compiler.IProblemFactory)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfInt: java.lang.Object put(int,java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfInt: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfIntValues: int put(char[],int)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfIntValues: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObject: java.lang.Object get(char[])>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObject: java.lang.Object put(char[],java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObject: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObject: void rehash()>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt: int put(java.lang.Object,int)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt: void <init>()>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt: void rehash()>
<org.eclipse.jdt.internal.compiler.util.HashtableOfPackage: void <init>()>
<org.eclipse.jdt.internal.compiler.util.HashtableOfPackage: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.ObjectVector: int size()>
<org.eclipse.jdt.internal.compiler.util.ObjectVector: void <clinit>()>
<org.eclipse.jdt.internal.compiler.util.ObjectVector: void <init>()>
<org.eclipse.jdt.internal.compiler.util.ObjectVector: void add(java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.ObjectVector: void copyInto(java.lang.Object[])>
<org.eclipse.jdt.internal.compiler.util.ObjectVector: void copyInto(java.lang.Object[],int)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: boolean containsKey(java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: java.lang.Object get(java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: java.lang.Object keyForValue(java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: java.lang.Object put(java.lang.Object,java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: java.lang.Object removeKey(java.lang.Object)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: void <init>()>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.SimpleLookupTable: void rehash()>
<org.eclipse.jdt.internal.compiler.util.SuffixConstants: void <clinit>()>
<org.eclipse.jdt.internal.compiler.util.Util: boolean isArchiveFileName(java.lang.String)>
<org.eclipse.jdt.internal.compiler.util.Util: boolean isClassFileName(java.lang.String)>
<org.eclipse.jdt.internal.compiler.util.Util: byte[] getInputStreamAsByteArray(java.io.InputStream,int)>
<org.eclipse.jdt.internal.compiler.util.Util: byte[] getZipEntryByteContent(java.util.zip.ZipEntry,java.util.zip.ZipFile)>
<org.eclipse.jdt.internal.compiler.util.Util: char[] getFileCharContent(java.io.File,java.lang.String)>
<org.eclipse.jdt.internal.compiler.util.Util: char[] getInputStreamAsCharArray(java.io.InputStream,int,java.lang.String)>
<org.eclipse.jdt.internal.compiler.util.Util: void <clinit>()>
<org.eclipse.jdt.internal.compiler.util.WeakHashSet: void <init>(int)>
<org.eclipse.jdt.internal.compiler.util.WeakHashSetOfCharArray: void <init>(int)>
<org.eclipse.jdt.internal.core.BatchOperation: boolean canModifyRoots()>
<org.eclipse.jdt.internal.core.BatchOperation: void <init>(org.eclipse.core.resources.IWorkspaceRunnable)>
<org.eclipse.jdt.internal.core.BatchOperation: void executeOperation()>
<org.eclipse.jdt.internal.core.ClasspathEntry: boolean isExported()>
<org.eclipse.jdt.internal.core.ClasspathEntry: char[][] fullExclusionPatternChars()>
<org.eclipse.jdt.internal.core.ClasspathEntry: char[][] fullInclusionPatternChars()>
<org.eclipse.jdt.internal.core.ClasspathEntry: int getContentKind()>
<org.eclipse.jdt.internal.core.ClasspathEntry: int getEntryKind()>
<org.eclipse.jdt.internal.core.ClasspathEntry: int kindFromString(java.lang.String)>
<org.eclipse.jdt.internal.core.ClasspathEntry: java.lang.String removeAttribute(java.lang.String,org.w3c.dom.NamedNodeMap)>
<org.eclipse.jdt.internal.core.ClasspathEntry: java.lang.String rootID()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath getOutputLocation()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath getPath()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath getSourceAttachmentPath()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath getSourceAttachmentRootPath()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath[] decodePatterns(org.w3c.dom.NamedNodeMap,java.lang.String)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath[] getExclusionPatterns()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.core.runtime.IPath[] getInclusionPatterns()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IAccessRule[] decodeAccessRules(org.w3c.dom.NodeList)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IAccessRule[] getAccessRules()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IAccessRule[] getAccessRules(org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IPath[])>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IClasspathAttribute[] decodeExtraAttributes(org.w3c.dom.NodeList)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IClasspathAttribute[] getExtraAttributes()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IClasspathEntry elementDecode(org.w3c.dom.Element,org.eclipse.jdt.core.IJavaProject,java.util.Map)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IJavaModelStatus validateClasspath(org.eclipse.jdt.core.IJavaProject,org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.core.IJavaModelStatus validateClasspathEntry(org.eclipse.jdt.core.IJavaProject,org.eclipse.jdt.core.IClasspathEntry,boolean,boolean)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.internal.compiler.env.AccessRuleSet createAccessRuleSet(org.eclipse.jdt.core.IAccessRule[])>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.internal.compiler.env.AccessRuleSet getAccessRuleSet()>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.eclipse.jdt.internal.core.ClasspathEntry combineWith(org.eclipse.jdt.internal.core.ClasspathEntry)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.w3c.dom.Node removeNode(java.lang.String,org.w3c.dom.NamedNodeMap)>
<org.eclipse.jdt.internal.core.ClasspathEntry: org.w3c.dom.NodeList getChildAttributes(java.lang.String,org.w3c.dom.NodeList,boolean[])>
<org.eclipse.jdt.internal.core.ClasspathEntry: void <clinit>()>
<org.eclipse.jdt.internal.core.ClasspathEntry: void <init>(int,int,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,boolean,org.eclipse.jdt.core.IAccessRule[],boolean,org.eclipse.jdt.core.IClasspathAttribute[])>
<org.eclipse.jdt.internal.core.DeltaProcessingState$ProjectUpdateInfo: void <init>()>
<org.eclipse.jdt.internal.core.DeltaProcessingState$ProjectUpdateInfo: void updateProjectReferencesIfNecessary()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: java.io.File getTimeStampsFile()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: java.util.Hashtable getExternalLibTimeStamps()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: org.eclipse.jdt.internal.core.DeltaProcessingState$ProjectUpdateInfo[] removeAllProjectUpdates()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: org.eclipse.jdt.internal.core.DeltaProcessor getDeltaProcessor()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void <init>()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void initializeRoots()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void performClasspathResourceChange(org.eclipse.jdt.internal.core.JavaProject,org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.jdt.core.IClasspathEntry[],boolean)>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void recordProjectUpdate(org.eclipse.jdt.internal.core.DeltaProcessingState$ProjectUpdateInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void resourceChanged(org.eclipse.core.resources.IResourceChangeEvent)>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void saveExternalLibTimeStamps()>
<org.eclipse.jdt.internal.core.DeltaProcessingState: void updateRoots(org.eclipse.core.runtime.IPath,org.eclipse.core.resources.IResourceDelta,org.eclipse.jdt.internal.core.DeltaProcessor)>
<org.eclipse.jdt.internal.core.DeltaProcessor$1$FoundRelevantDeltaException: void <init>(org.eclipse.jdt.internal.core.DeltaProcessor)>
<org.eclipse.jdt.internal.core.DeltaProcessor$2: boolean visit(org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor$2: void <init>(org.eclipse.jdt.internal.core.DeltaProcessor)>
<org.eclipse.jdt.internal.core.DeltaProcessor$OutputsInfo: void <init>(org.eclipse.core.runtime.IPath[],int[],int)>
<org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo: boolean isRootOfProject(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo: org.eclipse.jdt.core.IPackageFragmentRoot getPackageFragmentRoot(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo: void <init>(org.eclipse.jdt.internal.core.JavaProject,org.eclipse.core.runtime.IPath,char[][],char[][],int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: boolean createExternalArchiveDelta(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.DeltaProcessor: boolean isAffectedBy(org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor: boolean isPrimaryWorkingCopy(org.eclipse.jdt.core.IJavaElement,int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: boolean updateCurrentDeltaAndIndex(org.eclipse.core.resources.IResourceDelta,int,org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessor: int elementType(org.eclipse.core.resources.IResource,int,int,org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessor: long getTimeStamp(java.io.File)>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.core.IJavaElementDelta mergeDeltas(java.util.Collection)>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.core.IJavaElementDelta processResourceDelta(org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.internal.core.DeltaProcessor$OutputsInfo outputsInfo(org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo,org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo enclosingRootInfo(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo rootInfo(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.internal.core.JavaElementDelta currentDelta()>
<org.eclipse.jdt.internal.core.DeltaProcessor: org.eclipse.jdt.internal.core.Openable createElement(org.eclipse.core.resources.IResource,int,org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void <clinit>()>
<org.eclipse.jdt.internal.core.DeltaProcessor: void <init>(org.eclipse.jdt.internal.core.DeltaProcessingState,org.eclipse.jdt.internal.core.JavaModelManager)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void addDependentProjects(org.eclipse.jdt.core.IJavaProject,java.util.HashMap,java.util.HashSet)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void addForRefresh(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void addToParentInfo(org.eclipse.jdt.internal.core.Openable)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void addToRootsToRefreshWithDependents(org.eclipse.jdt.core.IJavaProject)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void checkProjectsBeingAddedOrRemoved(org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void checkSourceAttachmentChange(org.eclipse.core.resources.IResourceDelta,org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void close(org.eclipse.jdt.internal.core.Openable)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void deleting(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void elementAdded(org.eclipse.jdt.internal.core.Openable,org.eclipse.core.resources.IResourceDelta,org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void elementRemoved(org.eclipse.jdt.internal.core.Openable,org.eclipse.core.resources.IResourceDelta,org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void fire(org.eclipse.jdt.core.IJavaElementDelta,int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void firePostChangeDelta(org.eclipse.jdt.core.IJavaElementDelta,org.eclipse.jdt.core.IElementChangedListener[],int[],int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void fireReconcileDelta(org.eclipse.jdt.core.IElementChangedListener[],int[],int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void flush()>
<org.eclipse.jdt.internal.core.DeltaProcessor: void notifyListeners(org.eclipse.jdt.core.IJavaElementDelta,int,org.eclipse.jdt.core.IElementChangedListener[],int[],int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void notifyTypeHierarchies(org.eclipse.jdt.core.IElementChangedListener[],int)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void popUntilPrefixOf(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void refreshPackageFragmentRoots()>
<org.eclipse.jdt.internal.core.DeltaProcessor: void registerJavaModelDelta(org.eclipse.jdt.core.IJavaElementDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void removeFromParentInfo(org.eclipse.jdt.internal.core.Openable)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void resetProjectCaches()>
<org.eclipse.jdt.internal.core.DeltaProcessor: void resourceChanged(org.eclipse.core.resources.IResourceChangeEvent)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void startDeltas()>
<org.eclipse.jdt.internal.core.DeltaProcessor: void stopDeltas()>
<org.eclipse.jdt.internal.core.DeltaProcessor: void traverseDelta(org.eclipse.core.resources.IResourceDelta,int,org.eclipse.jdt.internal.core.DeltaProcessor$RootInfo,org.eclipse.jdt.internal.core.DeltaProcessor$OutputsInfo)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void updateClasspathMarkers(org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void updateClasspathMarkers(org.eclipse.core.resources.IResourceDelta,java.util.HashSet,java.util.Map,java.util.Map)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void updateIndex(org.eclipse.jdt.internal.core.Openable,org.eclipse.core.resources.IResourceDelta)>
<org.eclipse.jdt.internal.core.DeltaProcessor: void updateJavaModel(org.eclipse.jdt.core.IJavaElementDelta)>
<org.eclipse.jdt.internal.core.ElementCache: void <init>(int)>
<org.eclipse.jdt.internal.core.ElementCache: void ensureSpaceLimit(int,org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.ElementCache: void resetSpaceLimit(int,org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: boolean isExternal()>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: int hashCode()>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: org.eclipse.core.runtime.IPath getPath()>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: void <clinit>()>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: void <init>(org.eclipse.core.resources.IResource,org.eclipse.jdt.internal.core.JavaProject)>
<org.eclipse.jdt.internal.core.JarPackageFragmentRoot: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.jdt.internal.core.JavaProject)>
<org.eclipse.jdt.internal.core.JavaCorePreferenceInitializer: void <init>()>
<org.eclipse.jdt.internal.core.JavaCorePreferenceInitializer: void initializeDefaultPreferences()>
<org.eclipse.jdt.internal.core.JavaElement: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaElement: int hashCode()>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.Object getElementInfo()>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.Object getElementInfo(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.Object openWhenClosed(java.lang.Object,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.Object toStringInfo(int,java.lang.StringBuffer)>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.String tabString(int)>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.String toString()>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.String toStringWithAncestors()>
<org.eclipse.jdt.internal.core.JavaElement: java.lang.String toStringWithAncestors(boolean)>
<org.eclipse.jdt.internal.core.JavaElement: java.util.ArrayList getChildrenOfType(int)>
<org.eclipse.jdt.internal.core.JavaElement: org.eclipse.jdt.core.IJavaElement getParent()>
<org.eclipse.jdt.internal.core.JavaElement: org.eclipse.jdt.core.IJavaElement[] getChildren()>
<org.eclipse.jdt.internal.core.JavaElement: org.eclipse.jdt.core.IJavaModel getJavaModel()>
<org.eclipse.jdt.internal.core.JavaElement: org.eclipse.jdt.core.IJavaProject getJavaProject()>
<org.eclipse.jdt.internal.core.JavaElement: org.eclipse.jdt.core.IOpenable getOpenableParent()>
<org.eclipse.jdt.internal.core.JavaElement: org.eclipse.jdt.core.JavaModelException newNotPresentException()>
<org.eclipse.jdt.internal.core.JavaElement: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaElement: void <init>(org.eclipse.jdt.internal.core.JavaElement)>
<org.eclipse.jdt.internal.core.JavaElement: void close()>
<org.eclipse.jdt.internal.core.JavaElement: void toString(int,java.lang.StringBuffer)>
<org.eclipse.jdt.internal.core.JavaElement: void toStringAncestors(java.lang.StringBuffer)>
<org.eclipse.jdt.internal.core.JavaElement: void toStringChildren(int,java.lang.StringBuffer,java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaElement: void toStringInfo(int,java.lang.StringBuffer,java.lang.Object,boolean)>
<org.eclipse.jdt.internal.core.JavaElement: void toStringName(java.lang.StringBuffer)>
<org.eclipse.jdt.internal.core.JavaElementDelta: boolean equalsAndSameParent(org.eclipse.jdt.core.IJavaElement,org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementDelta: java.util.ArrayList getAncestors(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.core.resources.IResourceDelta[] getResourceDeltas()>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.jdt.core.IJavaElement getElement()>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.jdt.core.IJavaElementDelta[] getAffectedChildren()>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.jdt.core.IJavaElementDelta[] growAndAddToArray(org.eclipse.jdt.core.IJavaElementDelta[],org.eclipse.jdt.core.IJavaElementDelta)>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.jdt.internal.core.JavaElementDelta changed(org.eclipse.jdt.core.IJavaElement,int)>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.jdt.internal.core.JavaElementDelta createDeltaTree(org.eclipse.jdt.core.IJavaElement,org.eclipse.jdt.internal.core.JavaElementDelta)>
<org.eclipse.jdt.internal.core.JavaElementDelta: org.eclipse.jdt.internal.core.JavaElementDelta getDeltaFor(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaElementDelta: void <init>(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void addAffectedChild(org.eclipse.jdt.internal.core.JavaElementDelta)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void added(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void added(org.eclipse.jdt.core.IJavaElement,int)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void insertDeltaTree(org.eclipse.jdt.core.IJavaElement,org.eclipse.jdt.internal.core.JavaElementDelta)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void removed(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementDelta: void removed(org.eclipse.jdt.core.IJavaElement,int)>
<org.eclipse.jdt.internal.core.JavaElementInfo: boolean includesChild(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementInfo: org.eclipse.jdt.core.IJavaElement[] getChildren()>
<org.eclipse.jdt.internal.core.JavaElementInfo: org.eclipse.jdt.core.IJavaElement[] growAndAddToArray(org.eclipse.jdt.core.IJavaElement[],org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementInfo: org.eclipse.jdt.core.IJavaElement[] removeAndShrinkArray(org.eclipse.jdt.core.IJavaElement[],org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementInfo: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaElementInfo: void <init>()>
<org.eclipse.jdt.internal.core.JavaElementInfo: void addChild(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementInfo: void removeChild(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaElementInfo: void setChildren(org.eclipse.jdt.core.IJavaElement[])>
<org.eclipse.jdt.internal.core.JavaModel: boolean buildStructure(org.eclipse.jdt.internal.core.OpenableElementInfo,org.eclipse.core.runtime.IProgressMonitor,java.util.Map,org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.JavaModel: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaModel: boolean isFile(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaModel: int getElementType()>
<org.eclipse.jdt.internal.core.JavaModel: java.io.File getFile(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaModel: java.lang.Object createElementInfo()>
<org.eclipse.jdt.internal.core.JavaModel: java.lang.Object getTarget(org.eclipse.core.resources.IContainer,org.eclipse.core.runtime.IPath,boolean)>
<org.eclipse.jdt.internal.core.JavaModel: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.jdt.internal.core.JavaModel: org.eclipse.jdt.core.IJavaProject findJavaProject(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.JavaModel: org.eclipse.jdt.core.IJavaProject getJavaProject(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModel: org.eclipse.jdt.core.IJavaProject getJavaProject(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.JavaModel: org.eclipse.jdt.core.IJavaProject[] getJavaProjects()>
<org.eclipse.jdt.internal.core.JavaModel: org.eclipse.jdt.core.IJavaProject[] getOldJavaProjectsList()>
<org.eclipse.jdt.internal.core.JavaModel: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaModel: void <init>()>
<org.eclipse.jdt.internal.core.JavaModel: void flushExternalFileCache()>
<org.eclipse.jdt.internal.core.JavaModelCache: java.lang.Object getInfo(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaModelCache: java.lang.Object peekAtInfo(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaModelCache: void <init>()>
<org.eclipse.jdt.internal.core.JavaModelCache: void putInfo(org.eclipse.jdt.core.IJavaElement,java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaModelCache: void removeInfo(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaModelInfo: void <init>()>
<org.eclipse.jdt.internal.core.JavaModelManager$10: void <init>(org.eclipse.jdt.internal.core.JavaModelManager$9,org.eclipse.core.resources.IWorkspace)>
<org.eclipse.jdt.internal.core.JavaModelManager$10: void run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaModelManager$11: void <init>(org.eclipse.jdt.internal.core.JavaModelManager,java.util.HashMap,java.lang.String[],boolean)>
<org.eclipse.jdt.internal.core.JavaModelManager$11: void run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaModelManager$1: void <init>()>
<org.eclipse.jdt.internal.core.JavaModelManager$5: void <init>(org.eclipse.jdt.internal.core.JavaModelManager)>
<org.eclipse.jdt.internal.core.JavaModelManager$5: void added(org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent)>
<org.eclipse.jdt.internal.core.JavaModelManager$6: void <init>(org.eclipse.jdt.internal.core.JavaModelManager)>
<org.eclipse.jdt.internal.core.JavaModelManager$6: void added(org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent)>
<org.eclipse.jdt.internal.core.JavaModelManager$8: void <init>(org.eclipse.jdt.internal.core.JavaModelManager)>
<org.eclipse.jdt.internal.core.JavaModelManager$8: void propertyChange(org.eclipse.core.runtime.Preferences$PropertyChangeEvent)>
<org.eclipse.jdt.internal.core.JavaModelManager$9: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaModelManager$9: org.eclipse.jdt.internal.core.JavaModelManager access$0(org.eclipse.jdt.internal.core.JavaModelManager$9)>
<org.eclipse.jdt.internal.core.JavaModelManager$9: void <init>(org.eclipse.jdt.internal.core.JavaModelManager,java.lang.String,org.eclipse.core.resources.IWorkspace)>
<org.eclipse.jdt.internal.core.JavaModelManager$EclipsePreferencesListener: void <init>()>
<org.eclipse.jdt.internal.core.JavaModelManager$EclipsePreferencesListener: void preferenceChange(org.eclipse.core.runtime.preferences.IEclipsePreferences$PreferenceChangeEvent)>
<org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo: void <init>(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo: void rememberExternalLibTimestamps()>
<org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo: void updateClasspathInformation(org.eclipse.jdt.core.IClasspathEntry[])>
<org.eclipse.jdt.internal.core.JavaModelManager: boolean hasTemporaryCache()>
<org.eclipse.jdt.internal.core.JavaModelManager: boolean isDeprecatedOption(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModelManager: boolean variablePutIfInitializingWithSameValue(java.lang.String[],org.eclipse.core.runtime.IPath[])>
<org.eclipse.jdt.internal.core.JavaModelManager: java.io.File getSerializationFile(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.JavaModelManager: java.io.File getVariableAndContainersFile()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.lang.Object getInfo(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaModelManager: java.lang.Object peekAtInfo(org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaModelManager: java.lang.Object removeInfoAndChildren(org.eclipse.jdt.internal.core.JavaElement)>
<org.eclipse.jdt.internal.core.JavaModelManager: java.lang.String getOption(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModelManager: java.lang.String[] getRegisteredContainerIDs()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.lang.String[] getRegisteredVariableNames()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.HashMap getTemporaryCache()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.HashSet getClasspathBeingResolved()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.HashSet variableInitializationInProgress()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.Hashtable getDefaultOptions()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.Hashtable getOptions()>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.Map containerClone(org.eclipse.jdt.core.IJavaProject)>
<org.eclipse.jdt.internal.core.JavaModelManager: java.util.Map getElementsOutOfSynchWithBuffers()>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.core.runtime.IPath getPreviousSessionVariable(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.core.runtime.IPath variableGet(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.core.runtime.preferences.IEclipsePreferences getDefaultPreferences()>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.core.runtime.preferences.IEclipsePreferences getInstancePreferences()>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.core.IJavaElement create(org.eclipse.core.resources.IResource,org.eclipse.jdt.core.IJavaProject)>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.internal.core.DeltaProcessor getDeltaProcessor()>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.internal.core.JavaModel getJavaModel()>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.internal.core.JavaModelManager getJavaModelManager()>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo getPerProjectInfo(org.eclipse.core.resources.IProject,boolean)>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo getPerProjectInfoCheckExistence(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.JavaModelManager: org.eclipse.jdt.internal.core.search.indexing.IndexManager getIndexManager()>
<org.eclipse.jdt.internal.core.JavaModelManager: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaModelManager: void <init>()>
<org.eclipse.jdt.internal.core.JavaModelManager: void addDeprecatedOptions(java.util.Hashtable)>
<org.eclipse.jdt.internal.core.JavaModelManager: void configurePluginDebugOptions()>
<org.eclipse.jdt.internal.core.JavaModelManager: void containersReset(java.lang.String[])>
<org.eclipse.jdt.internal.core.JavaModelManager: void doneSaving(org.eclipse.core.resources.ISaveContext)>
<org.eclipse.jdt.internal.core.JavaModelManager: void initializePreferences()>
<org.eclipse.jdt.internal.core.JavaModelManager: void loadVariablesAndContainers()>
<org.eclipse.jdt.internal.core.JavaModelManager: void prepareToSave(org.eclipse.core.resources.ISaveContext)>
<org.eclipse.jdt.internal.core.JavaModelManager: void putInfos(org.eclipse.jdt.core.IJavaElement,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaModelManager: void removePerProjectInfo(org.eclipse.jdt.internal.core.JavaProject)>
<org.eclipse.jdt.internal.core.JavaModelManager: void resetProjectPreferences(org.eclipse.jdt.internal.core.JavaProject)>
<org.eclipse.jdt.internal.core.JavaModelManager: void resetTemporaryCache()>
<org.eclipse.jdt.internal.core.JavaModelManager: void saveState(org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo,org.eclipse.core.resources.ISaveContext)>
<org.eclipse.jdt.internal.core.JavaModelManager: void saveVariablesAndContainers()>
<org.eclipse.jdt.internal.core.JavaModelManager: void saving(org.eclipse.core.resources.ISaveContext)>
<org.eclipse.jdt.internal.core.JavaModelManager: void setClasspathBeingResolved(org.eclipse.jdt.core.IJavaProject,boolean)>
<org.eclipse.jdt.internal.core.JavaModelManager: void setLastBuiltState(org.eclipse.core.resources.IProject,java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaModelManager: void setOptions(java.util.Hashtable)>
<org.eclipse.jdt.internal.core.JavaModelManager: void startIndexing()>
<org.eclipse.jdt.internal.core.JavaModelManager: void startup()>
<org.eclipse.jdt.internal.core.JavaModelManager: void updateVariableValues(java.lang.String[],org.eclipse.core.runtime.IPath[],org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaModelManager: void variablePut(java.lang.String,org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.JavaModelOperation: boolean hasModifiedResource()>
<org.eclipse.jdt.internal.core.JavaModelOperation: boolean isReadOnly()>
<org.eclipse.jdt.internal.core.JavaModelOperation: boolean isTopLevelOperation()>
<org.eclipse.jdt.internal.core.JavaModelOperation: int firstActionWithID(java.lang.String,int)>
<org.eclipse.jdt.internal.core.JavaModelOperation: java.lang.Object getAttribute(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaModelOperation: java.util.ArrayList getCurrentOperationStack()>
<org.eclipse.jdt.internal.core.JavaModelOperation: org.eclipse.jdt.core.IJavaModel getJavaModel()>
<org.eclipse.jdt.internal.core.JavaModelOperation: org.eclipse.jdt.core.IJavaModelStatus commonVerify()>
<org.eclipse.jdt.internal.core.JavaModelOperation: org.eclipse.jdt.core.IJavaModelStatus verify()>
<org.eclipse.jdt.internal.core.JavaModelOperation: org.eclipse.jdt.internal.core.JavaModelOperation popOperation()>
<org.eclipse.jdt.internal.core.JavaModelOperation: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaModelOperation: void <init>()>
<org.eclipse.jdt.internal.core.JavaModelOperation: void <init>(org.eclipse.jdt.core.IJavaElement[])>
<org.eclipse.jdt.internal.core.JavaModelOperation: void addAction(org.eclipse.jdt.internal.core.JavaModelOperation$IPostAction)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void addDelta(org.eclipse.jdt.core.IJavaElementDelta)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void beginTask(java.lang.String,int)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void done()>
<org.eclipse.jdt.internal.core.JavaModelOperation: void postAction(org.eclipse.jdt.internal.core.JavaModelOperation$IPostAction,int)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void pushOperation(org.eclipse.jdt.internal.core.JavaModelOperation)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void runOperation(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.JavaModelOperation: void runPostActions()>
<org.eclipse.jdt.internal.core.JavaModelStatus: boolean isOK()>
<org.eclipse.jdt.internal.core.JavaModelStatus: java.lang.String getMessage()>
<org.eclipse.jdt.internal.core.JavaModelStatus: org.eclipse.core.runtime.IPath getPath()>
<org.eclipse.jdt.internal.core.JavaModelStatus: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaModelStatus: void <init>(int,int,java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModelStatus: void <init>(int,java.lang.String)>
<org.eclipse.jdt.internal.core.JavaModelStatus: void <init>(int,org.eclipse.jdt.core.IJavaElement)>
<org.eclipse.jdt.internal.core.JavaModelStatus: void <init>(int,org.eclipse.jdt.core.IJavaElement[])>
<org.eclipse.jdt.internal.core.JavaProject$1: void <init>(org.eclipse.jdt.internal.core.JavaProject,org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.jdt.internal.core.JavaProject$1: void removed(org.eclipse.core.runtime.preferences.IEclipsePreferences$NodeChangeEvent)>
<org.eclipse.jdt.internal.core.JavaProject$2: void <init>(org.eclipse.jdt.internal.core.JavaProject)>
<org.eclipse.jdt.internal.core.JavaProject: boolean buildStructure(org.eclipse.jdt.internal.core.OpenableElementInfo,org.eclipse.core.runtime.IProgressMonitor,java.util.Map,org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.JavaProject: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaProject: boolean hasCycleMarker()>
<org.eclipse.jdt.internal.core.JavaProject: boolean hasJavaNature(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.JavaProject: int getElementType()>
<org.eclipse.jdt.internal.core.JavaProject: int hashCode()>
<org.eclipse.jdt.internal.core.JavaProject: java.lang.Object createElementInfo()>
<org.eclipse.jdt.internal.core.JavaProject: java.lang.String getElementName()>
<org.eclipse.jdt.internal.core.JavaProject: java.lang.String getOption(java.lang.String,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: java.lang.String getSharedProperty(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaProject: java.lang.String rootID()>
<org.eclipse.jdt.internal.core.JavaProject: java.lang.String[] projectPrerequisites(org.eclipse.jdt.core.IClasspathEntry[])>
<org.eclipse.jdt.internal.core.JavaProject: java.util.Map getOptions(boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.resources.IMarker getCycleMarker()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.resources.IProject getProject()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.IPath canonicalizedPath(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.IPath getOutputLocation()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.IPath getOutputLocation(boolean,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.IPath getPath()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.IPath getPluginWorkingLocation()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.Preferences loadPreferences()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.core.runtime.preferences.IEclipsePreferences getEclipsePreferences()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] decodeClasspath(java.lang.String,boolean,boolean,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getExpandedClasspath(boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getExpandedClasspath(boolean,boolean,java.util.Map,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getRawClasspath()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getRawClasspath(boolean,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getResolvedClasspath(boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getResolvedClasspath(boolean,boolean,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] getResolvedClasspath(org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.core.runtime.IPath,boolean,boolean,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] readClasspathFile(boolean,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IClasspathEntry[] readClasspathFile(boolean,boolean,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IPackageFragmentRoot getPackageFragmentRoot(java.lang.String)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IPackageFragmentRoot getPackageFragmentRoot(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IPackageFragmentRoot getPackageFragmentRoot0(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IPackageFragmentRoot[] computePackageFragmentRoots(org.eclipse.jdt.core.IClasspathEntry)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IPackageFragmentRoot[] computePackageFragmentRoots(org.eclipse.jdt.core.IClasspathEntry[],boolean,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.core.IPackageFragmentRoot[] getPackageFragmentRoots()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.internal.core.JavaModelManager$PerProjectInfo getPerProjectInfo()>
<org.eclipse.jdt.internal.core.JavaProject: org.eclipse.jdt.internal.core.JavaProjectElementInfo getJavaProjectElementInfo()>
<org.eclipse.jdt.internal.core.JavaProject: void <clinit>()>
<org.eclipse.jdt.internal.core.JavaProject: void <init>(org.eclipse.core.resources.IProject,org.eclipse.jdt.internal.core.JavaElement)>
<org.eclipse.jdt.internal.core.JavaProject: void closing(java.lang.Object)>
<org.eclipse.jdt.internal.core.JavaProject: void computeChildren(org.eclipse.jdt.internal.core.JavaProjectElementInfo)>
<org.eclipse.jdt.internal.core.JavaProject: void computeExpandedClasspath(org.eclipse.jdt.internal.core.ClasspathEntry,boolean,boolean,java.util.HashSet,org.eclipse.jdt.internal.compiler.util.ObjectVector,java.util.Map,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: void computePackageFragmentRoots(org.eclipse.jdt.core.IClasspathEntry,org.eclipse.jdt.internal.compiler.util.ObjectVector,java.util.HashSet,org.eclipse.jdt.core.IClasspathEntry,boolean,boolean,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: void computePackageFragmentRoots(org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.jdt.internal.compiler.util.ObjectVector,java.util.HashSet,org.eclipse.jdt.core.IClasspathEntry,boolean,boolean,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: void createClasspathProblemMarker(org.eclipse.jdt.core.IJavaModelStatus)>
<org.eclipse.jdt.internal.core.JavaProject: void flushClasspathProblemMarkers(boolean,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: void resetCaches()>
<org.eclipse.jdt.internal.core.JavaProject: void setRawClasspath(org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IProgressMonitor,boolean,org.eclipse.jdt.core.IClasspathEntry[],boolean,boolean)>
<org.eclipse.jdt.internal.core.JavaProject: void updateAllCycleMarkers(java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: void updateClasspathMarkers(java.util.Map,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: void updateCycleParticipants(java.util.ArrayList,java.util.HashSet,org.eclipse.core.resources.IWorkspaceRoot,java.util.HashSet,java.util.Map)>
<org.eclipse.jdt.internal.core.JavaProject: void updatePackageFragmentRoots()>
<org.eclipse.jdt.internal.core.JavaProject: void updatePreferences(org.eclipse.core.runtime.preferences.IEclipsePreferences)>
<org.eclipse.jdt.internal.core.JavaProjectElementInfo: void <init>()>
<org.eclipse.jdt.internal.core.JavaProjectElementInfo: void resetCaches()>
<org.eclipse.jdt.internal.core.JavaProjectElementInfo: void setNonJavaResources(java.lang.Object[])>
<org.eclipse.jdt.internal.core.ModelUpdater: void <init>()>
<org.eclipse.jdt.internal.core.ModelUpdater: void processJavaDelta(org.eclipse.jdt.core.IJavaElementDelta)>
<org.eclipse.jdt.internal.core.ModelUpdater: void traverseDelta(org.eclipse.jdt.core.IJavaElementDelta,org.eclipse.jdt.core.IPackageFragmentRoot,org.eclipse.jdt.core.IJavaProject)>
<org.eclipse.jdt.internal.core.Openable: boolean hasBuffer()>
<org.eclipse.jdt.internal.core.Openable: boolean isOpen()>
<org.eclipse.jdt.internal.core.Openable: boolean resourceExists()>
<org.eclipse.jdt.internal.core.Openable: void <init>(org.eclipse.jdt.internal.core.JavaElement)>
<org.eclipse.jdt.internal.core.Openable: void closeBuffer()>
<org.eclipse.jdt.internal.core.Openable: void closing(java.lang.Object)>
<org.eclipse.jdt.internal.core.Openable: void generateInfos(java.lang.Object,java.util.HashMap,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.Openable: void openParent(java.lang.Object,java.util.HashMap,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.OpenableElementInfo: void <init>()>
<org.eclipse.jdt.internal.core.OpenableElementInfo: void setIsStructureKnown(boolean)>
<org.eclipse.jdt.internal.core.OverflowingLRUCache: java.lang.Object peek(java.lang.Object)>
<org.eclipse.jdt.internal.core.OverflowingLRUCache: void <init>(int)>
<org.eclipse.jdt.internal.core.OverflowingLRUCache: void <init>(int,int)>
<org.eclipse.jdt.internal.core.PackageFragment: void <clinit>()>
<org.eclipse.jdt.internal.core.PackageFragment: void <init>(org.eclipse.jdt.internal.core.PackageFragmentRoot,java.lang.String[])>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: boolean buildStructure(org.eclipse.jdt.internal.core.OpenableElementInfo,org.eclipse.core.runtime.IProgressMonitor,java.util.Map,org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: boolean computeChildren(org.eclipse.jdt.internal.core.OpenableElementInfo,java.util.Map)>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: char[][] fullExclusionPatternChars()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: char[][] fullInclusionPatternChars()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: int determineKind(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: int getElementType()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: int getKind()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: int hashCode()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: java.lang.Object createElementInfo()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: org.eclipse.core.resources.IResource getResource()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: org.eclipse.core.runtime.IPath getPath()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: org.eclipse.core.runtime.IStatus validateOnClasspath()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: org.eclipse.core.runtime.QualifiedName getSourceAttachmentPropertyName()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: org.eclipse.jdt.core.IClasspathEntry getRawClasspathEntry()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: org.eclipse.jdt.internal.core.PackageFragment getPackageFragment(java.lang.String[])>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: void <clinit>()>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: void <init>(org.eclipse.core.resources.IResource,org.eclipse.jdt.internal.core.JavaProject)>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: void computeFolderChildren(org.eclipse.core.resources.IContainer,boolean,java.lang.String[],java.util.ArrayList,char[][],char[][])>
<org.eclipse.jdt.internal.core.PackageFragmentRoot: void setSourceAttachmentProperty(java.lang.String)>
<org.eclipse.jdt.internal.core.PackageFragmentRootInfo: int getRootKind()>
<org.eclipse.jdt.internal.core.PackageFragmentRootInfo: void <init>()>
<org.eclipse.jdt.internal.core.PackageFragmentRootInfo: void setRootKind(int)>
<org.eclipse.jdt.internal.core.SetClasspathOperation$3: java.lang.String getID()>
<org.eclipse.jdt.internal.core.SetClasspathOperation$3: void <init>(org.eclipse.jdt.internal.core.SetClasspathOperation,org.eclipse.core.runtime.IPath,org.eclipse.jdt.internal.core.search.indexing.IndexManager)>
<org.eclipse.jdt.internal.core.SetClasspathOperation$3: void run()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: boolean canModifyRoots()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: boolean isReadOnly()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: int classpathContains(org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.jdt.core.IClasspathEntry)>
<org.eclipse.jdt.internal.core.SetClasspathOperation: int getSourceAttachmentDeltaFlag(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.SetClasspathOperation: org.eclipse.jdt.core.IJavaModelStatus verify()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void <clinit>()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void <init>(org.eclipse.jdt.internal.core.JavaProject,org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.core.runtime.IPath,boolean,boolean,boolean)>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void addClasspathDeltas(org.eclipse.jdt.core.IPackageFragmentRoot[],int,org.eclipse.jdt.internal.core.JavaElementDelta)>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void executeOperation()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void generateClasspathChangeDeltas()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void saveClasspathIfNecessary()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void updateClasspath()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void updateCycleMarkersIfNecessary()>
<org.eclipse.jdt.internal.core.SetClasspathOperation: void updateProjectReferencesIfNecessary()>
<org.eclipse.jdt.internal.core.SimpleDelta: int getFlags()>
<org.eclipse.jdt.internal.core.SimpleDelta: int getKind()>
<org.eclipse.jdt.internal.core.SimpleDelta: void <init>()>
<org.eclipse.jdt.internal.core.SimpleDelta: void added()>
<org.eclipse.jdt.internal.core.SimpleDelta: void changed(int)>
<org.eclipse.jdt.internal.core.SimpleDelta: void removed()>
<org.eclipse.jdt.internal.core.SourceMapper$1: void <init>()>
<org.eclipse.jdt.internal.core.SourceMapper: void <clinit>()>
<org.eclipse.jdt.internal.core.SourceMapper: void <init>()>
<org.eclipse.jdt.internal.core.SourceRange: void <init>(int,int)>
<org.eclipse.jdt.internal.core.builder.AbstractImageBuilder: boolean isExcludedFromProject(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.builder.AbstractImageBuilder: org.eclipse.core.resources.IContainer createFolder(org.eclipse.core.runtime.IPath,org.eclipse.core.resources.IContainer)>
<org.eclipse.jdt.internal.core.builder.AbstractImageBuilder: org.eclipse.jdt.internal.compiler.Compiler newCompiler()>
<org.eclipse.jdt.internal.core.builder.AbstractImageBuilder: void <clinit>()>
<org.eclipse.jdt.internal.core.builder.AbstractImageBuilder: void <init>(org.eclipse.jdt.internal.core.builder.JavaBuilder)>
<org.eclipse.jdt.internal.core.builder.AbstractImageBuilder: void cleanUp()>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder$1: boolean visit(org.eclipse.core.resources.IResourceProxy)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder$1: void <init>(org.eclipse.jdt.internal.core.builder.BatchImageBuilder,char[][],char[][],java.util.ArrayList,org.eclipse.jdt.internal.core.builder.ClasspathMultiDirectory,boolean)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder$4: boolean visit(org.eclipse.core.resources.IResourceProxy)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder$4: void <init>(org.eclipse.jdt.internal.core.builder.BatchImageBuilder,char[][],char[][],int,org.eclipse.core.resources.IContainer,boolean,boolean)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder: void <init>(org.eclipse.jdt.internal.core.builder.JavaBuilder)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder: void addAllSourceFiles(java.util.ArrayList)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder: void build()>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder: void cleanOutputFolders(boolean)>
<org.eclipse.jdt.internal.core.builder.BatchImageBuilder: void copyExtraResourcesBack(org.eclipse.jdt.internal.core.builder.ClasspathMultiDirectory,boolean)>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: java.lang.String problemsMessage()>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void <clinit>()>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void <init>(org.eclipse.core.runtime.IProgressMonitor,org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void begin()>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void checkCancel()>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void done()>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void resetProblemCounters()>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void subTask(java.lang.String)>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void updateProgress(float)>
<org.eclipse.jdt.internal.core.builder.BuildNotifier: void updateProgressDelta(float)>
<org.eclipse.jdt.internal.core.builder.ClasspathDirectory: void <init>(org.eclipse.core.resources.IContainer,boolean,org.eclipse.jdt.internal.compiler.env.AccessRuleSet)>
<org.eclipse.jdt.internal.core.builder.ClasspathDirectory: void cleanup()>
<org.eclipse.jdt.internal.core.builder.ClasspathDirectory: void reset()>
<org.eclipse.jdt.internal.core.builder.ClasspathJar: void <clinit>()>
<org.eclipse.jdt.internal.core.builder.ClasspathJar: void <init>(java.lang.String,long,org.eclipse.jdt.internal.compiler.env.AccessRuleSet)>
<org.eclipse.jdt.internal.core.builder.ClasspathJar: void <init>(org.eclipse.core.resources.IFile,org.eclipse.jdt.internal.compiler.env.AccessRuleSet)>
<org.eclipse.jdt.internal.core.builder.ClasspathJar: void cleanup()>
<org.eclipse.jdt.internal.core.builder.ClasspathLocation: org.eclipse.jdt.internal.core.builder.ClasspathLocation forLibrary(java.lang.String,long,org.eclipse.jdt.internal.compiler.env.AccessRuleSet)>
<org.eclipse.jdt.internal.core.builder.ClasspathLocation: org.eclipse.jdt.internal.core.builder.ClasspathLocation forLibrary(java.lang.String,org.eclipse.jdt.internal.compiler.env.AccessRuleSet)>
<org.eclipse.jdt.internal.core.builder.ClasspathLocation: org.eclipse.jdt.internal.core.builder.ClasspathLocation forLibrary(org.eclipse.core.resources.IFile,org.eclipse.jdt.internal.compiler.env.AccessRuleSet)>
<org.eclipse.jdt.internal.core.builder.ClasspathLocation: org.eclipse.jdt.internal.core.builder.ClasspathLocation forSourceFolder(org.eclipse.core.resources.IContainer,org.eclipse.core.resources.IContainer,char[][],char[][])>
<org.eclipse.jdt.internal.core.builder.ClasspathLocation: void <init>()>
<org.eclipse.jdt.internal.core.builder.ClasspathLocation: void reset()>
<org.eclipse.jdt.internal.core.builder.ClasspathMultiDirectory: void <init>(org.eclipse.core.resources.IContainer,org.eclipse.core.resources.IContainer,char[][],char[][])>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: boolean filterExtraResource(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: boolean isClasspathBroken(org.eclipse.jdt.core.IClasspathEntry[],org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: boolean isWorthBuilding()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: org.eclipse.core.resources.IProject[] build(int,java.util.Map,org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: org.eclipse.core.resources.IProject[] getRequiredProjects(boolean)>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void <clinit>()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void <init>()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void buildAll()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void buildFinished()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void buildStarting()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void clean(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void cleanup()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void clearLastState()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void initializeBuilder()>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void recordNewState(org.eclipse.jdt.internal.core.builder.State)>
<org.eclipse.jdt.internal.core.builder.JavaBuilder: void removeProblemsAndTasksFor(org.eclipse.core.resources.IResource)>
<org.eclipse.jdt.internal.core.builder.NameEnvironment: void <init>(org.eclipse.core.resources.IWorkspaceRoot,org.eclipse.jdt.internal.core.JavaProject,org.eclipse.jdt.internal.compiler.util.SimpleLookupTable)>
<org.eclipse.jdt.internal.core.builder.NameEnvironment: void cleanup()>
<org.eclipse.jdt.internal.core.builder.NameEnvironment: void computeClasspathLocations(org.eclipse.core.resources.IWorkspaceRoot,org.eclipse.jdt.internal.core.JavaProject,org.eclipse.jdt.internal.compiler.util.SimpleLookupTable)>
<org.eclipse.jdt.internal.core.builder.NameEnvironment: void setNames(java.lang.String[],org.eclipse.jdt.internal.core.builder.SourceFile[])>
<org.eclipse.jdt.internal.core.builder.ProblemFactory: org.eclipse.jdt.internal.core.builder.ProblemFactory getProblemFactory(java.util.Locale)>
<org.eclipse.jdt.internal.core.builder.ProblemFactory: void <clinit>()>
<org.eclipse.jdt.internal.core.builder.ProblemFactory: void <init>(java.util.Locale)>
<org.eclipse.jdt.internal.core.builder.State: void <clinit>()>
<org.eclipse.jdt.internal.core.builder.State: void <init>(org.eclipse.jdt.internal.core.builder.JavaBuilder)>
<org.eclipse.jdt.internal.core.builder.WorkQueue: void <init>()>
<org.eclipse.jdt.internal.core.index.DiskIndex$IntList: int[] asArray()>
<org.eclipse.jdt.internal.core.index.DiskIndex$IntList: void <init>(org.eclipse.jdt.internal.core.index.DiskIndex,int[])>
<org.eclipse.jdt.internal.core.index.DiskIndex$IntList: void add(int)>
<org.eclipse.jdt.internal.core.index.DiskIndex: java.io.File getIndexFile()>
<org.eclipse.jdt.internal.core.index.DiskIndex: java.lang.String[] computeDocumentNames(java.lang.String[],int[],org.eclipse.jdt.internal.compiler.util.SimpleLookupTable,org.eclipse.jdt.internal.core.index.MemoryIndex)>
<org.eclipse.jdt.internal.core.index.DiskIndex: java.lang.String[] readAllDocumentNames()>
<org.eclipse.jdt.internal.core.index.DiskIndex: org.eclipse.jdt.internal.core.index.DiskIndex mergeWith(org.eclipse.jdt.internal.core.index.MemoryIndex)>
<org.eclipse.jdt.internal.core.index.DiskIndex: org.eclipse.jdt.internal.core.util.SimpleSet addDocumentNames(java.lang.String,org.eclipse.jdt.internal.core.index.MemoryIndex)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void <clinit>()>
<org.eclipse.jdt.internal.core.index.DiskIndex: void <init>(java.lang.String)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void copyQueryResults(org.eclipse.jdt.internal.compiler.util.HashtableOfObject,int)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void initialize(boolean)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void initializeFrom(org.eclipse.jdt.internal.core.index.DiskIndex,java.io.File)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void writeAllDocumentNames(java.lang.String[],java.io.DataOutputStream)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void writeCategories(java.io.DataOutputStream)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void writeCategoryTable(char[],org.eclipse.jdt.internal.compiler.util.HashtableOfObject,java.io.DataOutputStream)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void writeDocumentNumbers(int[],java.io.DataOutputStream)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void writeHeaderInfo(java.io.DataOutputStream)>
<org.eclipse.jdt.internal.core.index.DiskIndex: void writeOffsetToHeader(int)>
<org.eclipse.jdt.internal.core.index.Index: boolean hasChanged()>
<org.eclipse.jdt.internal.core.index.Index: java.io.File getIndexFile()>
<org.eclipse.jdt.internal.core.index.Index: java.lang.String containerRelativePath(java.lang.String)>
<org.eclipse.jdt.internal.core.index.Index: java.lang.String[] queryDocumentNames(java.lang.String)>
<org.eclipse.jdt.internal.core.index.Index: void <init>(java.lang.String,java.lang.String,boolean)>
<org.eclipse.jdt.internal.core.index.Index: void addIndexEntry(char[],char[],java.lang.String)>
<org.eclipse.jdt.internal.core.index.Index: void remove(java.lang.String)>
<org.eclipse.jdt.internal.core.index.Index: void save()>
<org.eclipse.jdt.internal.core.index.MemoryIndex: boolean hasChanged()>
<org.eclipse.jdt.internal.core.index.MemoryIndex: void <init>()>
<org.eclipse.jdt.internal.core.index.MemoryIndex: void addIndexEntry(char[],char[],java.lang.String)>
<org.eclipse.jdt.internal.core.index.MemoryIndex: void remove(java.lang.String)>
<org.eclipse.jdt.internal.core.jdom.CompilationUnit: char[] getContents()>
<org.eclipse.jdt.internal.core.jdom.CompilationUnit: char[] getFileName()>
<org.eclipse.jdt.internal.core.jdom.CompilationUnit: void <init>(char[],char[])>
<org.eclipse.jdt.internal.core.search.BasicSearchEngine: org.eclipse.jdt.core.search.SearchParticipant getDefaultSearchParticipant()>
<org.eclipse.jdt.internal.core.search.BasicSearchEngine: void <clinit>()>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: byte[] getByteContents()>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: char[] getCharContents()>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: java.lang.String getEncoding()>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: org.eclipse.core.resources.IFile getFile()>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: org.eclipse.core.runtime.IPath getLocation()>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: void <init>(java.lang.String,org.eclipse.jdt.core.search.SearchParticipant)>
<org.eclipse.jdt.internal.core.search.JavaSearchDocument: void <init>(java.util.zip.ZipEntry,org.eclipse.core.runtime.IPath,byte[],org.eclipse.jdt.core.search.SearchParticipant)>
<org.eclipse.jdt.internal.core.search.JavaSearchParticipant: org.eclipse.jdt.core.search.SearchDocument getDocument(java.lang.String)>
<org.eclipse.jdt.internal.core.search.JavaSearchParticipant: void <init>()>
<org.eclipse.jdt.internal.core.search.JavaSearchParticipant: void indexDocument(org.eclipse.jdt.core.search.SearchDocument,org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: char[] erasure(char[])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void <init>(org.eclipse.jdt.core.search.SearchDocument)>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addClassDeclaration(int,char[],char[],char[][],char[],char[][],char[][])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addConstructorDeclaration(char[],char[][],char[][])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addConstructorReference(char[],int)>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addFieldDeclaration(char[],char[])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addFieldReference(char[])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addIndexEntry(char[],char[])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addInterfaceDeclaration(int,char[],char[],char[][],char[][],char[][])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addMethodDeclaration(char[],char[][],char[],char[][])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addMethodReference(char[],int)>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addNameReference(char[])>
<org.eclipse.jdt.internal.core.search.indexing.AbstractIndexer: void addTypeReference(char[])>
<org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex: boolean execute(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex: java.lang.Integer updatedIndexState()>
<org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex: void <init>(org.eclipse.core.resources.IFile,org.eclipse.jdt.internal.core.search.indexing.IndexManager)>
<org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.jdt.internal.core.search.indexing.IndexManager)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] convertToArrayType(char[],int)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] decodeFieldType(char[])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] decodeReturnType(char[])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] extractClassName(int[],org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader,int)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] extractClassReference(int[],org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader,int)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] extractName(int[],org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader,int)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] extractType(int[],org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader,int)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[] replace(char,char,char[])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[][] decodeParameterTypes(char[])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: char[][] replace(char,char,char[][])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: int extractArgCount(char[])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: void <clinit>()>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: void <init>(org.eclipse.jdt.core.search.SearchDocument)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: void addTypeReference(char[])>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: void convertToArrayType(char[][],int,int)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: void extractReferenceFromConstantPool(byte[],org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader)>
<org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer: void indexDocument()>
<org.eclipse.jdt.internal.core.search.indexing.IIndexConstants: void <clinit>()>
<org.eclipse.jdt.internal.core.search.indexing.IndexAllProject$1: boolean visit(org.eclipse.core.resources.IResourceProxy)>
<org.eclipse.jdt.internal.core.search.indexing.IndexAllProject$1: void <init>(org.eclipse.jdt.internal.core.search.indexing.IndexAllProject,char[][],char[][],org.eclipse.jdt.internal.compiler.util.SimpleLookupTable,boolean,java.util.HashSet)>
<org.eclipse.jdt.internal.core.search.indexing.IndexAllProject: boolean equals(java.lang.Object)>
<org.eclipse.jdt.internal.core.search.indexing.IndexAllProject: boolean execute(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.search.indexing.IndexAllProject: java.lang.Integer updatedIndexState()>
<org.eclipse.jdt.internal.core.search.indexing.IndexAllProject: void <init>(org.eclipse.core.resources.IProject,org.eclipse.jdt.internal.core.search.indexing.IndexManager)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager$1: boolean execute(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager$1: void <init>(org.eclipse.jdt.internal.core.search.indexing.IndexManager,org.eclipse.core.runtime.IPath,org.eclipse.jdt.internal.core.search.indexing.IndexManager,java.lang.String,org.eclipse.jdt.core.search.SearchDocument,org.eclipse.jdt.core.search.SearchParticipant)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: char[] readIndexState()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: java.lang.String computeIndexLocation(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: java.lang.String processName()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: org.eclipse.core.runtime.IPath getJavaPluginWorkingLocation()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: org.eclipse.jdt.internal.compiler.util.SimpleLookupTable getIndexStates()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: org.eclipse.jdt.internal.core.index.Index getIndex(org.eclipse.core.runtime.IPath,boolean,boolean)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: org.eclipse.jdt.internal.core.index.Index getIndex(org.eclipse.core.runtime.IPath,java.lang.String,boolean,boolean)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: org.eclipse.jdt.internal.core.index.Index getIndexForUpdate(org.eclipse.core.runtime.IPath,boolean,boolean)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: org.eclipse.jdt.internal.core.index.Index recreateIndex(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void <clinit>()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void <init>()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void aboutToUpdateIndex(org.eclipse.core.runtime.IPath,java.lang.Integer)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void addSource(org.eclipse.core.resources.IFile,org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void indexAll(org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void indexDocument(org.eclipse.jdt.core.search.SearchDocument,org.eclipse.jdt.core.search.SearchParticipant,org.eclipse.jdt.internal.core.index.Index,org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void indexLibrary(org.eclipse.core.runtime.IPath,org.eclipse.core.resources.IProject)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void jobWasCancelled(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void moveToNextJob()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void notifyIdle(long)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void removeIndex(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void removeIndexFamily(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void reset()>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void saveIndex(org.eclipse.jdt.internal.core.index.Index)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void scheduleDocumentIndexing(org.eclipse.jdt.core.search.SearchDocument,org.eclipse.core.runtime.IPath,java.lang.String,org.eclipse.jdt.core.search.SearchParticipant)>
<org.eclipse.jdt.internal.core.search.indexing.IndexManager: void updateIndexState(java.lang.String,java.lang.Integer)>
<org.eclipse.jdt.internal.core.search.indexing.IndexRequest: boolean belongsTo(java.lang.String)>
<org.eclipse.jdt.internal.core.search.indexing.IndexRequest: java.lang.Integer updatedIndexState()>
<org.eclipse.jdt.internal.core.search.indexing.IndexRequest: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.jdt.internal.core.search.indexing.IndexManager)>
<org.eclipse.jdt.internal.core.search.indexing.IndexRequest: void cancel()>
<org.eclipse.jdt.internal.core.search.indexing.IndexRequest: void ensureReadyToRun()>
<org.eclipse.jdt.internal.core.search.indexing.InternalSearchDocument: java.lang.String getContainerRelativePath()>
<org.eclipse.jdt.internal.core.search.indexing.InternalSearchDocument: void <init>()>
<org.eclipse.jdt.internal.core.search.indexing.InternalSearchDocument: void addIndexEntry(char[],char[])>
<org.eclipse.jdt.internal.core.search.indexing.InternalSearchDocument: void removeAllIndexEntries()>
<org.eclipse.jdt.internal.core.search.indexing.ReadWriteMonitor: void <init>()>
<org.eclipse.jdt.internal.core.search.indexing.ReadWriteMonitor: void enterRead()>
<org.eclipse.jdt.internal.core.search.indexing.ReadWriteMonitor: void enterWrite()>
<org.eclipse.jdt.internal.core.search.indexing.ReadWriteMonitor: void exitRead()>
<org.eclipse.jdt.internal.core.search.indexing.ReadWriteMonitor: void exitWrite()>
<org.eclipse.jdt.internal.core.search.indexing.SaveIndex: boolean execute(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.search.indexing.SaveIndex: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.jdt.internal.core.search.indexing.IndexManager)>
<org.eclipse.jdt.internal.core.search.indexing.SourceIndexer: void <init>(org.eclipse.jdt.core.search.SearchDocument)>
<org.eclipse.jdt.internal.core.search.indexing.SourceIndexer: void indexDocument()>
<org.eclipse.jdt.internal.core.search.indexing.SourceIndexerRequestor: void <init>(org.eclipse.jdt.internal.core.search.indexing.SourceIndexer)>
<org.eclipse.jdt.internal.core.search.indexing.SourceIndexerRequestor: void acceptTypeReference(char[],int)>
<org.eclipse.jdt.internal.core.search.indexing.SourceIndexerRequestor: void acceptTypeReference(char[][],int,int)>
<org.eclipse.jdt.internal.core.search.matching.ConstructorPattern: char[] createIndexKey(char[],int)>
<org.eclipse.jdt.internal.core.search.matching.ConstructorPattern: void <clinit>()>
<org.eclipse.jdt.internal.core.search.matching.FieldPattern: char[] createIndexKey(char[])>
<org.eclipse.jdt.internal.core.search.matching.FieldPattern: void <clinit>()>
<org.eclipse.jdt.internal.core.search.matching.MethodPattern: char[] createIndexKey(char[],int)>
<org.eclipse.jdt.internal.core.search.matching.MethodPattern: void <clinit>()>
<org.eclipse.jdt.internal.core.search.matching.SuperTypeReferencePattern: char[] createIndexKey(int,char[],char[],char[][],char[][],char,char[],char)>
<org.eclipse.jdt.internal.core.search.matching.SuperTypeReferencePattern: void <clinit>()>
<org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern$PackageNameSet: void <init>(int)>
<org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern: char[] createIndexKey(int,char[],char[],char[][])>
<org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern: void <clinit>()>
<org.eclipse.jdt.internal.core.search.processing.JobManager$1$ProgressJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.core.search.processing.JobManager$1$ProgressJob: void <init>(org.eclipse.jdt.internal.core.search.processing.JobManager,java.lang.String)>
<org.eclipse.jdt.internal.core.search.processing.JobManager: boolean isJobWaiting(org.eclipse.jdt.internal.core.search.processing.IJob)>
<org.eclipse.jdt.internal.core.search.processing.JobManager: int awaitingJobsCount()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: org.eclipse.jdt.internal.core.search.processing.IJob currentJob()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void <clinit>()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void <init>()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void activateProcessing()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void disable()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void discardJobs(java.lang.String)>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void enable()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void moveToNextJob()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void request(org.eclipse.jdt.internal.core.search.processing.IJob)>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void reset()>
<org.eclipse.jdt.internal.core.search.processing.JobManager: void run()>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: int flushCommentsDefinedPriorTo(int)>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: void <init>(org.eclipse.jdt.internal.compiler.problem.ProblemReporter,boolean)>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: void consumeInterfaceHeader()>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: void initialize()>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: void initializeScanner()>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: void pushOnCommentsStack(int,int)>
<org.eclipse.jdt.internal.core.util.CommentRecorderParser: void resetModifiers()>
<org.eclipse.jdt.internal.core.util.CommentRecorderScanner: void <init>(boolean,boolean,boolean,long,char[][],char[][],boolean)>
<org.eclipse.jdt.internal.core.util.CommentRecorderScanner: void recordComment(int)>
<org.eclipse.jdt.internal.core.util.LRUCache: java.lang.Object get(java.lang.Object)>
<org.eclipse.jdt.internal.core.util.LRUCache: void <init>(int)>
<org.eclipse.jdt.internal.core.util.Messages: java.lang.String bind(java.lang.String,java.lang.Object)>
<org.eclipse.jdt.internal.core.util.Messages: java.lang.String bind(java.lang.String,java.lang.Object[])>
<org.eclipse.jdt.internal.core.util.Messages: void <clinit>()>
<org.eclipse.jdt.internal.core.util.ReferenceInfoAdapter: void <init>()>
<org.eclipse.jdt.internal.core.util.SimpleSet: void <init>()>
<org.eclipse.jdt.internal.core.util.SimpleSet: void <init>(int)>
<org.eclipse.jdt.internal.core.util.SimpleWordSet: char[] add(char[])>
<org.eclipse.jdt.internal.core.util.SimpleWordSet: void <init>(int)>
<org.eclipse.jdt.internal.core.util.SimpleWordSet: void rehash()>
<org.eclipse.jdt.internal.core.util.Util: boolean isExcluded(org.eclipse.core.resources.IResource,char[][],char[][])>
<org.eclipse.jdt.internal.core.util.Util: boolean isExcluded(org.eclipse.core.runtime.IPath,char[][],char[][],boolean)>
<org.eclipse.jdt.internal.core.util.Util: boolean isJavaLikeFileName(java.lang.String)>
<org.eclipse.jdt.internal.core.util.Util: boolean isValidFolderNameForPackage(java.lang.String)>
<org.eclipse.jdt.internal.core.util.Util: byte[] getResourceContentsAsByteArray(org.eclipse.core.resources.IFile)>
<org.eclipse.jdt.internal.core.util.Util: char[][] getJavaLikeExtensions()>
<org.eclipse.jdt.internal.core.util.Util: int indexOfEnclosingPath(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath[],int)>
<org.eclipse.jdt.internal.core.util.Util: int indexOfJavaLikeExtension(java.lang.String)>
<org.eclipse.jdt.internal.core.util.Util: int indexOfMatchingPath(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath[],int)>
<org.eclipse.jdt.internal.core.util.Util: int writeUTF(java.io.OutputStream,char[])>
<org.eclipse.jdt.internal.core.util.Util: java.lang.String getProblemArgumentsForMarker(java.lang.String[])>
<org.eclipse.jdt.internal.core.util.Util: java.lang.String relativePath(org.eclipse.core.runtime.IPath,int)>
<org.eclipse.jdt.internal.core.util.Util: void <clinit>()>
<org.eclipse.jdt.internal.core.util.Util: void log(java.lang.Throwable,java.lang.String)>
<org.eclipse.jdt.internal.core.util.Util: void quickSort(int[],int,int)>
<org.eclipse.jdt.internal.core.util.Util: void quickSort(java.lang.String[],int,int)>
<org.eclipse.jdt.internal.core.util.Util: void setReadOnly(org.eclipse.core.resources.IResource,boolean)>
<org.eclipse.jdt.internal.core.util.Util: void sort(int[])>
<org.eclipse.jdt.internal.core.util.Util: void sort(java.lang.String[])>
<org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions: java.lang.String getAlignment(int)>
<org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions: java.util.Map getMap()>
<org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions: org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions getEclipseDefaultSettings()>
<org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions: void <init>()>
<org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions: void setEclipseDefaultSettings()>
<org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions: void setJavaConventionsSettings()>
<org.eclipse.jdt.internal.formatter.align.Alignment: void <clinit>()>
<org.eclipse.jdt.internal.launching.CompositeId: int getPartCount()>
<org.eclipse.jdt.internal.launching.CompositeId: java.lang.String get(int)>
<org.eclipse.jdt.internal.launching.CompositeId: java.lang.String toString()>
<org.eclipse.jdt.internal.launching.CompositeId: org.eclipse.jdt.internal.launching.CompositeId fromString(java.lang.String)>
<org.eclipse.jdt.internal.launching.CompositeId: void <init>(java.lang.String[])>
<org.eclipse.jdt.internal.launching.JavaClasspathVariablesInitializer: boolean setAutobuild(org.eclipse.core.resources.IWorkspace,boolean)>
<org.eclipse.jdt.internal.launching.JavaClasspathVariablesInitializer: org.eclipse.core.runtime.IProgressMonitor getMonitor()>
<org.eclipse.jdt.internal.launching.JavaClasspathVariablesInitializer: void <init>()>
<org.eclipse.jdt.internal.launching.JavaClasspathVariablesInitializer: void initialize(java.lang.String)>
<org.eclipse.jdt.internal.launching.JavaClasspathVariablesInitializer: void setJREVariable(org.eclipse.core.runtime.IPath,java.lang.String)>
<org.eclipse.jdt.internal.launching.JavaLaunchConfigurationUtils: java.lang.String serializeDocument(org.w3c.dom.Document)>
<org.eclipse.jdt.internal.launching.LaunchingMessages: void <clinit>()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$1: void <init>(org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$1: void run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$JREUpdateJob: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$JREUpdateJob: void <init>(org.eclipse.jdt.internal.launching.LaunchingPlugin,org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges: void <init>(org.eclipse.jdt.internal.launching.LaunchingPlugin)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges: void access$0(org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges,org.eclipse.core.runtime.IProgressMonitor,org.eclipse.jdt.core.IJavaProject[])>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges: void doit(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges: void process()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges: void rebind(org.eclipse.core.runtime.IProgressMonitor,org.eclipse.jdt.core.IJavaProject[])>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: boolean isIgnoreVMDefPropertyChangeEvents()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: java.io.File getFileInPlugin(org.eclipse.core.runtime.IPath)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: java.lang.String getUniqueIdentifier()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: org.eclipse.jdt.internal.launching.LaunchingPlugin getDefault()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: org.eclipse.jdt.internal.launching.LibraryInfo getLibraryInfo(java.lang.String)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: org.eclipse.jdt.internal.launching.VMDefinitionsContainer getVMDefinitions(java.lang.String)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: org.w3c.dom.Document getDocument()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void <clinit>()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void <init>()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void log(java.lang.String)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void log(java.lang.Throwable)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void log(org.eclipse.core.runtime.IStatus)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void processVMPrefsChanged(java.lang.String,java.lang.String)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void propertyChange(org.eclipse.core.runtime.Preferences$PropertyChangeEvent)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void resourceChanged(org.eclipse.core.resources.IResourceChangeEvent)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void restoreLibraryInfo()>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void start(org.osgi.framework.BundleContext)>
<org.eclipse.jdt.internal.launching.LaunchingPlugin: void vmAdded(org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.internal.launching.LibraryInfo: java.lang.String getVersion()>
<org.eclipse.jdt.internal.launching.LibraryInfo: java.lang.String[] getBootpath()>
<org.eclipse.jdt.internal.launching.LibraryInfo: java.lang.String[] getExtensionDirs()>
<org.eclipse.jdt.internal.launching.LibraryInfo: void <init>(java.lang.String,java.lang.String[],java.lang.String[],java.lang.String[])>
<org.eclipse.jdt.internal.launching.ListenerList: java.lang.Object[] getListeners()>
<org.eclipse.jdt.internal.launching.ListenerList: void <clinit>()>
<org.eclipse.jdt.internal.launching.ListenerList: void <init>(int)>
<org.eclipse.jdt.internal.launching.ListenerList: void add(java.lang.Object)>
<org.eclipse.jdt.internal.launching.ListenerList: void remove(java.lang.Object)>
<org.eclipse.jdt.internal.launching.Standard11xVMType: boolean canDetectDefaultSystemLibraries(java.io.File,java.io.File)>
<org.eclipse.jdt.internal.launching.Standard11xVMType: org.eclipse.core.runtime.IPath getDefaultSystemLibrary(java.io.File)>
<org.eclipse.jdt.internal.launching.Standard11xVMType: org.eclipse.jdt.launching.LibraryLocation[] getDefaultLibraryLocations(java.io.File)>
<org.eclipse.jdt.internal.launching.Standard11xVMType: void <init>()>
<org.eclipse.jdt.internal.launching.StandardVM: void <init>(org.eclipse.jdt.launching.IVMInstallType,java.lang.String)>
<org.eclipse.jdt.internal.launching.StandardVMType: boolean canDetectDefaultSystemLibraries(java.io.File,java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: java.io.File detectInstallLocation()>
<org.eclipse.jdt.internal.launching.StandardVMType: java.io.File findJavaExecutable(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: java.io.File getDefaultEndorsedDirectory(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: java.io.File getDefaultExtensionDirectory(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: java.lang.String getDefaultRootPath()>
<org.eclipse.jdt.internal.launching.StandardVMType: java.lang.String getVMVersion(java.io.File,java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: java.net.URL getDefaultJavadocLocation(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: java.util.List gatherAllLibraries(java.lang.String[],java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.core.runtime.IPath getDefaultPackageRootPath()>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.core.runtime.IPath getDefaultSystemLibrary(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.core.runtime.IPath getDefaultSystemLibrarySource(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.core.runtime.IStatus validateInstallLocation(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.jdt.internal.launching.LibraryInfo generateLibraryInfo(java.io.File,java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.jdt.internal.launching.LibraryInfo getDefaultLibraryInfo(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.jdt.internal.launching.LibraryInfo getLibraryInfo(java.io.File,java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.jdt.launching.IVMInstall doCreateVMInstall(java.lang.String)>
<org.eclipse.jdt.internal.launching.StandardVMType: org.eclipse.jdt.launching.LibraryLocation[] getDefaultLibraryLocations(java.io.File)>
<org.eclipse.jdt.internal.launching.StandardVMType: void <clinit>()>
<org.eclipse.jdt.internal.launching.StandardVMType: void <init>()>
<org.eclipse.jdt.internal.launching.StandardVMType: void setDefaultRootPath(java.lang.String)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: java.lang.String getAsXML()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: java.lang.String getDefaultVMInstallCompositeID()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: java.lang.String getDefaultVMInstallConnectorTypeID()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: java.util.List getVMList()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: java.util.List getValidVMList()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: java.util.Map getVMTypeToVMMap()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: org.eclipse.jdt.internal.launching.VMDefinitionsContainer parseXMLIntoContainer(java.io.InputStream)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: org.w3c.dom.Element vmAsElement(org.w3c.dom.Document,org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: org.w3c.dom.Element vmTypeAsElement(org.w3c.dom.Document,org.eclipse.jdt.launching.IVMInstallType)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: void <init>()>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: void addVM(org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: void populateVMForType(org.eclipse.jdt.launching.IVMInstallType,org.w3c.dom.Element,org.eclipse.jdt.internal.launching.VMDefinitionsContainer)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: void populateVMTypes(org.w3c.dom.Element,org.eclipse.jdt.internal.launching.VMDefinitionsContainer)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: void setDefaultVMInstallCompositeID(java.lang.String)>
<org.eclipse.jdt.internal.launching.VMDefinitionsContainer: void setDefaultVMInstallConnectorTypeID(java.lang.String)>
<org.eclipse.jdt.launching.AbstractVMInstall: java.io.File getInstallLocation()>
<org.eclipse.jdt.launching.AbstractVMInstall: java.lang.String getId()>
<org.eclipse.jdt.launching.AbstractVMInstall: java.lang.String getName()>
<org.eclipse.jdt.launching.AbstractVMInstall: java.lang.String getVMArgs()>
<org.eclipse.jdt.launching.AbstractVMInstall: java.net.URL getJavadocLocation()>
<org.eclipse.jdt.launching.AbstractVMInstall: org.eclipse.jdt.launching.IVMInstallType getVMInstallType()>
<org.eclipse.jdt.launching.AbstractVMInstall: org.eclipse.jdt.launching.LibraryLocation[] getLibraryLocations()>
<org.eclipse.jdt.launching.AbstractVMInstall: void <init>(org.eclipse.jdt.launching.IVMInstallType,java.lang.String)>
<org.eclipse.jdt.launching.AbstractVMInstall: void setInstallLocation(java.io.File)>
<org.eclipse.jdt.launching.AbstractVMInstall: void setJavadocLocation(java.net.URL)>
<org.eclipse.jdt.launching.AbstractVMInstall: void setLibraryLocations(org.eclipse.jdt.launching.LibraryLocation[])>
<org.eclipse.jdt.launching.AbstractVMInstall: void setName(java.lang.String)>
<org.eclipse.jdt.launching.AbstractVMInstall: void setNotify(boolean)>
<org.eclipse.jdt.launching.AbstractVMInstall: void setVMArgs(java.lang.String)>
<org.eclipse.jdt.launching.AbstractVMInstallType: java.lang.String getId()>
<org.eclipse.jdt.launching.AbstractVMInstallType: org.eclipse.jdt.launching.IVMInstall createVMInstall(java.lang.String)>
<org.eclipse.jdt.launching.AbstractVMInstallType: org.eclipse.jdt.launching.IVMInstall findVMInstall(java.lang.String)>
<org.eclipse.jdt.launching.AbstractVMInstallType: org.eclipse.jdt.launching.IVMInstall[] getVMInstalls()>
<org.eclipse.jdt.launching.AbstractVMInstallType: void <init>()>
<org.eclipse.jdt.launching.AbstractVMInstallType: void setInitializationData(org.eclipse.core.runtime.IConfigurationElement,java.lang.String,java.lang.Object)>
<org.eclipse.jdt.launching.IVMInstallChangedListener: void <clinit>()>
<org.eclipse.jdt.launching.JavaRuntime$1: org.eclipse.core.runtime.IStatus run(org.eclipse.core.runtime.IProgressMonitor)>
<org.eclipse.jdt.launching.JavaRuntime$1: void <init>(java.lang.String,java.lang.String)>
<org.eclipse.jdt.launching.JavaRuntime: java.lang.String generateDetectedVMName(org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.launching.JavaRuntime: java.lang.String getCompositeIdFromVM(org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.launching.JavaRuntime: java.lang.String getDefaultVMConnectorId()>
<org.eclipse.jdt.launching.JavaRuntime: java.lang.String getDefaultVMId()>
<org.eclipse.jdt.launching.JavaRuntime: java.lang.String getVMsAsXML()>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.core.runtime.Preferences getPreferences()>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.jdt.launching.IVMInstall getDefaultVMInstall()>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.jdt.launching.IVMInstall getVMFromCompositeId(java.lang.String)>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.jdt.launching.IVMInstallType getVMInstallType(java.lang.String)>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.jdt.launching.IVMInstallType[] getVMInstallTypes()>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.jdt.launching.LibraryLocation[] getLibraryLocations(org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.launching.JavaRuntime: org.eclipse.jdt.launching.VMStandin detectEclipseRuntime()>
<org.eclipse.jdt.launching.JavaRuntime: void <clinit>()>
<org.eclipse.jdt.launching.JavaRuntime: void addVMInstallChangedListener(org.eclipse.jdt.launching.IVMInstallChangedListener)>
<org.eclipse.jdt.launching.JavaRuntime: void detectAndSaveVMDefinitions()>
<org.eclipse.jdt.launching.JavaRuntime: void detectDefaultVM()>
<org.eclipse.jdt.launching.JavaRuntime: void fireVMAdded(org.eclipse.jdt.launching.IVMInstall)>
<org.eclipse.jdt.launching.JavaRuntime: void initializeVMConfiguration()>
<org.eclipse.jdt.launching.JavaRuntime: void initializeVMTypes()>
<org.eclipse.jdt.launching.JavaRuntime: void removeVMInstallChangedListener(org.eclipse.jdt.launching.IVMInstallChangedListener)>
<org.eclipse.jdt.launching.JavaRuntime: void saveVMDefinitions(java.lang.String)>
<org.eclipse.jdt.launching.JavaRuntime: void setDefaultVMInstall(org.eclipse.jdt.launching.IVMInstall,org.eclipse.core.runtime.IProgressMonitor,boolean)>
<org.eclipse.jdt.launching.LibraryLocation: org.eclipse.core.runtime.IPath getSystemLibraryPath()>
<org.eclipse.jdt.launching.LibraryLocation: org.eclipse.core.runtime.IPath getSystemLibrarySourcePath()>
<org.eclipse.jdt.launching.LibraryLocation: void <init>(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath,java.net.URL)>
<org.eclipse.jdt.launching.PropertyChangeEvent: void <init>(java.lang.Object,java.lang.String,java.lang.Object,java.lang.Object)>
<org.eclipse.jdt.launching.StandardClasspathProvider: void <init>()>
<org.eclipse.jdt.launching.StandardSourcePathProvider: void <init>()>
<org.eclipse.jdt.launching.VMStandin: org.eclipse.jdt.launching.IVMInstall convertToRealVM()>
<org.eclipse.jdt.launching.VMStandin: void <init>(org.eclipse.jdt.launching.IVMInstallType,java.lang.String)>
<org.eclipse.jdt.launching.sourcelookup.ArchiveSourceLocation: void <clinit>()>
<org.eclipse.jdt.launching.sourcelookup.ArchiveSourceLocation: void closeArchives()>
<org.eclipse.osgi.framework.adaptor.FilePath: boolean hasTrailingSlash()>
<org.eclipse.osgi.framework.adaptor.FilePath: boolean isAbsolute()>
<org.eclipse.osgi.framework.adaptor.FilePath: int computeSegmentCount(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.FilePath: int matchingFirstSegments(org.eclipse.osgi.framework.adaptor.FilePath)>
<org.eclipse.osgi.framework.adaptor.FilePath: java.lang.String makeRelative(org.eclipse.osgi.framework.adaptor.FilePath)>
<org.eclipse.osgi.framework.adaptor.FilePath: java.lang.String toString()>
<org.eclipse.osgi.framework.adaptor.FilePath: java.lang.String[] computeSegments(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.FilePath: void <clinit>()>
<org.eclipse.osgi.framework.adaptor.FilePath: void <init>(java.io.File)>
<org.eclipse.osgi.framework.adaptor.FilePath: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.FilePath: void initialize(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: boolean isReference()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: int getGeneration()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: int getStartLevel()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: int getStatus()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: int getType()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.io.File createGenerationDir()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.io.File getBaseFile()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.io.File getBundleStoreDir()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.io.File getGenerationDir()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String findLibrary(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String findNativePath(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String getActivator()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String getFileName()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String getLocation()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String getSymbolicName()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String[] getClassPath()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String[] getClassPath(org.eclipse.osgi.util.ManifestElement[])>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.lang.String[] getNativePaths()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.net.URL getEntry(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: java.util.Dictionary getManifest()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: long getBundleID()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: org.eclipse.osgi.framework.adaptor.BundleClassLoader createClassLoader(org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate,org.eclipse.osgi.framework.adaptor.BundleProtectionDomain,java.lang.String[])>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor getAdaptor()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: org.eclipse.osgi.framework.adaptor.core.BundleFile createBaseBundleFile()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: org.eclipse.osgi.framework.adaptor.core.BundleFile getBaseBundleFile()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: org.osgi.framework.Bundle getBundle()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: org.osgi.framework.Version getVersion()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void <init>(org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor,long)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void close()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void initBundleStoreDirs(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void initializeNewBundle()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void loadFromManifest()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void open()>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setActivator(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setBundle(org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setBundleStoreDir(java.io.File)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setClassPathString(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setDynamicImports(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setExecutionEnvironment(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setFileName(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setLastModified(long)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setLocation(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setReference(boolean)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setStartLevel(int)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setStatus(int)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setSymbolicName(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setType(int)>
<org.eclipse.osgi.framework.adaptor.core.AbstractBundleData: void setVersion(org.osgi.framework.Version)>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: java.lang.Class findLocalClass(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: java.lang.Class loadClass(java.lang.String,boolean)>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: java.lang.String findLibrary(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: java.net.URL findLocalResource(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: java.net.URL getResource(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate getDelegate()>
<org.eclipse.osgi.framework.adaptor.core.AbstractClassLoader: void <init>(org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate,java.security.ProtectionDomain,java.lang.String[],java.lang.ClassLoader)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor$1: org.eclipse.osgi.framework.adaptor.BundleData begin()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor$1: void <init>(org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor,java.net.URLConnection,java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor$1: void commit(boolean)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor$1: void undo()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor$ParentClassLoader: void <init>()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: boolean isStopping()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: boolean rm(java.io.File)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: int getInitialBundleStartLevel()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.io.File getBundleStoreRootDir()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.lang.ClassLoader getBundleClassLoaderParent()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.lang.String getExportPackages()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.lang.String getExportServices()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.lang.String getProvidePackages()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.lang.reflect.Method findaddURLMethod(java.lang.Class)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: java.util.Properties getProperties()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: long getNextBundleId()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.framework.adaptor.BundleData createSystemBundleData()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.framework.adaptor.BundleOperation installBundle(java.lang.String,java.net.URLConnection)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.framework.adaptor.ServiceRegistry getServiceRegistry()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.framework.adaptor.core.BundleFile createBaseBundleFile(java.io.File,org.eclipse.osgi.framework.adaptor.BundleData)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.framework.adaptor.core.BundleFile createBundleFile(java.io.File,org.eclipse.osgi.framework.adaptor.BundleData)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.framework.log.FrameworkLog getFrameworkLog()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.eclipse.osgi.service.resolver.State getState()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: org.osgi.framework.ServiceRegistration register(java.lang.String,java.lang.Object,org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void <clinit>()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void <init>(java.lang.String[])>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void checkSystemState(org.eclipse.osgi.service.resolver.State)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void compact(java.io.File)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void compactStorage()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void frameworkStart(org.osgi.framework.BundleContext)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void initialize(org.eclipse.osgi.framework.adaptor.EventPublisher)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void initializeStorage()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void loadProperties()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void processExtension(org.eclipse.osgi.framework.adaptor.BundleData,byte)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void readAdaptorManifest()>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void readFile(java.io.InputStream,java.io.File)>
<org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor: void updateState(org.eclipse.osgi.framework.adaptor.BundleData,int)>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$DirZipBundleEntry: void <init>(org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile,java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$FileBundleEntry: java.io.InputStream getInputStream()>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$FileBundleEntry: long getTime()>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$FileBundleEntry: void <init>(java.io.File,java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$ZipBundleEntry: java.io.InputStream getInputStream()>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$ZipBundleEntry: java.net.URL getFileURL()>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$ZipBundleEntry: long getSize()>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry$ZipBundleEntry: void <init>(java.util.zip.ZipEntry,org.eclipse.osgi.framework.adaptor.core.BundleFile)>
<org.eclipse.osgi.framework.adaptor.core.BundleEntry: void <init>()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$DirBundleFile: java.io.File getFile(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$DirBundleFile: org.eclipse.osgi.framework.adaptor.core.BundleEntry getEntry(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$DirBundleFile: void <init>(java.io.File)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$DirBundleFile: void open()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: boolean checkedOpen()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: boolean containsDir(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: java.io.File getExtractFile(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: java.io.File getFile(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: java.util.zip.ZipEntry getZipEntry(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: java.util.zip.ZipFile basicOpen()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: java.util.zip.ZipFile getZipFile()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: org.eclipse.osgi.framework.adaptor.core.BundleEntry getEntry(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: void <init>(java.io.File,org.eclipse.osgi.framework.adaptor.BundleData)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: void close()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile$ZipBundleFile: void open()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile: java.io.File getBaseFile()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile: java.net.URL getResourceURL(java.lang.String,long,int)>
<org.eclipse.osgi.framework.adaptor.core.BundleFile: void <clinit>()>
<org.eclipse.osgi.framework.adaptor.core.BundleFile: void <init>(java.io.File)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathDomain: void <init>(org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader,java.net.URL,java.security.PermissionCollection)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry: java.security.ProtectionDomain createProtectionDomain(java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry: java.security.ProtectionDomain getProtectionDomain()>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry: org.eclipse.osgi.framework.adaptor.core.BundleFile getBundleFile()>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry: void <init>(org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader,org.eclipse.osgi.framework.adaptor.core.BundleFile,java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: boolean addClassPathEntry(java.util.ArrayList,java.lang.String,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData,java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: java.lang.Class defineClass(java.lang.String,byte[],int,int,org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: java.lang.Class findClass(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: java.lang.Class findClassImpl(java.lang.String,org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: java.net.URL findResource(java.lang.String)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: java.net.URL findResourceImpl(java.lang.String,org.eclipse.osgi.framework.adaptor.core.BundleFile)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: java.net.URL findResourceImpl(java.lang.String,org.eclipse.osgi.framework.adaptor.core.BundleFile,int)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: org.eclipse.osgi.framework.adaptor.core.AbstractBundleData getHostData()>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: org.eclipse.osgi.framework.adaptor.core.BundleFile createBundleFile(java.io.File,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry getClasspath(java.lang.String,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData,java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$ClasspathEntry[] buildClasspath(java.lang.String[],org.eclipse.osgi.framework.adaptor.core.AbstractBundleData,java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader$FragmentClasspath[] getFragClasspaths()>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: void <clinit>()>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: void <init>(org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate,java.security.ProtectionDomain,java.lang.String[],java.lang.ClassLoader,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: void addDefaultDevEntries(java.util.ArrayList,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData,java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: void findClassPathEntry(java.util.ArrayList,java.lang.String,org.eclipse.osgi.framework.adaptor.core.AbstractBundleData,java.security.ProtectionDomain)>
<org.eclipse.osgi.framework.adaptor.core.DefaultClassLoader: void initialize()>
<org.eclipse.osgi.framework.adaptor.core.DevClassPathHelper: boolean inDevelopmentMode()>
<org.eclipse.osgi.framework.adaptor.core.DevClassPathHelper: void <clinit>()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: boolean initializeSystemState()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: org.eclipse.osgi.service.resolver.Resolver getResolver(boolean)>
<org.eclipse.osgi.framework.adaptor.core.StateManager: org.eclipse.osgi.service.resolver.State createSystemState()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: org.eclipse.osgi.service.resolver.State getState(boolean)>
<org.eclipse.osgi.framework.adaptor.core.StateManager: org.eclipse.osgi.service.resolver.State getSystemState()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: org.eclipse.osgi.service.resolver.State readSystemState()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: org.eclipse.osgi.service.resolver.StateObjectFactory getFactory()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: void <clinit>()>
<org.eclipse.osgi.framework.adaptor.core.StateManager: void <init>(java.io.File,java.io.File,org.osgi.framework.BundleContext,long)>
<org.eclipse.osgi.framework.adaptor.core.StateManager: void readSystemState(java.io.File,java.io.File,long)>
<org.eclipse.osgi.framework.adaptor.core.StateManager: void setInstaller(org.eclipse.osgi.framework.adaptor.core.BundleInstaller)>
<org.eclipse.osgi.framework.debug.Debug: void <clinit>()>
<org.eclipse.osgi.framework.debug.FrameworkDebugOptions: boolean isDebugEnabled()>
<org.eclipse.osgi.framework.debug.FrameworkDebugOptions: org.eclipse.osgi.framework.debug.FrameworkDebugOptions getDefault()>
<org.eclipse.osgi.framework.debug.FrameworkDebugOptions: void <clinit>()>
<org.eclipse.osgi.framework.debug.FrameworkDebugOptions: void <init>()>
<org.eclipse.osgi.framework.debug.FrameworkDebugOptions: void loadOptions()>
<org.eclipse.osgi.framework.eventmgr.EventListeners$ListElement: void <init>(java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.EventListeners: org.eclipse.osgi.framework.eventmgr.EventListeners$ListElement[] getListeners()>
<org.eclipse.osgi.framework.eventmgr.EventListeners: void <clinit>()>
<org.eclipse.osgi.framework.eventmgr.EventListeners: void <init>()>
<org.eclipse.osgi.framework.eventmgr.EventListeners: void <init>(int)>
<org.eclipse.osgi.framework.eventmgr.EventListeners: void addListener(java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.EventListeners: void copyList(int)>
<org.eclipse.osgi.framework.eventmgr.EventListeners: void removeListener(java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.EventManager$EventThread$Queued: void <init>(org.eclipse.osgi.framework.eventmgr.EventListeners$ListElement[],org.eclipse.osgi.framework.eventmgr.EventDispatcher,int,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.EventManager$EventThread: org.eclipse.osgi.framework.eventmgr.EventManager$EventThread$Queued getNextEvent()>
<org.eclipse.osgi.framework.eventmgr.EventManager$EventThread: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.eventmgr.EventManager$EventThread: void init()>
<org.eclipse.osgi.framework.eventmgr.EventManager$EventThread: void postEvent(org.eclipse.osgi.framework.eventmgr.EventListeners$ListElement[],org.eclipse.osgi.framework.eventmgr.EventDispatcher,int,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.EventManager$EventThread: void run()>
<org.eclipse.osgi.framework.eventmgr.EventManager: org.eclipse.osgi.framework.eventmgr.EventManager$EventThread getEventThread()>
<org.eclipse.osgi.framework.eventmgr.EventManager: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.eventmgr.EventManager: void dispatchEvent(org.eclipse.osgi.framework.eventmgr.EventListeners$ListElement[],org.eclipse.osgi.framework.eventmgr.EventDispatcher,int,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.ListenerQueue: void <init>(org.eclipse.osgi.framework.eventmgr.EventManager)>
<org.eclipse.osgi.framework.eventmgr.ListenerQueue: void dispatchEventAsynchronous(int,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.ListenerQueue: void dispatchEventSynchronous(int,java.lang.Object)>
<org.eclipse.osgi.framework.eventmgr.ListenerQueue: void queueListeners(org.eclipse.osgi.framework.eventmgr.EventListeners,org.eclipse.osgi.framework.eventmgr.EventDispatcher)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle$1: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle$1: void <init>(org.eclipse.osgi.framework.internal.core.AbstractBundle,int,boolean)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: boolean compare(org.eclipse.osgi.framework.internal.core.KeyedElement)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: boolean isActive()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: boolean isFragment()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: boolean isResolved()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: boolean testStateChanging(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: int compareTo(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: int getKeyHashCode()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: int getStartLevel()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: int getState()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.lang.Class loadClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.lang.Object getKey()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.lang.String getLocation()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.lang.String getSymbolicName()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.lang.Thread getStateChanging()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.net.URL getEntry(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.util.Dictionary getHeaders()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.util.Dictionary getHeaders(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: java.util.ResourceBundle getResourceBundle(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: long getBundleId()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: org.eclipse.osgi.framework.adaptor.BundleData getBundleData()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: org.eclipse.osgi.framework.adaptor.BundleProtectionDomain getProtectionDomain()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: org.eclipse.osgi.framework.internal.core.AbstractBundle createBundle(org.eclipse.osgi.framework.adaptor.BundleData,org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: org.eclipse.osgi.service.resolver.BundleDescription getBundleDescription()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: org.osgi.framework.BundleActivator loadBundleActivator()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: org.osgi.framework.Version getVersion()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void <init>(org.eclipse.osgi.framework.adaptor.BundleData,org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void beginStateChange()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void checkValid()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void completeStateChange()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void initializeManifestLocalization()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void resolve()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void resume()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void setStatus(int,boolean)>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void start()>
<org.eclipse.osgi.framework.internal.core.AbstractBundle: void unresolvePermissions(org.eclipse.osgi.framework.internal.core.AbstractBundle[])>
<org.eclipse.osgi.framework.internal.core.AliasMapper: java.lang.Object aliasOSName(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.AliasMapper: java.util.Hashtable initAliases(java.io.InputStream)>
<org.eclipse.osgi.framework.internal.core.AliasMapper: void <init>()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl$1: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl$1: void <init>(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl$2: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl$2: void <init>(org.eclipse.osgi.framework.internal.core.BundleContextImpl,org.osgi.framework.BundleActivator)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: boolean hasListenServicePermission(org.osgi.framework.ServiceEvent)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: boolean isAssignableTo(org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: boolean isValid()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: boolean ungetService(org.osgi.framework.ServiceReference)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: java.lang.Object getService(org.osgi.framework.ServiceReference)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: java.lang.String checkServiceClass(java.lang.String[],java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl createServiceRegistration(java.lang.String[],java.lang.Object,java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.Bundle getBundle()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.Bundle getBundle(long)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.Bundle installBundle(java.lang.String,java.io.InputStream)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.Bundle[] getBundles()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.Filter createFilter(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.ServiceReference getServiceReference(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.ServiceReference[] getServiceReferences(java.lang.String,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.ServiceRegistration registerService(java.lang.String,java.lang.Object,java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: org.osgi.framework.ServiceRegistration registerService(java.lang.String[],java.lang.Object,java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void <init>(org.eclipse.osgi.framework.internal.core.BundleHost)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void addBundleListener(org.osgi.framework.BundleListener)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void addFrameworkListener(org.osgi.framework.FrameworkListener)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void addServiceListener(org.osgi.framework.ServiceListener,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void checkValid()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void dispatchEvent(java.lang.Object,java.lang.Object,int,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void removeFrameworkListener(org.osgi.framework.FrameworkListener)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void removeServiceListener(org.osgi.framework.ServiceListener)>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void start()>
<org.eclipse.osgi.framework.internal.core.BundleContextImpl: void startActivator(org.osgi.framework.BundleActivator)>
<org.eclipse.osgi.framework.internal.core.BundleHost: java.lang.Class loadClass(java.lang.String,boolean)>
<org.eclipse.osgi.framework.internal.core.BundleHost: org.eclipse.osgi.framework.internal.core.BundleContextImpl createContext()>
<org.eclipse.osgi.framework.internal.core.BundleHost: org.eclipse.osgi.framework.internal.core.BundleContextImpl getContext()>
<org.eclipse.osgi.framework.internal.core.BundleHost: org.eclipse.osgi.framework.internal.core.BundleLoader checkLoader()>
<org.eclipse.osgi.framework.internal.core.BundleHost: org.eclipse.osgi.framework.internal.core.BundleLoader getBundleLoader()>
<org.eclipse.osgi.framework.internal.core.BundleHost: org.eclipse.osgi.framework.internal.core.BundleLoaderProxy getLoaderProxy()>
<org.eclipse.osgi.framework.internal.core.BundleHost: org.osgi.framework.Bundle[] getFragments()>
<org.eclipse.osgi.framework.internal.core.BundleHost: void <init>(org.eclipse.osgi.framework.adaptor.BundleData,org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.BundleHost: void load()>
<org.eclipse.osgi.framework.internal.core.BundleHost: void refresh()>
<org.eclipse.osgi.framework.internal.core.BundleHost: void startWorker(boolean)>
<org.eclipse.osgi.framework.internal.core.BundleLoader$1: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.BundleLoader$1: void <init>()>
<org.eclipse.osgi.framework.internal.core.BundleLoader$ClassContext: void <init>()>
<org.eclipse.osgi.framework.internal.core.BundleLoader: boolean findParentResource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: boolean isBootDelegationPackage(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: boolean isDynamicallyImported(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: boolean isExportedPackage(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.Class findClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.Class findClass(java.lang.String,boolean)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.Class findLocalClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.Class loadClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.ClassLoader getClassLoader(java.lang.Class)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.ClassLoader getParentPrivileged(org.eclipse.osgi.framework.adaptor.BundleClassLoader)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.String findLibrary(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.String findLocalLibrary(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.String getPackageName(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.lang.String getResourcePackageName(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.net.URL findLocalResource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.net.URL findResource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: java.net.URL findResource(java.lang.String,boolean)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.adaptor.BundleClassLoader createBCL(org.eclipse.osgi.framework.adaptor.BundleProtectionDomain,java.lang.String[])>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.adaptor.BundleClassLoader createBCLPrevileged(org.eclipse.osgi.framework.adaptor.BundleProtectionDomain,java.lang.String[])>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.adaptor.BundleClassLoader createClassLoader()>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.BundleLoaderProxy getLoaderProxy(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.PackageSource createMultiSource(java.lang.String,org.eclipse.osgi.framework.internal.core.PackageSource[])>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.PackageSource findDynamicSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.PackageSource findImportedSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.PackageSource findRequiredSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.PackageSource findSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: org.eclipse.osgi.framework.internal.core.PackageSource getPackageSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.BundleLoader: void <init>(org.eclipse.osgi.framework.internal.core.BundleHost,org.eclipse.osgi.framework.internal.core.BundleLoaderProxy)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: void addExportedProvidersFor(java.lang.String,java.lang.String,java.util.ArrayList,org.eclipse.osgi.framework.internal.core.KeyedHashSet)>
<org.eclipse.osgi.framework.internal.core.BundleLoader: void addImportedPackages(org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.framework.internal.core.BundleLoader: void initialize(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.framework.internal.core.BundleLoaderProxy: java.lang.String getSymbolicName()>
<org.eclipse.osgi.framework.internal.core.BundleLoaderProxy: org.eclipse.osgi.framework.internal.core.BundleLoader getBundleLoader()>
<org.eclipse.osgi.framework.internal.core.BundleLoaderProxy: org.eclipse.osgi.framework.internal.core.PackageSource createPackageSource(org.eclipse.osgi.service.resolver.ExportPackageDescription,boolean)>
<org.eclipse.osgi.framework.internal.core.BundleLoaderProxy: org.eclipse.osgi.framework.internal.core.PackageSource getPackageSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleLoaderProxy: org.eclipse.osgi.service.resolver.BundleDescription getBundleDescription()>
<org.eclipse.osgi.framework.internal.core.BundleLoaderProxy: void <init>(org.eclipse.osgi.framework.internal.core.BundleHost,org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.framework.internal.core.BundleRepository: java.util.List getBundles()>
<org.eclipse.osgi.framework.internal.core.BundleRepository: org.eclipse.osgi.framework.internal.core.AbstractBundle getBundle(java.lang.String,org.osgi.framework.Version)>
<org.eclipse.osgi.framework.internal.core.BundleRepository: org.eclipse.osgi.framework.internal.core.AbstractBundle getBundle(long)>
<org.eclipse.osgi.framework.internal.core.BundleRepository: org.eclipse.osgi.framework.internal.core.AbstractBundle[] getBundles(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.BundleRepository: void <init>(int,org.eclipse.osgi.framework.internal.core.PackageAdminImpl)>
<org.eclipse.osgi.framework.internal.core.BundleRepository: void add(org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.BundleResourceHandler: java.net.URLConnection openConnection(java.net.URL)>
<org.eclipse.osgi.framework.internal.core.BundleResourceHandler: void <init>(org.eclipse.osgi.framework.adaptor.core.BundleEntry)>
<org.eclipse.osgi.framework.internal.core.BundleResourceHandler: void checkAdminPermission(org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.internal.core.BundleResourceHandler: void parseURL(java.net.URL,java.lang.String,int,int)>
<org.eclipse.osgi.framework.internal.core.BundleResourceHandler: void setContext(org.osgi.framework.BundleContext)>
<org.eclipse.osgi.framework.internal.core.BundleSource: java.io.InputStream getInputStream()>
<org.eclipse.osgi.framework.internal.core.BundleSource: void <init>(java.io.InputStream)>
<org.eclipse.osgi.framework.internal.core.BundleURLConnection: java.io.InputStream getInputStream()>
<org.eclipse.osgi.framework.internal.core.BundleURLConnection: java.net.URL getFileURL()>
<org.eclipse.osgi.framework.internal.core.BundleURLConnection: void <init>(java.net.URL,org.eclipse.osgi.framework.adaptor.core.BundleEntry)>
<org.eclipse.osgi.framework.internal.core.BundleURLConnection: void connect()>
<org.eclipse.osgi.framework.internal.core.Constants: java.lang.String getInternalSymbolicName()>
<org.eclipse.osgi.framework.internal.core.Constants: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.Constants: void setInternalSymbolicName(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: java.lang.Object parse_substring()>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: java.lang.String parse_attr()>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void parse(org.eclipse.osgi.framework.internal.core.FilterImpl)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void parse_and(org.eclipse.osgi.framework.internal.core.FilterImpl)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void parse_filter(org.eclipse.osgi.framework.internal.core.FilterImpl)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void parse_filtercomp(org.eclipse.osgi.framework.internal.core.FilterImpl)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void parse_item(org.eclipse.osgi.framework.internal.core.FilterImpl)>
<org.eclipse.osgi.framework.internal.core.FilterImpl$Parser: void skipWhiteSpace()>
<org.eclipse.osgi.framework.internal.core.FilterImpl: boolean compare(int,java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: boolean compare_ObjectArray(int,java.lang.Object[],java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: boolean compare_String(int,java.lang.String,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: boolean match(org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: boolean match(org.osgi.framework.ServiceReference)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: boolean match0(java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: java.lang.String encodeValue(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: java.lang.String toString()>
<org.eclipse.osgi.framework.internal.core.FilterImpl: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.FilterImpl: void <init>()>
<org.eclipse.osgi.framework.internal.core.FilterImpl: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.FilterImpl: void setFilter(int,java.lang.String,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.FilteredServiceListener: void <init>(java.lang.String,org.osgi.framework.ServiceListener,org.eclipse.osgi.framework.internal.core.BundleContextImpl)>
<org.eclipse.osgi.framework.internal.core.FilteredServiceListener: void serviceChanged(org.osgi.framework.ServiceEvent)>
<org.eclipse.osgi.framework.internal.core.Framework$2: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.Framework$2: void <init>(org.eclipse.osgi.framework.internal.core.Framework,java.io.InputStream,java.lang.String,java.security.AccessControlContext)>
<org.eclipse.osgi.framework.internal.core.Framework$4: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.Framework$4: void <init>(org.eclipse.osgi.framework.internal.core.Framework,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: boolean isActive()>
<org.eclipse.osgi.framework.internal.core.Framework: boolean verifyExecutionEnvironment(java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.Framework: java.io.InputStream findVMProfile()>
<org.eclipse.osgi.framework.internal.core.Framework: java.lang.Object setProperty(java.lang.String,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: java.lang.String getProperty(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: java.lang.String[] selectNativeCode(org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.internal.core.Framework: long getNextServiceId()>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle createAndVerifyBundle(org.eclipse.osgi.framework.adaptor.BundleData)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle getBundle(long)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle getBundleByLocation(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle getBundleBySymbolicName(java.lang.String,org.osgi.framework.Version)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle installBundle(java.lang.String,java.io.InputStream)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle installWorker(java.lang.String,java.security.PrivilegedExceptionAction)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle installWorkerPrivileged(java.lang.String,java.net.URLConnection,java.security.AccessControlContext)>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle[] getAllBundles()>
<org.eclipse.osgi.framework.internal.core.Framework: org.eclipse.osgi.framework.internal.core.AbstractBundle[] getBundleBySymbolicName(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: org.osgi.framework.ServiceReference[] getServiceReferences(java.lang.String,java.lang.String,org.eclipse.osgi.framework.internal.core.BundleContextImpl,boolean)>
<org.eclipse.osgi.framework.internal.core.Framework: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.Framework: void <init>(org.eclipse.osgi.framework.adaptor.FrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.core.Framework: void checkAdminPermission(org.osgi.framework.Bundle,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: void checkGetServicePermission(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Framework: void checkGetServicePermission(java.lang.String[])>
<org.eclipse.osgi.framework.internal.core.Framework: void checkRegisterServicePermission(java.lang.String[])>
<org.eclipse.osgi.framework.internal.core.Framework: void createSystemBundle()>
<org.eclipse.osgi.framework.internal.core.Framework: void dispatchEvent(java.lang.Object,java.lang.Object,int,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.Framework: void initialize(org.eclipse.osgi.framework.adaptor.FrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.core.Framework: void initializeProperties(java.util.Properties)>
<org.eclipse.osgi.framework.internal.core.Framework: void installSecurityManager()>
<org.eclipse.osgi.framework.internal.core.Framework: void launch()>
<org.eclipse.osgi.framework.internal.core.Framework: void loadVMProfile()>
<org.eclipse.osgi.framework.internal.core.Framework: void publishBundleEvent(int,org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.internal.core.Framework: void publishBundleEventPrivileged(org.osgi.framework.BundleEvent)>
<org.eclipse.osgi.framework.internal.core.Framework: void publishFrameworkEvent(int,org.osgi.framework.Bundle,java.lang.Throwable)>
<org.eclipse.osgi.framework.internal.core.Framework: void publishFrameworkEventPrivileged(org.osgi.framework.FrameworkEvent)>
<org.eclipse.osgi.framework.internal.core.Framework: void publishServiceEvent(int,org.osgi.framework.ServiceReference)>
<org.eclipse.osgi.framework.internal.core.Framework: void publishServiceEventPrivileged(org.osgi.framework.ServiceEvent)>
<org.eclipse.osgi.framework.internal.core.Framework: void resumeBundle(org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.Framework: void setBootDelegation()>
<org.eclipse.osgi.framework.internal.core.Framework: void setExecutionEnvironment()>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: boolean add(org.eclipse.osgi.framework.internal.core.KeyedElement)>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: boolean shouldGrow()>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: int hash(org.eclipse.osgi.framework.internal.core.KeyedElement)>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: int keyHash(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: int size()>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: java.lang.Object[] elements(java.lang.Object[])>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: org.eclipse.osgi.framework.internal.core.KeyedElement getByKey(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: void <init>()>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: void <init>(boolean)>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: void <init>(int,boolean)>
<org.eclipse.osgi.framework.internal.core.KeyedHashSet: void expand()>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization$EmptyResouceBundle: boolean isEmpty()>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization$EmptyResouceBundle: java.lang.Object handleGetObject(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization$EmptyResouceBundle: void <init>(org.eclipse.osgi.framework.internal.core.ManifestLocalization)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization$EmptyResouceBundle: void setParent(java.util.ResourceBundle)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization$LocalizationResourceBundle: boolean isEmpty()>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization$LocalizationResourceBundle: void <init>(org.eclipse.osgi.framework.internal.core.ManifestLocalization,java.io.InputStream)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.lang.String[] buildNLVariants(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.net.URL findInBundle(java.lang.String,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.net.URL findInFragments(java.lang.String,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.net.URL findInResolved(java.lang.String,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.net.URL findResource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.util.Dictionary getHeaders(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: java.util.ResourceBundle getResourceBundle(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ManifestLocalization: void <init>(org.eclipse.osgi.framework.internal.core.AbstractBundle,java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle$MessagesProperties: java.lang.Object put(java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle$MessagesProperties: void <init>(java.util.Map,java.lang.String,boolean)>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle: java.lang.String[] buildVariants(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle: void computeMissingMessages(java.lang.String,java.lang.Class,java.util.Map,java.lang.reflect.Field[],boolean)>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle: void load(java.lang.String,java.lang.Class)>
<org.eclipse.osgi.framework.internal.core.MessageResourceBundle: void setAdaptor(org.eclipse.osgi.framework.adaptor.FrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.core.Msg: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.MultiSourcePackage: java.lang.Class loadClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.MultiSourcePackage: void <init>(java.lang.String,org.eclipse.osgi.framework.internal.core.SingleSourcePackage[])>
<org.eclipse.osgi.framework.internal.core.NullPackageSource: boolean isNullSource()>
<org.eclipse.osgi.framework.internal.core.NullPackageSource: org.eclipse.osgi.framework.internal.core.NullPackageSource getNullPackageSource(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.NullPackageSource: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.OSGi: org.eclipse.osgi.framework.internal.core.Framework createFramework(org.eclipse.osgi.framework.adaptor.FrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.core.OSGi: org.osgi.framework.BundleContext getBundleContext()>
<org.eclipse.osgi.framework.internal.core.OSGi: void <init>(org.eclipse.osgi.framework.adaptor.FrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.core.OSGi: void launch()>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl$1: void <init>(org.eclipse.osgi.framework.internal.core.PackageAdminImpl,org.eclipse.osgi.framework.internal.core.AbstractBundle[])>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl$1: void run()>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: int getBundleType(org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.eclipse.osgi.framework.internal.core.AbstractBundle setResolved(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.eclipse.osgi.framework.internal.core.AbstractBundle[] applyDeltas(org.eclipse.osgi.service.resolver.BundleDelta[])>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.eclipse.osgi.framework.internal.core.AbstractBundle[] processDelta(org.eclipse.osgi.service.resolver.BundleDelta[],boolean)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.osgi.framework.Bundle getBundle(java.lang.Class)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.osgi.framework.Bundle getBundlePriv(java.lang.Class)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.osgi.framework.Bundle[] getBundles(java.lang.String,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: org.osgi.framework.Bundle[] getFragments(org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void <init>(org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void checkSystemBundle(org.eclipse.osgi.framework.internal.core.SystemBundle)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void doResolveBundles(org.eclipse.osgi.framework.internal.core.AbstractBundle[],boolean)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void refreshPackages(org.osgi.framework.Bundle[])>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void resumeBundles(org.eclipse.osgi.framework.internal.core.AbstractBundle[])>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void setFrameworkVersion(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void setResolvedBundles(org.eclipse.osgi.framework.internal.core.SystemBundle)>
<org.eclipse.osgi.framework.internal.core.PackageAdminImpl: void suspendBundle(org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.PackageSource: boolean compare(org.eclipse.osgi.framework.internal.core.KeyedElement)>
<org.eclipse.osgi.framework.internal.core.PackageSource: boolean hasCommonSource(org.eclipse.osgi.framework.internal.core.PackageSource)>
<org.eclipse.osgi.framework.internal.core.PackageSource: boolean isFriend(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.PackageSource: boolean isNullSource()>
<org.eclipse.osgi.framework.internal.core.PackageSource: int getKeyHashCode()>
<org.eclipse.osgi.framework.internal.core.PackageSource: java.lang.Object getKey()>
<org.eclipse.osgi.framework.internal.core.PackageSource: java.lang.String getId()>
<org.eclipse.osgi.framework.internal.core.PackageSource: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ReferenceInputStream: java.net.URL getReference()>
<org.eclipse.osgi.framework.internal.core.ReferenceInputStream: void <init>(java.net.URL)>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: boolean equals(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: boolean isAssignableTo(org.osgi.framework.Bundle,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: int getRanking()>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: int hashCode()>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: java.lang.Object getProperty(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: java.lang.String[] getClasses()>
<org.eclipse.osgi.framework.internal.core.ServiceReferenceImpl: void <init>(org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl$Properties: java.lang.Object cloneValue(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl$Properties: java.lang.Object getProperty(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl$Properties: java.lang.Object setProperty(java.lang.String,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl$Properties: void <init>(int,java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl$Properties: void <init>(java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl: boolean ungetService(org.eclipse.osgi.framework.internal.core.BundleContextImpl)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl: java.lang.Object getProperty(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl: java.lang.Object getService(org.eclipse.osgi.framework.internal.core.BundleContextImpl)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl: org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl$Properties createProperties(java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl: org.osgi.framework.ServiceReference getReference()>
<org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl: void <init>(org.eclipse.osgi.framework.internal.core.BundleContextImpl,java.lang.String[],java.lang.Object,java.util.Dictionary)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistryImpl: org.osgi.framework.ServiceReference[] lookupServiceReferences(java.lang.String,org.osgi.framework.Filter)>
<org.eclipse.osgi.framework.internal.core.ServiceRegistryImpl: void <init>()>
<org.eclipse.osgi.framework.internal.core.ServiceRegistryImpl: void initialize()>
<org.eclipse.osgi.framework.internal.core.ServiceRegistryImpl: void publishService(org.osgi.framework.BundleContext,org.osgi.framework.ServiceRegistration)>
<org.eclipse.osgi.framework.internal.core.ServiceUse$1: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.ServiceUse$1: void <init>(org.eclipse.osgi.framework.internal.core.ServiceUse)>
<org.eclipse.osgi.framework.internal.core.ServiceUse$2: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.ServiceUse$2: void <init>(org.eclipse.osgi.framework.internal.core.ServiceUse)>
<org.eclipse.osgi.framework.internal.core.ServiceUse: boolean ungetService()>
<org.eclipse.osgi.framework.internal.core.ServiceUse: java.lang.Object getService()>
<org.eclipse.osgi.framework.internal.core.ServiceUse: void <init>(org.eclipse.osgi.framework.internal.core.BundleContextImpl,org.eclipse.osgi.framework.internal.core.ServiceRegistrationImpl)>
<org.eclipse.osgi.framework.internal.core.SingleSourcePackage: boolean equals(java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.SingleSourcePackage: java.lang.Class loadClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.SingleSourcePackage: org.eclipse.osgi.framework.internal.core.SingleSourcePackage[] getSuppliers()>
<org.eclipse.osgi.framework.internal.core.SingleSourcePackage: void <init>(java.lang.String,int,org.eclipse.osgi.framework.internal.core.BundleLoaderProxy)>
<org.eclipse.osgi.framework.internal.core.StartLevelEvent: int getNewSL()>
<org.eclipse.osgi.framework.internal.core.StartLevelEvent: int getType()>
<org.eclipse.osgi.framework.internal.core.StartLevelEvent: org.eclipse.osgi.framework.internal.core.AbstractBundle getBundle()>
<org.eclipse.osgi.framework.internal.core.StartLevelEvent: void <init>(int,int,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.StartLevelImpl: int getStartLevel()>
<org.eclipse.osgi.framework.internal.core.StartLevelImpl: void <init>(org.osgi.framework.Bundle,org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.StartLevelImpl: void setBundleStartLevel(org.osgi.framework.Bundle,int)>
<org.eclipse.osgi.framework.internal.core.StartLevelImpl: void setStartLevel(int)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager$1: java.lang.Object run()>
<org.eclipse.osgi.framework.internal.core.StartLevelManager$1: void <init>(org.eclipse.osgi.framework.internal.core.StartLevelManager,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: int getFrameworkStartLevel()>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: int getStartLevel()>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: java.lang.Object getService(org.osgi.framework.Bundle,org.osgi.framework.ServiceRegistration)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: org.eclipse.osgi.framework.internal.core.AbstractBundle[] getInstalledBundles(org.eclipse.osgi.framework.internal.core.BundleRepository)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void <clinit>()>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void <init>(org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void dispatchEvent(java.lang.Object,java.lang.Object,int,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void doSetStartLevel(int,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void incFWSL(int,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void initialize()>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void issueEvent(org.eclipse.osgi.framework.internal.core.StartLevelEvent)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void launch(int)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void loadInstalledBundles(org.eclipse.osgi.framework.internal.core.AbstractBundle[])>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void resumeBundles(org.eclipse.osgi.framework.internal.core.AbstractBundle[],boolean)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void saveActiveStartLevel(int)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void setBundleSL(org.eclipse.osgi.framework.internal.core.StartLevelEvent)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void setBundleStartLevel(org.osgi.framework.Bundle,int)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void setStartLevel(int,org.osgi.framework.Bundle)>
<org.eclipse.osgi.framework.internal.core.StartLevelManager: void ungetService(org.osgi.framework.Bundle,org.osgi.framework.ServiceRegistration,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.SystemBundle: java.lang.Class loadClass(java.lang.String,boolean)>
<org.eclipse.osgi.framework.internal.core.SystemBundle: java.lang.String getSymbolicName()>
<org.eclipse.osgi.framework.internal.core.SystemBundle: void <init>(org.eclipse.osgi.framework.internal.core.Framework)>
<org.eclipse.osgi.framework.internal.core.SystemBundle: void load()>
<org.eclipse.osgi.framework.internal.core.SystemBundle: void resume()>
<org.eclipse.osgi.framework.internal.core.SystemBundle: void unresolvePermissions(org.eclipse.osgi.framework.internal.core.AbstractBundle[])>
<org.eclipse.osgi.framework.internal.core.SystemBundleActivator: org.osgi.framework.ServiceRegistration register(java.lang.String,java.lang.Object)>
<org.eclipse.osgi.framework.internal.core.SystemBundleActivator: void <init>()>
<org.eclipse.osgi.framework.internal.core.SystemBundleActivator: void start(org.osgi.framework.BundleContext)>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: int getStartLevel()>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: java.io.File getOsgiBase()>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: org.eclipse.osgi.framework.util.Headers createManifest(java.io.File)>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: void <init>(org.eclipse.osgi.framework.adaptor.core.AbstractFrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: void appendManifestValue(org.eclipse.osgi.framework.util.Headers,java.lang.String,java.lang.String)>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: void createBundleFile(java.io.File)>
<org.eclipse.osgi.framework.internal.core.SystemBundleData: void setMetaData()>
<org.eclipse.osgi.framework.internal.core.SystemBundleLoader: java.lang.Class findLocalClass(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.SystemBundleLoader: void <init>(org.eclipse.osgi.framework.internal.core.BundleHost,org.eclipse.osgi.framework.internal.core.BundleLoaderProxy)>
<org.eclipse.osgi.framework.internal.core.Tokenizer: char getChar()>
<org.eclipse.osgi.framework.internal.core.Tokenizer: java.lang.String getString(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Tokenizer: java.lang.String getToken(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Tokenizer: void <init>(java.lang.String)>
<org.eclipse.osgi.framework.internal.core.Tokenizer: void skipWhiteSpace()>
<org.eclipse.osgi.framework.internal.core.Util: void sort(java.lang.Object[],int,int)>
<org.eclipse.osgi.framework.internal.protocol.ContentHandlerFactory: void <init>(org.osgi.framework.BundleContext)>
<org.eclipse.osgi.framework.internal.protocol.StreamHandlerFactory: java.net.URLStreamHandler createURLStreamHandler(java.lang.String)>
<org.eclipse.osgi.framework.internal.protocol.StreamHandlerFactory: void <clinit>()>
<org.eclipse.osgi.framework.internal.protocol.StreamHandlerFactory: void <init>(org.osgi.framework.BundleContext,org.eclipse.osgi.framework.adaptor.FrameworkAdaptor)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: int getRank(org.osgi.framework.ServiceReference)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: java.lang.Object addingService(org.osgi.framework.ServiceReference)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: java.lang.String toExternalForm(java.net.URL)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: java.net.URLConnection openConnection(java.net.URL)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: void <init>(java.lang.String,org.osgi.framework.ServiceReference,org.osgi.framework.BundleContext)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: void parseURL(java.net.URL,java.lang.String,int,int)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: void setNewHandler(org.osgi.framework.ServiceReference,int)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerSetter: void <init>(org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerProxy)>
<org.eclipse.osgi.framework.internal.protocol.URLStreamHandlerSetter: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.osgi.framework.internal.protocol.bundleentry.Handler: org.eclipse.osgi.framework.adaptor.core.BundleEntry findBundleEntry(java.net.URL,org.eclipse.osgi.framework.internal.core.AbstractBundle)>
<org.eclipse.osgi.framework.internal.protocol.bundleentry.Handler: void <init>(org.eclipse.osgi.framework.adaptor.core.BundleEntry)>
<org.eclipse.osgi.framework.internal.protocol.bundleresource.Handler: void <init>(org.eclipse.osgi.framework.adaptor.core.BundleEntry)>
<org.eclipse.osgi.framework.internal.protocol.reference.Handler: java.net.URLConnection openConnection(java.net.URL)>
<org.eclipse.osgi.framework.internal.protocol.reference.Handler: void <init>()>
<org.eclipse.osgi.framework.internal.protocol.reference.Handler: void parseURL(java.net.URL,java.lang.String,int,int)>
<org.eclipse.osgi.framework.internal.protocol.reference.ReferenceURLConnection: java.io.File makeAbsolute(java.lang.String,java.io.File)>
<org.eclipse.osgi.framework.internal.protocol.reference.ReferenceURLConnection: java.io.InputStream getInputStream()>
<org.eclipse.osgi.framework.internal.protocol.reference.ReferenceURLConnection: java.lang.String getInstallPath()>
<org.eclipse.osgi.framework.internal.protocol.reference.ReferenceURLConnection: void <init>(java.net.URL)>
<org.eclipse.osgi.framework.internal.protocol.reference.ReferenceURLConnection: void connect()>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile$CacheInfo: void <init>(org.eclipse.osgi.framework.internal.reliablefile.ReliableFile,int,java.util.zip.Checksum,long)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: byte[] intToHex(int)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: int lastModifiedVersion(java.io.File)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: int[] getFileGenerations(java.io.File)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: java.io.File getOutputFile()>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: java.io.OutputStream getOutputStream(boolean,int)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: java.util.zip.Checksum getChecksumCalculator()>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: org.eclipse.osgi.framework.internal.reliablefile.ReliableFile getReliableFile(java.io.File)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: void <clinit>()>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: void <init>(java.io.File)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: void cleanup(int[],boolean)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: void closeOutputFile(java.util.zip.Checksum)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: void mv(java.io.File,java.io.File)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFile: void writeChecksumSignature(java.io.OutputStream,java.util.zip.Checksum)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFileOutputStream: java.io.File closeIntermediateFile()>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFileOutputStream: void <init>(java.io.File)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFileOutputStream: void <init>(org.eclipse.osgi.framework.internal.reliablefile.ReliableFile,boolean)>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFileOutputStream: void close()>
<org.eclipse.osgi.framework.internal.reliablefile.ReliableFileOutputStream: void write(byte[],int,int)>
<org.eclipse.osgi.framework.log.FrameworkLogEntry: int getStackCode()>
<org.eclipse.osgi.framework.log.FrameworkLogEntry: java.lang.String getEntry()>
<org.eclipse.osgi.framework.log.FrameworkLogEntry: java.lang.String getMessage()>
<org.eclipse.osgi.framework.log.FrameworkLogEntry: java.lang.Throwable getThrowable()>
<org.eclipse.osgi.framework.log.FrameworkLogEntry: org.eclipse.osgi.framework.log.FrameworkLogEntry[] getChildren()>
<org.eclipse.osgi.framework.log.FrameworkLogEntry: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable,org.eclipse.osgi.framework.log.FrameworkLogEntry[])>
<org.eclipse.osgi.framework.util.Headers$ArrayEnumeration: boolean hasMoreElements()>
<org.eclipse.osgi.framework.util.Headers$ArrayEnumeration: java.lang.Object nextElement()>
<org.eclipse.osgi.framework.util.Headers$ArrayEnumeration: void <init>(org.eclipse.osgi.framework.util.Headers,java.lang.Object[],int)>
<org.eclipse.osgi.framework.util.Headers: int getIndex(java.lang.Object)>
<org.eclipse.osgi.framework.util.Headers: int size()>
<org.eclipse.osgi.framework.util.Headers: java.lang.Object get(java.lang.Object)>
<org.eclipse.osgi.framework.util.Headers: java.lang.Object remove(int)>
<org.eclipse.osgi.framework.util.Headers: java.lang.Object set(java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.framework.util.Headers: java.util.Enumeration keys()>
<org.eclipse.osgi.framework.util.Headers: org.eclipse.osgi.framework.util.Headers parseManifest(java.io.InputStream)>
<org.eclipse.osgi.framework.util.Headers: void <init>(int)>
<org.eclipse.osgi.framework.util.Headers: void add(java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.framework.util.SecureAction: boolean exists(java.io.File)>
<org.eclipse.osgi.framework.util.SecureAction: boolean isDirectory(java.io.File)>
<org.eclipse.osgi.framework.util.SecureAction: java.io.FileInputStream getFileInputStream(java.io.File)>
<org.eclipse.osgi.framework.util.SecureAction: java.io.FileOutputStream getFileOutputStream(java.io.File,boolean)>
<org.eclipse.osgi.framework.util.SecureAction: java.lang.Class forName(java.lang.String)>
<org.eclipse.osgi.framework.util.SecureAction: java.lang.Object getService(org.osgi.framework.ServiceReference,org.osgi.framework.BundleContext)>
<org.eclipse.osgi.framework.util.SecureAction: java.lang.String getProperty(java.lang.String)>
<org.eclipse.osgi.framework.util.SecureAction: java.lang.Thread createThread(java.lang.Runnable,java.lang.String)>
<org.eclipse.osgi.framework.util.SecureAction: java.net.URL getURL(java.lang.String,java.lang.String,int,java.lang.String,java.net.URLStreamHandler)>
<org.eclipse.osgi.framework.util.SecureAction: java.util.zip.ZipFile getZipFile(java.io.File)>
<org.eclipse.osgi.framework.util.SecureAction: long lastModified(java.io.File)>
<org.eclipse.osgi.framework.util.SecureAction: void <init>()>
<org.eclipse.osgi.framework.util.SecureAction: void open(org.osgi.util.tracker.ServiceTracker)>
<org.eclipse.osgi.internal.module.BundleConstraint: boolean isFromFragment()>
<org.eclipse.osgi.internal.module.BundleConstraint: boolean isOptional()>
<org.eclipse.osgi.internal.module.BundleConstraint: boolean isSatisfiedBy(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.BundleConstraint: org.eclipse.osgi.internal.module.ResolverBundle getBundle()>
<org.eclipse.osgi.internal.module.BundleConstraint: org.eclipse.osgi.internal.module.ResolverBundle getMatchingBundle()>
<org.eclipse.osgi.internal.module.BundleConstraint: org.eclipse.osgi.service.resolver.VersionConstraint getVersionConstraint()>
<org.eclipse.osgi.internal.module.BundleConstraint: void <init>(org.eclipse.osgi.internal.module.ResolverBundle,org.eclipse.osgi.service.resolver.VersionConstraint)>
<org.eclipse.osgi.internal.module.BundleConstraint: void setMatchingBundle(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.CyclicDependencyHashMap: java.util.ArrayList remove(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.CyclicDependencyHashMap: void <init>()>
<org.eclipse.osgi.internal.module.GroupingChecker: boolean checkRequiresConstraints(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.GroupingChecker: java.util.ArrayList getConstraints(org.eclipse.osgi.internal.module.ResolverExport)>
<org.eclipse.osgi.internal.module.GroupingChecker: void <init>()>
<org.eclipse.osgi.internal.module.GroupingChecker: void addInitialGroupingConstraints(org.eclipse.osgi.internal.module.ResolverBundle[])>
<org.eclipse.osgi.internal.module.GroupingChecker: void addReExportConstraints(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.GroupingChecker: void addRequireConstraints(org.eclipse.osgi.internal.module.ResolverExport[],org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.PermissionChecker: boolean checkBundlePermission(org.eclipse.osgi.service.resolver.VersionConstraint,org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.module.PermissionChecker: void <init>(org.osgi.framework.BundleContext,boolean)>
<org.eclipse.osgi.internal.module.ResolverBundle: boolean isDependentOnCycle()>
<org.eclipse.osgi.internal.module.ResolverBundle: boolean isFragment()>
<org.eclipse.osgi.internal.module.ResolverBundle: boolean isFullyWired()>
<org.eclipse.osgi.internal.module.ResolverBundle: boolean isResolvable()>
<org.eclipse.osgi.internal.module.ResolverBundle: int getState()>
<org.eclipse.osgi.internal.module.ResolverBundle: java.lang.String getName()>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.internal.module.BundleConstraint[] getRequires()>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.internal.module.ResolverExport[] getExportPackages()>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.internal.module.ResolverExport[] getSelectedExports()>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.internal.module.ResolverImpl getResolver()>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.internal.module.ResolverImport getImport(java.lang.String)>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.internal.module.ResolverImport[] getImportPackages()>
<org.eclipse.osgi.internal.module.ResolverBundle: org.eclipse.osgi.service.resolver.BundleDescription getBundle()>
<org.eclipse.osgi.internal.module.ResolverBundle: void <init>(org.eclipse.osgi.service.resolver.BundleDescription,org.eclipse.osgi.internal.module.ResolverImpl)>
<org.eclipse.osgi.internal.module.ResolverBundle: void clearWires()>
<org.eclipse.osgi.internal.module.ResolverBundle: void detachAllFragments()>
<org.eclipse.osgi.internal.module.ResolverBundle: void initialize(boolean)>
<org.eclipse.osgi.internal.module.ResolverBundle: void setResolvable(boolean)>
<org.eclipse.osgi.internal.module.ResolverBundle: void setState(int)>
<org.eclipse.osgi.internal.module.ResolverExport: java.lang.String getName()>
<org.eclipse.osgi.internal.module.ResolverExport: org.eclipse.osgi.internal.module.ResolverBundle getExporter()>
<org.eclipse.osgi.internal.module.ResolverExport: org.eclipse.osgi.service.resolver.BundleDescription getBundle()>
<org.eclipse.osgi.internal.module.ResolverExport: org.eclipse.osgi.service.resolver.ExportPackageDescription getExportPackageDescription()>
<org.eclipse.osgi.internal.module.ResolverExport: org.osgi.framework.Version getVersion()>
<org.eclipse.osgi.internal.module.ResolverExport: void <init>(org.eclipse.osgi.internal.module.ResolverBundle,org.eclipse.osgi.service.resolver.ExportPackageDescription)>
<org.eclipse.osgi.internal.module.ResolverImpl: boolean isResolvable(org.eclipse.osgi.service.resolver.BundleDescription,java.util.Dictionary[],java.util.ArrayList)>
<org.eclipse.osgi.internal.module.ResolverImpl: boolean resolveBundle(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.ResolverImpl: boolean resolveRequire(org.eclipse.osgi.internal.module.BundleConstraint)>
<org.eclipse.osgi.internal.module.ResolverImpl: boolean selectSingletons(org.eclipse.osgi.internal.module.ResolverBundle[],java.util.ArrayList)>
<org.eclipse.osgi.internal.module.ResolverImpl: org.eclipse.osgi.internal.module.PermissionChecker getPermissionChecker()>
<org.eclipse.osgi.internal.module.ResolverImpl: org.eclipse.osgi.service.resolver.BundleDescription[] getRemovalPending()>
<org.eclipse.osgi.internal.module.ResolverImpl: org.eclipse.osgi.service.resolver.BundleDescription[] getRemovalPending(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.module.ResolverImpl: void <clinit>()>
<org.eclipse.osgi.internal.module.ResolverImpl: void <init>(org.osgi.framework.BundleContext,boolean)>
<org.eclipse.osgi.internal.module.ResolverImpl: void attachFragment(org.eclipse.osgi.internal.module.ResolverBundle,java.util.ArrayList)>
<org.eclipse.osgi.internal.module.ResolverImpl: void bundleAdded(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.module.ResolverImpl: void flush()>
<org.eclipse.osgi.internal.module.ResolverImpl: void initResolverBundle(org.eclipse.osgi.service.resolver.BundleDescription,java.util.ArrayList,boolean)>
<org.eclipse.osgi.internal.module.ResolverImpl: void initialize()>
<org.eclipse.osgi.internal.module.ResolverImpl: void resolve(org.eclipse.osgi.service.resolver.BundleDescription[],java.util.Dictionary[])>
<org.eclipse.osgi.internal.module.ResolverImpl: void resolveBundles(org.eclipse.osgi.internal.module.ResolverBundle[],java.util.Dictionary[],java.util.ArrayList)>
<org.eclipse.osgi.internal.module.ResolverImpl: void resolveFragment(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.ResolverImpl: void rewireBundles()>
<org.eclipse.osgi.internal.module.ResolverImpl: void setBundleResolved(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.ResolverImpl: void setBundleResolving(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.ResolverImpl: void setBundleUnresolved(org.eclipse.osgi.internal.module.ResolverBundle,boolean)>
<org.eclipse.osgi.internal.module.ResolverImpl: void setDebugOptions()>
<org.eclipse.osgi.internal.module.ResolverImpl: void setState(org.eclipse.osgi.service.resolver.State)>
<org.eclipse.osgi.internal.module.ResolverImpl: void stateResolveBundle(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.ResolverImpl: void stateResolveBundles()>
<org.eclipse.osgi.internal.module.ResolverImpl: void stateResolveConstraints(org.eclipse.osgi.internal.module.ResolverBundle)>
<org.eclipse.osgi.internal.module.ResolverImpl: void unresolveBundle(org.eclipse.osgi.internal.module.ResolverBundle,boolean)>
<org.eclipse.osgi.internal.module.VersionHashMap: java.lang.Object put(org.eclipse.osgi.internal.module.VersionSupplier)>
<org.eclipse.osgi.internal.module.VersionHashMap: org.eclipse.osgi.internal.module.VersionSupplier[] add(int,org.eclipse.osgi.internal.module.VersionSupplier,org.eclipse.osgi.internal.module.VersionSupplier[])>
<org.eclipse.osgi.internal.module.VersionHashMap: org.eclipse.osgi.internal.module.VersionSupplier[] getArray(java.lang.String)>
<org.eclipse.osgi.internal.module.VersionHashMap: void <init>()>
<org.eclipse.osgi.internal.module.VersionHashMap: void put(org.eclipse.osgi.internal.module.VersionSupplier[])>
<org.eclipse.osgi.internal.module.VersionHashMap: void reorder()>
<org.eclipse.osgi.internal.profile.Profile: void <clinit>()>
<org.eclipse.osgi.internal.profile.Profile: void initProps()>
<org.eclipse.osgi.internal.resolver.BaseDescriptionImpl: java.lang.String getName()>
<org.eclipse.osgi.internal.resolver.BaseDescriptionImpl: org.osgi.framework.Version getVersion()>
<org.eclipse.osgi.internal.resolver.BaseDescriptionImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.BaseDescriptionImpl: void setName(java.lang.String)>
<org.eclipse.osgi.internal.resolver.BaseDescriptionImpl: void setVersion(org.osgi.framework.Version)>
<org.eclipse.osgi.internal.resolver.BundleDeltaImpl: int compareTo(java.lang.Object)>
<org.eclipse.osgi.internal.resolver.BundleDeltaImpl: int getType()>
<org.eclipse.osgi.internal.resolver.BundleDeltaImpl: org.eclipse.osgi.service.resolver.BundleDescription getBundle()>
<org.eclipse.osgi.internal.resolver.BundleDeltaImpl: void <init>(org.eclipse.osgi.service.resolver.BundleDescription,int)>
<org.eclipse.osgi.internal.resolver.BundleDeltaImpl: void setBundle(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.BundleDeltaImpl: void setType(int)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl$LazyData: void <init>(org.eclipse.osgi.internal.resolver.BundleDescriptionImpl)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: boolean compare(org.eclipse.osgi.framework.internal.core.KeyedElement)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: boolean hasDynamicImports()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: boolean isResolved()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: boolean isSingleton()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: int getKeyHashCode()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: java.lang.Object getKey()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: java.lang.Object getUserObject()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: java.lang.String getPlatformFilter()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: java.lang.String getSymbolicName()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: long getBundleId()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.BundleDescription[] getResolvedRequires()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.BundleSpecification[] getRequiredBundles()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.ExportPackageDescription[] getExportPackages()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.ExportPackageDescription[] getResolvedImports()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.ExportPackageDescription[] getSelectedExports()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.ExportPackageDescription[] mergeSystemExports(org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.HostSpecification getHost()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: org.eclipse.osgi.service.resolver.ImportPackageSpecification[] getImportPackages()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void addDependencies(org.eclipse.osgi.service.resolver.BaseDescription[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void addDependency(org.eclipse.osgi.internal.resolver.BaseDescriptionImpl)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void addDependent(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void checkLazyData()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void fullyLoad()>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setBundleId(long)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setContainingState(org.eclipse.osgi.service.resolver.State)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setExportPackages(org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setImportPackages(org.eclipse.osgi.service.resolver.ImportPackageSpecification[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setLazyLoaded(boolean)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setLocation(java.lang.String)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setPlatformFilter(java.lang.String)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setRequiredBundles(org.eclipse.osgi.service.resolver.BundleSpecification[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setResolvedImports(org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setResolvedRequires(org.eclipse.osgi.service.resolver.BundleDescription[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setSelectedExports(org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setStateBit(int,boolean)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setSymbolicName(java.lang.String)>
<org.eclipse.osgi.internal.resolver.BundleDescriptionImpl: void setUserObject(java.lang.Object)>
<org.eclipse.osgi.internal.resolver.BundleSpecificationImpl: boolean isExported()>
<org.eclipse.osgi.internal.resolver.BundleSpecificationImpl: boolean isOptional()>
<org.eclipse.osgi.internal.resolver.BundleSpecificationImpl: boolean isSatisfiedBy(org.eclipse.osgi.service.resolver.BaseDescription)>
<org.eclipse.osgi.internal.resolver.BundleSpecificationImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.BundleSpecificationImpl: void setExported(boolean)>
<org.eclipse.osgi.internal.resolver.BundleSpecificationImpl: void setOptional(boolean)>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: boolean isRoot()>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: java.lang.Object getDirective(java.lang.String)>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: java.lang.Object setDirective(java.lang.String,java.lang.Object)>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: org.eclipse.osgi.service.resolver.BundleDescription getExporter()>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: void setAttributes(java.util.Map)>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: void setExporter(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.ExportPackageDescriptionImpl: void setRoot(boolean)>
<org.eclipse.osgi.internal.resolver.ReadOnlyState: long getTimeStamp()>
<org.eclipse.osgi.internal.resolver.ReadOnlyState: void <init>(org.eclipse.osgi.service.resolver.State)>
<org.eclipse.osgi.internal.resolver.StateBuilder: java.util.Map getAttributes(org.eclipse.osgi.util.ManifestElement,java.lang.String[])>
<org.eclipse.osgi.internal.resolver.StateBuilder: org.eclipse.osgi.service.resolver.BundleDescription createBundleDescription(org.eclipse.osgi.internal.resolver.StateImpl,java.util.Dictionary,java.lang.String)>
<org.eclipse.osgi.internal.resolver.StateBuilder: org.eclipse.osgi.service.resolver.BundleSpecification createRequiredBundle(org.eclipse.osgi.util.ManifestElement)>
<org.eclipse.osgi.internal.resolver.StateBuilder: org.eclipse.osgi.service.resolver.BundleSpecification[] createRequiredBundles(org.eclipse.osgi.util.ManifestElement[])>
<org.eclipse.osgi.internal.resolver.StateBuilder: org.eclipse.osgi.service.resolver.ExportPackageDescription[] createExportPackages(org.eclipse.osgi.util.ManifestElement[],org.eclipse.osgi.util.ManifestElement[],org.eclipse.osgi.util.ManifestElement[],java.util.ArrayList,int,boolean)>
<org.eclipse.osgi.internal.resolver.StateBuilder: org.eclipse.osgi.service.resolver.ImportPackageSpecification[] createImportPackages(org.eclipse.osgi.service.resolver.ExportPackageDescription[],java.util.ArrayList,org.eclipse.osgi.util.ManifestElement[],org.eclipse.osgi.util.ManifestElement[],int)>
<org.eclipse.osgi.internal.resolver.StateBuilder: org.eclipse.osgi.service.resolver.VersionRange getVersionRange(java.lang.String)>
<org.eclipse.osgi.internal.resolver.StateBuilder: void <clinit>()>
<org.eclipse.osgi.internal.resolver.StateBuilder: void addExportPackages(org.eclipse.osgi.util.ManifestElement,java.util.ArrayList,int,boolean,boolean)>
<org.eclipse.osgi.internal.resolver.StateBuilder: void checkForDuplicateDirectives(org.eclipse.osgi.util.ManifestElement[])>
<org.eclipse.osgi.internal.resolver.StateBuilder: void checkImportExportSyntax(org.eclipse.osgi.util.ManifestElement[],boolean)>
<org.eclipse.osgi.internal.resolver.StateBuilder: void validateHeaders(java.util.Dictionary)>
<org.eclipse.osgi.internal.resolver.StateDeltaImpl: org.eclipse.osgi.service.resolver.BundleDelta[] getChanges()>
<org.eclipse.osgi.internal.resolver.StateDeltaImpl: void <init>(org.eclipse.osgi.service.resolver.State)>
<org.eclipse.osgi.internal.resolver.StateDeltaImpl: void recordBundleAdded(org.eclipse.osgi.internal.resolver.BundleDescriptionImpl)>
<org.eclipse.osgi.internal.resolver.StateDeltaImpl: void recordBundleResolved(org.eclipse.osgi.internal.resolver.BundleDescriptionImpl,boolean)>
<org.eclipse.osgi.internal.resolver.StateImpl: boolean addBundle(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.StateImpl: boolean basicAddBundle(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.StateImpl: boolean checkProp(java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.internal.resolver.StateImpl: boolean inStrictMode()>
<org.eclipse.osgi.internal.resolver.StateImpl: boolean setPlatformProperties(java.util.Dictionary)>
<org.eclipse.osgi.internal.resolver.StateImpl: boolean setProps(java.util.Dictionary,java.util.Dictionary)>
<org.eclipse.osgi.internal.resolver.StateImpl: java.util.Dictionary[] getPlatformProperties()>
<org.eclipse.osgi.internal.resolver.StateImpl: long getTimeStamp()>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.internal.resolver.StateDeltaImpl getDelta()>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.internal.resolver.StateReader getReader()>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.BundleDescription getBundle(long)>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.BundleDescription[] getBundles()>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.ExportPackageDescription[] getSystemPackages()>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.StateDelta resolve()>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.StateDelta resolve(boolean,org.eclipse.osgi.service.resolver.BundleDescription[])>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.StateDelta resolve(org.eclipse.osgi.service.resolver.BundleDescription[])>
<org.eclipse.osgi.internal.resolver.StateImpl: org.eclipse.osgi.service.resolver.StateObjectFactory getFactory()>
<org.eclipse.osgi.internal.resolver.StateImpl: void <clinit>()>
<org.eclipse.osgi.internal.resolver.StateImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.StateImpl: void fullyLoad()>
<org.eclipse.osgi.internal.resolver.StateImpl: void resolveBundle(org.eclipse.osgi.service.resolver.BundleDescription,boolean,org.eclipse.osgi.service.resolver.BundleDescription[],org.eclipse.osgi.service.resolver.ExportPackageDescription[],org.eclipse.osgi.service.resolver.BundleDescription[],org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.internal.resolver.StateImpl: void resolveConstraint(org.eclipse.osgi.service.resolver.VersionConstraint,org.eclipse.osgi.service.resolver.BaseDescription)>
<org.eclipse.osgi.internal.resolver.StateImpl: void resolveConstraints(org.eclipse.osgi.internal.resolver.BundleDescriptionImpl,org.eclipse.osgi.service.resolver.BundleDescription[],org.eclipse.osgi.service.resolver.ExportPackageDescription[],org.eclipse.osgi.service.resolver.BundleDescription[],org.eclipse.osgi.service.resolver.ExportPackageDescription[])>
<org.eclipse.osgi.internal.resolver.StateImpl: void setFactory(org.eclipse.osgi.service.resolver.StateObjectFactory)>
<org.eclipse.osgi.internal.resolver.StateImpl: void setResolver(org.eclipse.osgi.service.resolver.Resolver)>
<org.eclipse.osgi.internal.resolver.StateImpl: void setTimeStamp(long)>
<org.eclipse.osgi.internal.resolver.StateObjectFactoryImpl: org.eclipse.osgi.internal.resolver.SystemState createSystemState()>
<org.eclipse.osgi.internal.resolver.StateObjectFactoryImpl: org.eclipse.osgi.service.resolver.BundleDescription createBundleDescription(org.eclipse.osgi.service.resolver.State,java.util.Dictionary,java.lang.String,long)>
<org.eclipse.osgi.internal.resolver.StateObjectFactoryImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.SystemState: boolean addBundle(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.SystemState: org.eclipse.osgi.service.resolver.StateDelta resolve()>
<org.eclipse.osgi.internal.resolver.SystemState: org.eclipse.osgi.service.resolver.StateDelta resolve(org.eclipse.osgi.service.resolver.BundleDescription[])>
<org.eclipse.osgi.internal.resolver.SystemState: void <init>()>
<org.eclipse.osgi.internal.resolver.SystemState: void updateTimeStamp()>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: java.lang.String getName()>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: org.eclipse.osgi.service.resolver.BundleDescription getBundle()>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: org.eclipse.osgi.service.resolver.VersionRange getVersionRange()>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: void <init>()>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: void setBundle(org.eclipse.osgi.service.resolver.BundleDescription)>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: void setName(java.lang.String)>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: void setSupplier(org.eclipse.osgi.service.resolver.BaseDescription)>
<org.eclipse.osgi.internal.resolver.VersionConstraintImpl: void setVersionRange(org.eclipse.osgi.service.resolver.VersionRange)>
<org.eclipse.osgi.service.resolver.VersionRange: boolean isIncluded(org.osgi.framework.Version)>
<org.eclipse.osgi.service.resolver.VersionRange: org.osgi.framework.Version getMaximum()>
<org.eclipse.osgi.service.resolver.VersionRange: org.osgi.framework.Version getMinimum()>
<org.eclipse.osgi.service.resolver.VersionRange: void <clinit>()>
<org.eclipse.osgi.service.resolver.VersionRange: void <init>(java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String getAttribute(java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String getDirective(java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String getTableValue(java.util.Hashtable,java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String getValue()>
<org.eclipse.osgi.util.ManifestElement: java.lang.String[] getArrayFromList(java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String[] getDirectives(java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String[] getTableValues(java.util.Hashtable,java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: java.lang.String[] getValueComponents()>
<org.eclipse.osgi.util.ManifestElement: java.util.Enumeration getDirectiveKeys()>
<org.eclipse.osgi.util.ManifestElement: java.util.Enumeration getKeys()>
<org.eclipse.osgi.util.ManifestElement: java.util.Enumeration getTableKeys(java.util.Hashtable)>
<org.eclipse.osgi.util.ManifestElement: java.util.Hashtable addTableValue(java.util.Hashtable,java.lang.String,java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: org.eclipse.osgi.util.ManifestElement[] parseHeader(java.lang.String,java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: void <init>()>
<org.eclipse.osgi.util.ManifestElement: void addAttribute(java.lang.String,java.lang.String)>
<org.eclipse.osgi.util.ManifestElement: void addDirective(java.lang.String,java.lang.String)>
<org.eclipse.osgi.util.NLS: java.lang.String bind(java.lang.String,java.lang.Object)>
<org.eclipse.osgi.util.NLS: java.lang.String bind(java.lang.String,java.lang.Object,java.lang.Object)>
<org.eclipse.osgi.util.NLS: java.lang.String bind(java.lang.String,java.lang.Object[])>
<org.eclipse.osgi.util.NLS: java.lang.String internalBind(java.lang.String,java.lang.Object[],java.lang.String,java.lang.String)>
<org.eclipse.osgi.util.NLS: void <clinit>()>
<org.eclipse.osgi.util.NLS: void initializeMessages(java.lang.String,java.lang.Class)>
<org.eclipse.update.configurator.ConfiguratorUtils: org.eclipse.update.configurator.IPlatformConfiguration getCurrentPlatformConfiguration()>
<org.eclipse.update.internal.configurator.BundleManifest: boolean exists()>
<org.eclipse.update.internal.configurator.BundleManifest: org.eclipse.update.internal.configurator.PluginEntry getPluginEntry()>
<org.eclipse.update.internal.configurator.BundleManifest: void <init>(java.io.File)>
<org.eclipse.update.internal.configurator.BundleManifest: void <init>(java.io.InputStream,java.lang.String)>
<org.eclipse.update.internal.configurator.BundleManifest: void parse(java.io.InputStream)>
<org.eclipse.update.internal.configurator.Configuration: boolean isDirty()>
<org.eclipse.update.internal.configurator.Configuration: boolean isTransient()>
<org.eclipse.update.internal.configurator.Configuration: java.net.URL getURL()>
<org.eclipse.update.internal.configurator.Configuration: java.util.Date getDate()>
<org.eclipse.update.internal.configurator.Configuration: org.eclipse.update.internal.configurator.Configuration getLinkedConfig()>
<org.eclipse.update.internal.configurator.Configuration: org.eclipse.update.internal.configurator.SiteEntry getSiteEntry(java.lang.String)>
<org.eclipse.update.internal.configurator.Configuration: org.eclipse.update.internal.configurator.SiteEntry[] getSites()>
<org.eclipse.update.internal.configurator.Configuration: org.w3c.dom.Element toXML(org.w3c.dom.Document)>
<org.eclipse.update.internal.configurator.Configuration: void <init>()>
<org.eclipse.update.internal.configurator.Configuration: void <init>(java.util.Date)>
<org.eclipse.update.internal.configurator.Configuration: void addSiteEntry(java.lang.String,org.eclipse.update.internal.configurator.SiteEntry)>
<org.eclipse.update.internal.configurator.Configuration: void setDate(java.util.Date)>
<org.eclipse.update.internal.configurator.Configuration: void setDirty(boolean)>
<org.eclipse.update.internal.configurator.Configuration: void setLastModified(long)>
<org.eclipse.update.internal.configurator.Configuration: void setURL(java.net.URL)>
<org.eclipse.update.internal.configurator.ConfigurationActivator$1: void <init>(org.eclipse.update.internal.configurator.ConfigurationActivator,boolean[])>
<org.eclipse.update.internal.configurator.ConfigurationActivator$1: void frameworkEvent(org.osgi.framework.FrameworkEvent)>
<org.eclipse.update.internal.configurator.ConfigurationActivator: boolean canRunWithCachedData()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: boolean installBundles()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: java.lang.String[] getBundlesToInstall(org.osgi.framework.Bundle[],java.net.URL[])>
<org.eclipse.update.internal.configurator.ConfigurationActivator: java.lang.String[] getInitialSymbolicNames(org.osgi.framework.Bundle[])>
<org.eclipse.update.internal.configurator.ConfigurationActivator: java.util.List getUnresolvedBundles()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: org.eclipse.update.internal.configurator.PlatformConfiguration getPlatformConfiguration(java.net.URL,org.eclipse.osgi.service.datalocation.Location)>
<org.eclipse.update.internal.configurator.ConfigurationActivator: org.osgi.framework.BundleContext getBundleContext()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: org.osgi.framework.Bundle[] getBundlesToUninstall(org.osgi.framework.Bundle[],java.net.URL[])>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void <clinit>()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void <init>()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void acquireFrameworkLogService()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void initialize()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void loadOptions()>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void refreshPackages(org.osgi.framework.Bundle[])>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void removeInitialBundles(java.util.List,org.osgi.framework.Bundle[])>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void start(org.osgi.framework.BundleContext)>
<org.eclipse.update.internal.configurator.ConfigurationActivator: void writePlatformConfigurationTimeStamp()>
<org.eclipse.update.internal.configurator.ConfigurationParser: org.eclipse.update.internal.configurator.Configuration parse(java.net.URL)>
<org.eclipse.update.internal.configurator.ConfigurationParser: void <clinit>()>
<org.eclipse.update.internal.configurator.ConfigurationParser: void <init>()>
<org.eclipse.update.internal.configurator.FeatureEntry: boolean canBePrimary()>
<org.eclipse.update.internal.configurator.FeatureEntry: java.lang.String getFeatureIdentifier()>
<org.eclipse.update.internal.configurator.FeatureEntry: java.lang.String getURL()>
<org.eclipse.update.internal.configurator.FeatureEntry: java.net.URL[] getFeatureRootURLs()>
<org.eclipse.update.internal.configurator.FeatureEntry: org.w3c.dom.Element toXML(org.w3c.dom.Document)>
<org.eclipse.update.internal.configurator.FeatureEntry: void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String,java.net.URL[])>
<org.eclipse.update.internal.configurator.FeatureEntry: void setSite(org.eclipse.update.internal.configurator.SiteEntry)>
<org.eclipse.update.internal.configurator.FeatureEntry: void setURL(java.lang.String)>
<org.eclipse.update.internal.configurator.FeatureParser: org.eclipse.update.internal.configurator.FeatureEntry parse(java.net.URL)>
<org.eclipse.update.internal.configurator.FeatureParser: void <clinit>()>
<org.eclipse.update.internal.configurator.FeatureParser: void <init>()>
<org.eclipse.update.internal.configurator.FeatureParser: void processFeature(org.xml.sax.Attributes)>
<org.eclipse.update.internal.configurator.FeatureParser: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.update.internal.configurator.IConfigurationConstants: void <clinit>()>
<org.eclipse.update.internal.configurator.Locker_JavaNio: boolean lock()>
<org.eclipse.update.internal.configurator.Locker_JavaNio: void <init>(java.io.File)>
<org.eclipse.update.internal.configurator.Locker_JavaNio: void release()>
<org.eclipse.update.internal.configurator.Messages: void <clinit>()>
<org.eclipse.update.internal.configurator.PlatformConfiguration$1: boolean accept(java.io.File)>
<org.eclipse.update.internal.configurator.PlatformConfiguration$1: void <init>(org.eclipse.update.internal.configurator.PlatformConfiguration)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: boolean isTransient()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: boolean isUpdateable()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: boolean supportsDetection(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: java.net.URL getInstallURL()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: java.net.URL resolvePlatformURL(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: java.net.URL[] getPluginPath()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: long computeChangeStamp()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: long computeFeaturesChangeStamp()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: long computePluginsChangeStamp()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: long getChangeStamp()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.configurator.IPlatformConfiguration$IFeatureEntry[] getConfiguredFeatureEntries()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.configurator.IPlatformConfiguration$ISiteEntry createSiteEntry(java.net.URL,org.eclipse.update.configurator.IPlatformConfiguration$ISitePolicy)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.configurator.IPlatformConfiguration$ISiteEntry getRootSite()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.configurator.IPlatformConfiguration$ISiteEntry[] getConfiguredSites()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.configurator.IPlatformConfiguration$ISitePolicy createSitePolicy(int,java.lang.String[])>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.internal.configurator.Configuration loadConfig(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.internal.configurator.Locker createLocker(java.io.File)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: org.eclipse.update.internal.configurator.PlatformConfiguration getCurrent()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void <clinit>()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void <init>(org.eclipse.osgi.service.datalocation.Location)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void clearConfigurationLock()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void configureExternalLinks()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void configureSite(org.eclipse.update.configurator.IPlatformConfiguration$ISiteEntry)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void configureSite(org.eclipse.update.configurator.IPlatformConfiguration$ISiteEntry,boolean)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void createDefaultConfiguration(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void getConfigurationLock(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void initializeCurrent(org.eclipse.osgi.service.datalocation.Location)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void save()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void save(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void saveAsXML(java.io.OutputStream)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void startup(java.net.URL,org.eclipse.osgi.service.datalocation.Location)>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void validateSites()>
<org.eclipse.update.internal.configurator.PlatformConfiguration: void verifyPath(java.net.URL)>
<org.eclipse.update.internal.configurator.PlatformConfigurationFactory: org.eclipse.update.configurator.IPlatformConfiguration getCurrentPlatformConfiguration()>
<org.eclipse.update.internal.configurator.PlatformConfigurationFactory: void <init>()>
<org.eclipse.update.internal.configurator.PluginEntry: java.lang.String getURL()>
<org.eclipse.update.internal.configurator.PluginEntry: void <init>()>
<org.eclipse.update.internal.configurator.PluginEntry: void isFragment(boolean)>
<org.eclipse.update.internal.configurator.PluginEntry: void setPluginIdentifier(java.lang.String)>
<org.eclipse.update.internal.configurator.PluginEntry: void setPluginVersion(java.lang.String)>
<org.eclipse.update.internal.configurator.PluginEntry: void setURL(java.lang.String)>
<org.eclipse.update.internal.configurator.PluginEntry: void setVersionedIdentifier(org.eclipse.update.internal.configurator.VersionedIdentifier)>
<org.eclipse.update.internal.configurator.PluginParser$ParseCompleteException: void <init>(org.eclipse.update.internal.configurator.PluginParser,java.lang.String)>
<org.eclipse.update.internal.configurator.PluginParser: org.eclipse.update.internal.configurator.PluginEntry parse(java.io.File)>
<org.eclipse.update.internal.configurator.PluginParser: org.eclipse.update.internal.configurator.PluginEntry parse(java.io.InputStream,java.lang.String)>
<org.eclipse.update.internal.configurator.PluginParser: void <clinit>()>
<org.eclipse.update.internal.configurator.PluginParser: void <init>()>
<org.eclipse.update.internal.configurator.PluginParser: void processPlugin(org.xml.sax.Attributes)>
<org.eclipse.update.internal.configurator.PluginParser: void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)>
<org.eclipse.update.internal.configurator.ProductProvider: org.eclipse.core.runtime.IProduct[] getProducts()>
<org.eclipse.update.internal.configurator.ProductProvider: void <init>()>
<org.eclipse.update.internal.configurator.SiteEntry$1: boolean accept(java.io.File)>
<org.eclipse.update.internal.configurator.SiteEntry$1: void <init>(org.eclipse.update.internal.configurator.SiteEntry)>
<org.eclipse.update.internal.configurator.SiteEntry: boolean access$0()>
<org.eclipse.update.internal.configurator.SiteEntry: boolean isEnabled()>
<org.eclipse.update.internal.configurator.SiteEntry: boolean isExternallyLinkedSite()>
<org.eclipse.update.internal.configurator.SiteEntry: boolean isUpdateable()>
<org.eclipse.update.internal.configurator.SiteEntry: java.lang.String getLinkFileName()>
<org.eclipse.update.internal.configurator.SiteEntry: java.lang.String[] getDetectedFeatures()>
<org.eclipse.update.internal.configurator.SiteEntry: java.lang.String[] getDetectedPlugins()>
<org.eclipse.update.internal.configurator.SiteEntry: java.lang.String[] getFeatures()>
<org.eclipse.update.internal.configurator.SiteEntry: java.lang.String[] getPlugins()>
<org.eclipse.update.internal.configurator.SiteEntry: java.net.URL getResolvedURL()>
<org.eclipse.update.internal.configurator.SiteEntry: java.net.URL getURL()>
<org.eclipse.update.internal.configurator.SiteEntry: long computeFeaturesChangeStamp()>
<org.eclipse.update.internal.configurator.SiteEntry: long computePluginsChangeStamp()>
<org.eclipse.update.internal.configurator.SiteEntry: long computeStamp(java.lang.String[])>
<org.eclipse.update.internal.configurator.SiteEntry: long getFeaturesChangeStamp()>
<org.eclipse.update.internal.configurator.SiteEntry: long getPluginsChangeStamp()>
<org.eclipse.update.internal.configurator.SiteEntry: org.eclipse.update.configurator.IPlatformConfiguration$ISitePolicy getSitePolicy()>
<org.eclipse.update.internal.configurator.SiteEntry: org.eclipse.update.internal.configurator.FeatureEntry[] getFeatureEntries()>
<org.eclipse.update.internal.configurator.SiteEntry: org.w3c.dom.Element toXML(org.w3c.dom.Document)>
<org.eclipse.update.internal.configurator.SiteEntry: void <clinit>()>
<org.eclipse.update.internal.configurator.SiteEntry: void <init>(java.net.URL,org.eclipse.update.configurator.IPlatformConfiguration$ISitePolicy)>
<org.eclipse.update.internal.configurator.SiteEntry: void addFeatureEntry(org.eclipse.update.configurator.IPlatformConfiguration$IFeatureEntry)>
<org.eclipse.update.internal.configurator.SiteEntry: void addPluginEntry(org.eclipse.update.internal.configurator.PluginEntry)>
<org.eclipse.update.internal.configurator.SiteEntry: void detectFeatures()>
<org.eclipse.update.internal.configurator.SiteEntry: void detectPackedPlugin(java.io.File,boolean)>
<org.eclipse.update.internal.configurator.SiteEntry: void detectPlugins()>
<org.eclipse.update.internal.configurator.SiteEntry: void detectUnpackedPlugin(java.io.File,boolean)>
<org.eclipse.update.internal.configurator.SiteEntry: void loadFromDisk(long)>
<org.eclipse.update.internal.configurator.SiteEntry: void setConfig(org.eclipse.update.internal.configurator.Configuration)>
<org.eclipse.update.internal.configurator.SitePolicy: int getType()>
<org.eclipse.update.internal.configurator.SitePolicy: java.lang.String[] getList()>
<org.eclipse.update.internal.configurator.SitePolicy: void <init>(int,java.lang.String[])>
<org.eclipse.update.internal.configurator.Utils: boolean isAutomaticallyStartedBundle(java.lang.String)>
<org.eclipse.update.internal.configurator.Utils: boolean isValidEnvironment(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.eclipse.update.internal.configurator.Utils: java.lang.String canonicalizeURL(java.lang.String)>
<org.eclipse.update.internal.configurator.Utils: java.lang.String makeRelative(java.net.URL,java.lang.String)>
<org.eclipse.update.internal.configurator.Utils: java.net.URL getInstallURL()>
<org.eclipse.update.internal.configurator.Utils: java.net.URL makeRelative(java.net.URL,java.net.URL)>
<org.eclipse.update.internal.configurator.Utils: org.eclipse.core.runtime.IPath makeRelative(org.eclipse.core.runtime.IPath,org.eclipse.core.runtime.IPath)>
<org.eclipse.update.internal.configurator.Utils: void <clinit>()>
<org.eclipse.update.internal.configurator.Utils: void debug(java.lang.String)>
<org.eclipse.update.internal.configurator.VersionedIdentifier: java.lang.String getIdentifier()>
<org.eclipse.update.internal.configurator.VersionedIdentifier: java.lang.String getVersion()>
<org.eclipse.update.internal.configurator.VersionedIdentifier: void <init>(java.lang.String)>
<org.eclipse.update.internal.configurator.VersionedIdentifier: void <init>(java.lang.String,java.lang.String)>
<org.eclipse.update.internal.configurator.VersionedIdentifier: void parseVersion(java.lang.String)>
<org.eclipse.update.internal.configurator.XMLPrintHandler: java.lang.String wrapAttributeForPrint(java.lang.String,java.lang.String)>
<org.eclipse.update.internal.configurator.XMLPrintHandler: java.lang.StringBuffer encode(java.lang.String)>
<org.eclipse.update.internal.configurator.XMLPrintHandler: void printBeginElement(java.io.Writer,java.lang.String)>
<org.eclipse.update.internal.configurator.XMLPrintHandler: void printEndElement(java.io.Writer,java.lang.String)>
<org.eclipse.update.internal.configurator.XMLPrintHandler: void printHead(java.io.Writer,java.lang.String)>
<org.eclipse.update.internal.configurator.XMLPrintHandler: void printNode(java.io.Writer,org.w3c.dom.Node,java.lang.String)>
<org.osgi.framework.BundleEvent: int getType()>
<org.osgi.framework.BundleEvent: org.osgi.framework.Bundle getBundle()>
<org.osgi.framework.BundleEvent: void <init>(int,org.osgi.framework.Bundle)>
<org.osgi.framework.BundleException: void <init>(java.lang.String)>
<org.osgi.framework.FrameworkEvent: int getType()>
<org.osgi.framework.FrameworkEvent: void <init>(int,org.osgi.framework.Bundle,java.lang.Throwable)>
<org.osgi.framework.ServiceEvent: int getType()>
<org.osgi.framework.ServiceEvent: org.osgi.framework.ServiceReference getServiceReference()>
<org.osgi.framework.ServiceEvent: void <init>(int,org.osgi.framework.ServiceReference)>
<org.osgi.framework.Version: boolean equals(java.lang.Object)>
<org.osgi.framework.Version: int compareTo(java.lang.Object)>
<org.osgi.framework.Version: java.lang.String toString()>
<org.osgi.framework.Version: org.osgi.framework.Version parseVersion(java.lang.String)>
<org.osgi.framework.Version: void <clinit>()>
<org.osgi.framework.Version: void <init>(int,int,int)>
<org.osgi.framework.Version: void <init>(int,int,int,java.lang.String)>
<org.osgi.framework.Version: void <init>(java.lang.String)>
<org.osgi.framework.Version: void validate()>
<org.osgi.service.url.AbstractURLStreamHandlerService: java.lang.String toExternalForm(java.net.URL)>
<org.osgi.service.url.AbstractURLStreamHandlerService: void <init>()>
<org.osgi.service.url.AbstractURLStreamHandlerService: void parseURL(org.osgi.service.url.URLStreamHandlerSetter,java.net.URL,java.lang.String,int,int)>
<org.osgi.service.url.AbstractURLStreamHandlerService: void setURL(java.net.URL,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<org.osgi.util.tracker.ServiceTracker$Tracked: void <init>(org.osgi.util.tracker.ServiceTracker)>
<org.osgi.util.tracker.ServiceTracker$Tracked: void close()>
<org.osgi.util.tracker.ServiceTracker$Tracked: void serviceChanged(org.osgi.framework.ServiceEvent)>
<org.osgi.util.tracker.ServiceTracker$Tracked: void setInitialServices(org.osgi.framework.ServiceReference[])>
<org.osgi.util.tracker.ServiceTracker$Tracked: void track(org.osgi.framework.ServiceReference)>
<org.osgi.util.tracker.ServiceTracker$Tracked: void trackAdding(org.osgi.framework.ServiceReference)>
<org.osgi.util.tracker.ServiceTracker$Tracked: void trackInitialServices()>
<org.osgi.util.tracker.ServiceTracker$Tracked: void untrack(org.osgi.framework.ServiceReference)>
<org.osgi.util.tracker.ServiceTracker: java.lang.Object addingService(org.osgi.framework.ServiceReference)>
<org.osgi.util.tracker.ServiceTracker: java.lang.Object getService()>
<org.osgi.util.tracker.ServiceTracker: java.lang.Object getService(org.osgi.framework.ServiceReference)>
<org.osgi.util.tracker.ServiceTracker: org.osgi.framework.ServiceReference getServiceReference()>
<org.osgi.util.tracker.ServiceTracker: org.osgi.framework.ServiceReference[] getInitialReferences(boolean,java.lang.String,java.lang.String)>
<org.osgi.util.tracker.ServiceTracker: org.osgi.framework.ServiceReference[] getServiceReferences()>
<org.osgi.util.tracker.ServiceTracker: void <init>(org.osgi.framework.BundleContext,java.lang.String,org.osgi.util.tracker.ServiceTrackerCustomizer)>
<org.osgi.util.tracker.ServiceTracker: void <init>(org.osgi.framework.BundleContext,org.osgi.framework.Filter,org.osgi.util.tracker.ServiceTrackerCustomizer)>
<org.osgi.util.tracker.ServiceTracker: void close()>
<org.osgi.util.tracker.ServiceTracker: void finalize()>
<org.osgi.util.tracker.ServiceTracker: void modified()>
<org.osgi.util.tracker.ServiceTracker: void open()>
<org.osgi.util.tracker.ServiceTracker: void open(boolean)>
<org.osgi.util.tracker.ServiceTracker: void removedService(org.osgi.framework.ServiceReference,java.lang.Object)>
<org.w3c.dom.DOMException: void <init>(short,java.lang.String)>
<org.xml.sax.InputSource: java.io.InputStream getByteStream()>
<org.xml.sax.InputSource: java.io.Reader getCharacterStream()>
<org.xml.sax.InputSource: java.lang.String getEncoding()>
<org.xml.sax.InputSource: java.lang.String getPublicId()>
<org.xml.sax.InputSource: java.lang.String getSystemId()>
<org.xml.sax.InputSource: void <init>(java.io.InputStream)>
<org.xml.sax.InputSource: void <init>(java.io.Reader)>
<org.xml.sax.InputSource: void setByteStream(java.io.InputStream)>
<org.xml.sax.InputSource: void setCharacterStream(java.io.Reader)>
<org.xml.sax.SAXException: java.lang.String getMessage()>
<org.xml.sax.SAXException: void <init>(java.lang.String)>
<org.xml.sax.helpers.DefaultHandler: void <init>()>
<org.xml.sax.helpers.DefaultHandler: void characters(char[],int,int)>
<org.xml.sax.helpers.DefaultHandler: void endDocument()>
<org.xml.sax.helpers.DefaultHandler: void processingInstruction(java.lang.String,java.lang.String)>
<org.xml.sax.helpers.DefaultHandler: void setDocumentLocator(org.xml.sax.Locator)>
<org.xml.sax.helpers.DefaultHandler: void startDocument()>
<org.xml.sax.helpers.LocatorImpl: void <init>()>
<org.xml.sax.helpers.LocatorImpl: void setColumnNumber(int)>
<org.xml.sax.helpers.LocatorImpl: void setLineNumber(int)>
<org.xml.sax.helpers.LocatorImpl: void setSystemId(java.lang.String)>
<sun.jkernel.DownloadManager: boolean isJREComplete()>
<sun.jkernel.DownloadManager: java.io.File[] getAdditionalBootStrapPaths()>
<sun.jkernel.DownloadManager: java.lang.String getBootClassPathEntryForClass(java.lang.String)>
<sun.jkernel.DownloadManager: java.lang.String getBootClassPathEntryForResource(java.lang.String)>
<sun.misc.ASCIICaseInsensitiveComparator: boolean isUpper(int)>
<sun.misc.ASCIICaseInsensitiveComparator: int compare(java.lang.Object,java.lang.Object)>
<sun.misc.ASCIICaseInsensitiveComparator: int lowerCaseHashCode(java.lang.String)>
<sun.misc.ASCIICaseInsensitiveComparator: int toLower(int)>
<sun.misc.ASCIICaseInsensitiveComparator: void <clinit>()>
<sun.misc.ASCIICaseInsensitiveComparator: void <init>()>
<sun.misc.CompoundEnumeration: boolean hasMoreElements()>
<sun.misc.CompoundEnumeration: boolean next()>
<sun.misc.CompoundEnumeration: void <init>(java.util.Enumeration[])>
<sun.misc.ExtensionDependency: boolean checkExtensionsDependencies(java.util.jar.JarFile)>
<sun.misc.FileURLMapper: boolean exists()>
<sun.misc.FileURLMapper: java.lang.String getPath()>
<sun.misc.FileURLMapper: void <init>(java.net.URL)>
<sun.misc.FloatingDecimal$1: java.lang.Object initialValue()>
<sun.misc.FloatingDecimal$1: void <init>()>
<sun.misc.FloatingDecimal: int countBits(long)>
<sun.misc.FloatingDecimal: int getChars(char[])>
<sun.misc.FloatingDecimal: java.lang.String toJavaFormatString()>
<sun.misc.FloatingDecimal: void <clinit>()>
<sun.misc.FloatingDecimal: void <init>(double)>
<sun.misc.FloatingDecimal: void developLongDigits(int,long,long)>
<sun.misc.FloatingDecimal: void dtoa(int,long,int)>
<sun.misc.FpUtils: double powerOfTwoD(int)>
<sun.misc.FpUtils: int getExponent(double)>
<sun.misc.FpUtils: void <clinit>()>
<sun.misc.IOUtils: byte[] readFully(java.io.InputStream,int,boolean)>
<sun.misc.JarIndex: java.lang.String[] getJarFiles()>
<sun.misc.JarIndex: java.util.LinkedList get(java.lang.String)>
<sun.misc.JarIndex: sun.misc.JarIndex getJarIndex(java.util.jar.JarFile,sun.misc.MetaIndex)>
<sun.misc.JarIndex: void <clinit>()>
<sun.misc.JarIndex: void <init>()>
<sun.misc.JarIndex: void <init>(java.io.InputStream)>
<sun.misc.JarIndex: void addToList(java.lang.String,java.lang.String,java.util.HashMap)>
<sun.misc.JarIndex: void read(java.io.InputStream)>
<sun.misc.Launcher$1: java.lang.Object run()>
<sun.misc.Launcher$1: void <init>(java.lang.String)>
<sun.misc.Launcher$2: java.lang.Object run()>
<sun.misc.Launcher$2: void <init>(java.io.File[])>
<sun.misc.Launcher$AppClassLoader: java.lang.Class loadClass(java.lang.String,boolean)>
<sun.misc.Launcher$AppClassLoader: java.security.PermissionCollection getPermissions(java.security.CodeSource)>
<sun.misc.Launcher$ExtClassLoader: java.lang.Class findClass(java.lang.String)>
<sun.misc.Launcher$Factory: java.net.URLStreamHandler createURLStreamHandler(java.lang.String)>
<sun.misc.Launcher: java.io.File[] access$200(java.lang.String)>
<sun.misc.Launcher: java.io.File[] getClassPath(java.lang.String)>
<sun.misc.Launcher: java.net.URL getFileURL(java.io.File)>
<sun.misc.Launcher: java.net.URL[] access$300(java.io.File[])>
<sun.misc.Launcher: java.net.URL[] pathToURLs(java.io.File[])>
<sun.misc.Launcher: sun.misc.URLClassPath getBootstrapClassPath()>
<sun.misc.MetaIndex: boolean mayContain(java.lang.String)>
<sun.misc.MetaIndex: java.util.Map getJarMap()>
<sun.misc.MetaIndex: sun.misc.MetaIndex forJar(java.io.File)>
<sun.misc.MetaIndex: void <init>(java.util.List,boolean)>
<sun.misc.MetaIndex: void registerDirectory(java.io.File)>
<sun.misc.PostVMInitHook: void run()>
<sun.misc.PostVMInitHook: void trackJavaUsage()>
<sun.misc.Resource: byte[] getBytes()>
<sun.misc.Resource: java.io.InputStream cachedInputStream()>
<sun.misc.Resource: java.nio.ByteBuffer getByteBuffer()>
<sun.misc.Resource: void <init>()>
<sun.misc.SharedSecrets: sun.misc.JavaAWTAccess getJavaAWTAccess()>
<sun.misc.SharedSecrets: sun.misc.JavaLangAccess getJavaLangAccess()>
<sun.misc.SharedSecrets: sun.misc.JavaUtilJarAccess javaUtilJarAccess()>
<sun.misc.SharedSecrets: void setJavaSecurityProtectionDomainAccess(sun.misc.JavaSecurityProtectionDomainAccess)>
<sun.misc.SharedSecrets: void setJavaUtilJarAccess(sun.misc.JavaUtilJarAccess)>
<sun.misc.Signal$1: void <init>(sun.misc.SignalHandler,sun.misc.Signal)>
<sun.misc.Signal$1: void run()>
<sun.misc.Signal: boolean equals(java.lang.Object)>
<sun.misc.Signal: int getNumber()>
<sun.misc.Signal: int hashCode()>
<sun.misc.Signal: java.lang.String toString()>
<sun.misc.Signal: void dispatch(int)>
<sun.misc.URLClassPath$1: boolean hasMoreElements()>
<sun.misc.URLClassPath$1: boolean next()>
<sun.misc.URLClassPath$1: void <init>(sun.misc.URLClassPath,java.lang.String,boolean)>
<sun.misc.URLClassPath$2: boolean hasMoreElements()>
<sun.misc.URLClassPath$2: boolean next()>
<sun.misc.URLClassPath$2: void <init>(sun.misc.URLClassPath,java.lang.String,boolean)>
<sun.misc.URLClassPath$3: java.lang.Object run()>
<sun.misc.URLClassPath$3: void <init>(sun.misc.URLClassPath,java.net.URL)>
<sun.misc.URLClassPath$JarLoader$1: java.lang.Object run()>
<sun.misc.URLClassPath$JarLoader$1: void <init>(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader$2: int getContentLength()>
<sun.misc.URLClassPath$JarLoader$2: java.io.InputStream getInputStream()>
<sun.misc.URLClassPath$JarLoader$2: java.net.URL getCodeSourceURL()>
<sun.misc.URLClassPath$JarLoader$2: java.net.URL getURL()>
<sun.misc.URLClassPath$JarLoader$2: java.security.CodeSigner[] getCodeSigners()>
<sun.misc.URLClassPath$JarLoader$2: java.util.jar.Manifest getManifest()>
<sun.misc.URLClassPath$JarLoader$2: void <init>(sun.misc.URLClassPath$JarLoader,java.lang.String,java.net.URL,java.util.jar.JarEntry)>
<sun.misc.URLClassPath$JarLoader: boolean isOptimizable(java.net.URL)>
<sun.misc.URLClassPath$JarLoader: boolean validIndex(java.lang.String)>
<sun.misc.URLClassPath$JarLoader: java.net.URL access$400(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: java.net.URL findResource(java.lang.String,boolean)>
<sun.misc.URLClassPath$JarLoader: java.net.URL[] getClassPath()>
<sun.misc.URLClassPath$JarLoader: java.util.HashMap access$900(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile access$500(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile access$502(sun.misc.URLClassPath$JarLoader,java.util.jar.JarFile)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile access$600(sun.misc.URLClassPath$JarLoader,java.net.URL)>
<sun.misc.URLClassPath$JarLoader: java.util.jar.JarFile getJarFile(java.net.URL)>
<sun.misc.URLClassPath$JarLoader: sun.misc.JarIndex access$700(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: sun.misc.JarIndex access$702(sun.misc.URLClassPath$JarLoader,sun.misc.JarIndex)>
<sun.misc.URLClassPath$JarLoader: sun.misc.MetaIndex access$800(sun.misc.URLClassPath$JarLoader)>
<sun.misc.URLClassPath$JarLoader: sun.misc.Resource checkResource(java.lang.String,boolean,java.util.jar.JarEntry)>
<sun.misc.URLClassPath$JarLoader: sun.misc.Resource getResource(java.lang.String,boolean)>
<sun.misc.URLClassPath$JarLoader: sun.misc.Resource getResource(java.lang.String,boolean,java.util.Set)>
<sun.misc.URLClassPath$JarLoader: void <init>(java.net.URL,java.net.URLStreamHandler,java.util.HashMap)>
<sun.misc.URLClassPath$JarLoader: void ensureOpen()>
<sun.misc.URLClassPath$JarLoader: void parseExtensionsDependencies()>
<sun.misc.URLClassPath$Loader: java.net.URL getBaseURL()>
<sun.misc.URLClassPath$Loader: void <init>(java.net.URL)>
<sun.misc.URLClassPath: boolean access$300()>
<sun.misc.URLClassPath: java.net.URL checkURL(java.net.URL)>
<sun.misc.URLClassPath: java.net.URL findResource(java.lang.String,boolean)>
<sun.misc.URLClassPath: java.net.URLStreamHandler access$100(sun.misc.URLClassPath)>
<sun.misc.URLClassPath: java.util.Enumeration findResources(java.lang.String,boolean)>
<sun.misc.URLClassPath: java.util.Enumeration getResources(java.lang.String)>
<sun.misc.URLClassPath: java.util.Enumeration getResources(java.lang.String,boolean)>
<sun.misc.URLClassPath: sun.misc.Resource getResource(java.lang.String)>
<sun.misc.URLClassPath: sun.misc.Resource getResource(java.lang.String,boolean)>
<sun.misc.URLClassPath: sun.misc.URLClassPath$Loader access$000(sun.misc.URLClassPath,int)>
<sun.misc.URLClassPath: sun.misc.URLClassPath$Loader getLoader(int)>
<sun.misc.URLClassPath: sun.misc.URLClassPath$Loader getLoader(java.net.URL)>
<sun.misc.URLClassPath: void <init>(java.net.URL[],java.net.URLStreamHandlerFactory)>
<sun.misc.URLClassPath: void check(java.net.URL)>
<sun.misc.URLClassPath: void push(java.net.URL[])>
<sun.misc.Unsafe: int fieldOffset(java.lang.reflect.Field)>
<sun.misc.Unsafe: sun.misc.Unsafe getUnsafe()>
<sun.misc.Unsafe: void putObject(java.lang.Object,int,java.lang.Object)>
<sun.misc.VM: boolean allowArraySyntax()>
<sun.misc.VM: void addFinalRefCount(int)>
<sun.net.DefaultProgressMeteringPolicy: boolean shouldMeterInput(java.net.URL,java.lang.String)>
<sun.net.DefaultProgressMeteringPolicy: void <init>()>
<sun.net.InetAddressCachePolicy$1: java.lang.Object run()>
<sun.net.InetAddressCachePolicy$1: void <init>()>
<sun.net.InetAddressCachePolicy$2: java.lang.Object run()>
<sun.net.InetAddressCachePolicy$2: void <init>()>
<sun.net.InetAddressCachePolicy: int get()>
<sun.net.InetAddressCachePolicy: void <clinit>()>
<sun.net.ProgressMonitor: boolean shouldMeterInput(java.net.URL,java.lang.String)>
<sun.net.ProgressMonitor: sun.net.ProgressMonitor getDefault()>
<sun.net.ProgressMonitor: void <clinit>()>
<sun.net.ProgressMonitor: void <init>()>
<sun.net.util.URLUtil: java.lang.String urlNoFragString(java.net.URL)>
<sun.net.www.MessageHeader: void <init>()>
<sun.net.www.MessageHeader: void grow()>
<sun.net.www.ParseUtil: java.lang.String canonizeString(java.lang.String)>
<sun.net.www.ParseUtil: java.lang.String decode(java.lang.String)>
<sun.net.www.ParseUtil: java.lang.String encodePath(java.lang.String)>
<sun.net.www.ParseUtil: java.lang.String encodePath(java.lang.String,boolean)>
<sun.net.www.ParseUtil: java.net.URL fileToEncodedURL(java.io.File)>
<sun.net.www.ParseUtil: void <init>()>
<sun.net.www.URLConnection: void <clinit>()>
<sun.net.www.URLConnection: void <init>(java.net.URL)>
<sun.net.www.protocol.file.FileURLConnection: java.io.InputStream getInputStream()>
<sun.net.www.protocol.file.FileURLConnection: java.security.Permission getPermission()>
<sun.net.www.protocol.file.FileURLConnection: void <clinit>()>
<sun.net.www.protocol.file.FileURLConnection: void <init>(java.net.URL,java.io.File)>
<sun.net.www.protocol.file.FileURLConnection: void connect()>
<sun.net.www.protocol.file.Handler: boolean hostsEqual(java.net.URL,java.net.URL)>
<sun.net.www.protocol.file.Handler: java.net.URLConnection createFileURLConnection(java.net.URL,java.io.File)>
<sun.net.www.protocol.file.Handler: java.net.URLConnection openConnection(java.net.URL)>
<sun.net.www.protocol.file.Handler: java.net.URLConnection openConnection(java.net.URL,java.net.Proxy)>
<sun.net.www.protocol.file.Handler: void <init>()>
<sun.net.www.protocol.file.Handler: void parseURL(java.net.URL,java.lang.String,int,int)>
<sun.net.www.protocol.jar.Handler: int indexOfBangSlash(java.lang.String)>
<sun.net.www.protocol.jar.Handler: java.lang.String parseContextSpec(java.net.URL,java.lang.String)>
<sun.net.www.protocol.jar.Handler: java.net.URLConnection openConnection(java.net.URL)>
<sun.net.www.protocol.jar.Handler: void <init>()>
<sun.net.www.protocol.jar.Handler: void parseURL(java.net.URL,java.lang.String,int,int)>
<sun.net.www.protocol.jar.JarFileFactory: java.net.URLConnection getConnection(java.util.jar.JarFile)>
<sun.net.www.protocol.jar.JarFileFactory: java.security.Permission getPermission(java.util.jar.JarFile)>
<sun.net.www.protocol.jar.JarFileFactory: java.util.jar.JarFile get(java.net.URL,boolean)>
<sun.net.www.protocol.jar.JarFileFactory: java.util.jar.JarFile getCachedJarFile(java.net.URL)>
<sun.net.www.protocol.jar.JarFileFactory: void <clinit>()>
<sun.net.www.protocol.jar.JarFileFactory: void <init>()>
<sun.net.www.protocol.jar.JarURLConnection$JarURLInputStream: void <init>(sun.net.www.protocol.jar.JarURLConnection,java.io.InputStream)>
<sun.net.www.protocol.jar.JarURLConnection$JarURLInputStream: void close()>
<sun.net.www.protocol.jar.JarURLConnection: boolean getUseCaches()>
<sun.net.www.protocol.jar.JarURLConnection: java.io.InputStream getInputStream()>
<sun.net.www.protocol.jar.JarURLConnection: void <clinit>()>
<sun.net.www.protocol.jar.JarURLConnection: void <init>(java.net.URL,sun.net.www.protocol.jar.Handler)>
<sun.net.www.protocol.jar.JarURLConnection: void connect()>
<sun.net.www.protocol.jar.URLJarFile$URLJarFileEntry: void <init>(sun.net.www.protocol.jar.URLJarFile,java.util.jar.JarEntry)>
<sun.net.www.protocol.jar.URLJarFile: boolean isFileURL(java.net.URL)>
<sun.net.www.protocol.jar.URLJarFile: java.util.jar.JarFile getJarFile(java.net.URL,sun.net.www.protocol.jar.URLJarFile$URLJarFileCloseController)>
<sun.net.www.protocol.jar.URLJarFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
<sun.net.www.protocol.jar.URLJarFile: void <clinit>()>
<sun.net.www.protocol.jar.URLJarFile: void <init>(java.net.URL,sun.net.www.protocol.jar.URLJarFile$URLJarFileCloseController)>
<sun.nio.ch.FileChannelImpl$1: void <init>(sun.nio.ch.FileChannelImpl)>
<sun.nio.ch.FileChannelImpl$FileLockReference: void <init>(java.nio.channels.FileLock,java.lang.ref.ReferenceQueue,sun.nio.ch.FileKey)>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void <clinit>()>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void <init>(sun.nio.ch.FileChannelImpl)>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void add(java.nio.channels.FileLock)>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void remove(java.nio.channels.FileLock)>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void removeAll(sun.nio.ch.FileChannelImpl$FileLockTable$Releaser)>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void removeKeyIfEmpty(sun.nio.ch.FileKey,java.util.ArrayList)>
<sun.nio.ch.FileChannelImpl$SharedFileLockTable: void removeStaleEntries()>
<sun.nio.ch.FileChannelImpl: boolean isSharedFileLockTable()>
<sun.nio.ch.FileChannelImpl: java.io.FileDescriptor access$000(sun.nio.ch.FileChannelImpl)>
<sun.nio.ch.FileChannelImpl: java.nio.channels.FileChannel open(java.io.FileDescriptor,boolean,boolean,java.lang.Object)>
<sun.nio.ch.FileChannelImpl: java.nio.channels.FileChannel open(java.io.FileDescriptor,boolean,boolean,java.lang.Object,boolean)>
<sun.nio.ch.FileChannelImpl: java.nio.channels.FileLock lock(long,long,boolean)>
<sun.nio.ch.FileChannelImpl: java.nio.channels.FileLock tryLock(long,long,boolean)>
<sun.nio.ch.FileChannelImpl: sun.nio.ch.FileChannelImpl$FileLockTable fileLockTable()>
<sun.nio.ch.FileChannelImpl: void <clinit>()>
<sun.nio.ch.FileChannelImpl: void <init>(java.io.FileDescriptor,boolean,boolean,java.lang.Object,boolean)>
<sun.nio.ch.FileChannelImpl: void ensureOpen()>
<sun.nio.ch.FileChannelImpl: void implCloseChannel()>
<sun.nio.ch.FileChannelImpl: void release(sun.nio.ch.FileLockImpl)>
<sun.nio.ch.FileDispatcher: void <clinit>()>
<sun.nio.ch.FileDispatcher: void <init>()>
<sun.nio.ch.FileDispatcher: void preClose(java.io.FileDescriptor)>
<sun.nio.ch.FileKey: boolean equals(java.lang.Object)>
<sun.nio.ch.FileKey: int hashCode()>
<sun.nio.ch.FileKey: sun.nio.ch.FileKey create(java.io.FileDescriptor)>
<sun.nio.ch.FileKey: void <clinit>()>
<sun.nio.ch.FileKey: void <init>()>
<sun.nio.ch.FileLockImpl: void <init>(java.nio.channels.FileChannel,long,long,boolean)>
<sun.nio.ch.FileLockImpl: void release()>
<sun.nio.ch.IOUtil: void <clinit>()>
<sun.nio.ch.NativeDispatcher: void <init>()>
<sun.nio.ch.NativeThread: void <clinit>()>
<sun.nio.ch.NativeThreadSet: int add()>
<sun.nio.ch.NativeThreadSet: void <clinit>()>
<sun.nio.ch.NativeThreadSet: void <init>(int)>
<sun.nio.ch.NativeThreadSet: void remove(int)>
<sun.nio.ch.NativeThreadSet: void signal()>
<sun.nio.ch.Util$1: void <init>()>
<sun.nio.ch.Util: void <clinit>()>
<sun.nio.ch.Util: void load()>
<sun.nio.cs.FastCharsetProvider: java.lang.String canonicalize(java.lang.String)>
<sun.nio.cs.FastCharsetProvider: java.lang.String toLower(java.lang.String)>
<sun.nio.cs.FastCharsetProvider: java.nio.charset.Charset charsetForName(java.lang.String)>
<sun.nio.cs.FastCharsetProvider: java.nio.charset.Charset lookup(java.lang.String)>
<sun.nio.cs.ISO_8859_1$Decoder: java.nio.charset.CoderResult decodeArrayLoop(java.nio.ByteBuffer,java.nio.CharBuffer)>
<sun.nio.cs.ISO_8859_1$Decoder: java.nio.charset.CoderResult decodeLoop(java.nio.ByteBuffer,java.nio.CharBuffer)>
<sun.nio.cs.ISO_8859_1$Decoder: void <clinit>()>
<sun.nio.cs.ISO_8859_1$Decoder: void <init>(java.nio.charset.Charset)>
<sun.nio.cs.ISO_8859_1$Decoder: void <init>(java.nio.charset.Charset,sun.nio.cs.ISO_8859_1$1)>
<sun.nio.cs.ISO_8859_1$Encoder: java.nio.charset.CoderResult encodeArrayLoop(java.nio.CharBuffer,java.nio.ByteBuffer)>
<sun.nio.cs.ISO_8859_1$Encoder: java.nio.charset.CoderResult encodeLoop(java.nio.CharBuffer,java.nio.ByteBuffer)>
<sun.nio.cs.ISO_8859_1$Encoder: void <clinit>()>
<sun.nio.cs.ISO_8859_1$Encoder: void <init>(java.nio.charset.Charset)>
<sun.nio.cs.ISO_8859_1$Encoder: void <init>(java.nio.charset.Charset,sun.nio.cs.ISO_8859_1$1)>
<sun.nio.cs.ISO_8859_1: java.nio.charset.CharsetDecoder newDecoder()>
<sun.nio.cs.ISO_8859_1: java.nio.charset.CharsetEncoder newEncoder()>
<sun.nio.cs.ISO_8859_1: void <init>()>
<sun.nio.cs.StreamDecoder: boolean inReady()>
<sun.nio.cs.StreamDecoder: int implRead(char[],int,int)>
<sun.nio.cs.StreamDecoder: int read(char[],int,int)>
<sun.nio.cs.StreamDecoder: int readBytes()>
<sun.nio.cs.StreamDecoder: sun.nio.cs.StreamDecoder forInputStreamReader(java.io.InputStream,java.lang.Object,java.lang.String)>
<sun.nio.cs.StreamDecoder: void <init>(java.io.InputStream,java.lang.Object,java.nio.charset.Charset)>
<sun.nio.cs.StreamDecoder: void <init>(java.io.InputStream,java.lang.Object,java.nio.charset.CharsetDecoder)>
<sun.nio.cs.StreamDecoder: void close()>
<sun.nio.cs.StreamDecoder: void ensureOpen()>
<sun.nio.cs.StreamDecoder: void implClose()>
<sun.nio.cs.StreamEncoder: boolean isOpen()>
<sun.nio.cs.StreamEncoder: sun.nio.cs.StreamEncoder forOutputStreamWriter(java.io.OutputStream,java.lang.Object,java.lang.String)>
<sun.nio.cs.StreamEncoder: void <init>(java.io.OutputStream,java.lang.Object,java.nio.charset.Charset)>
<sun.nio.cs.StreamEncoder: void <init>(java.io.OutputStream,java.lang.Object,java.nio.charset.CharsetEncoder)>
<sun.nio.cs.StreamEncoder: void close()>
<sun.nio.cs.StreamEncoder: void ensureOpen()>
<sun.nio.cs.StreamEncoder: void flush()>
<sun.nio.cs.StreamEncoder: void flushBuffer()>
<sun.nio.cs.StreamEncoder: void flushLeftoverChar(java.nio.CharBuffer,boolean)>
<sun.nio.cs.StreamEncoder: void implClose()>
<sun.nio.cs.StreamEncoder: void implFlush()>
<sun.nio.cs.StreamEncoder: void implFlushBuffer()>
<sun.nio.cs.StreamEncoder: void implWrite(char[],int,int)>
<sun.nio.cs.StreamEncoder: void write(char[],int,int)>
<sun.nio.cs.StreamEncoder: void writeBytes()>
<sun.nio.cs.Surrogate$Parser: void <clinit>()>
<sun.nio.cs.Surrogate$Parser: void <init>()>
<sun.nio.cs.UTF_8$Decoder: java.nio.charset.CoderResult decodeArrayLoop(java.nio.ByteBuffer,java.nio.CharBuffer)>
<sun.nio.cs.UTF_8$Decoder: java.nio.charset.CoderResult decodeLoop(java.nio.ByteBuffer,java.nio.CharBuffer)>
<sun.nio.cs.UTF_8$Decoder: java.nio.charset.CoderResult xflow(java.nio.Buffer,int,int,java.nio.Buffer,int,int)>
<sun.nio.cs.UTF_8$Decoder: void <init>(java.nio.charset.Charset)>
<sun.nio.cs.UTF_8$Decoder: void <init>(java.nio.charset.Charset,sun.nio.cs.UTF_8$1)>
<sun.nio.cs.UTF_8$Encoder: boolean isLegalReplacement(byte[])>
<sun.nio.cs.UTF_8$Encoder: java.nio.charset.CoderResult encodeArrayLoop(java.nio.CharBuffer,java.nio.ByteBuffer)>
<sun.nio.cs.UTF_8$Encoder: java.nio.charset.CoderResult encodeLoop(java.nio.CharBuffer,java.nio.ByteBuffer)>
<sun.nio.cs.UTF_8$Encoder: void <init>(java.nio.charset.Charset)>
<sun.nio.cs.UTF_8$Encoder: void <init>(java.nio.charset.Charset,sun.nio.cs.UTF_8$1)>
<sun.nio.cs.UTF_8: java.lang.String historicalName()>
<sun.nio.cs.UTF_8: java.nio.charset.CharsetDecoder newDecoder()>
<sun.nio.cs.UTF_8: java.nio.charset.CharsetEncoder newEncoder()>
<sun.nio.cs.UTF_8: void updatePositions(java.nio.Buffer,int,java.nio.Buffer,int)>
<sun.reflect.AccessorGenerator: java.lang.String getClassName(java.lang.Class,boolean)>
<sun.reflect.AccessorGenerator: java.lang.String internalize(java.lang.String)>
<sun.reflect.AccessorGenerator: short add(short,short)>
<sun.reflect.AccessorGenerator: short sub(short,short)>
<sun.reflect.AccessorGenerator: void <clinit>()>
<sun.reflect.AccessorGenerator: void <init>()>
<sun.reflect.AccessorGenerator: void emitBoxingContantPoolEntries()>
<sun.reflect.AccessorGenerator: void emitCommonConstantPoolEntries()>
<sun.reflect.AccessorGenerator: void emitConstructor()>
<sun.reflect.AccessorGenerator: void emitMethod(short,int,sun.reflect.ClassFileAssembler,sun.reflect.ClassFileAssembler,short[])>
<sun.reflect.BootstrapConstructorAccessorImpl: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.BootstrapConstructorAccessorImpl: void <init>(java.lang.reflect.Constructor)>
<sun.reflect.ByteVectorFactory: sun.reflect.ByteVector create()>
<sun.reflect.ByteVectorImpl: byte get(int)>
<sun.reflect.ByteVectorImpl: byte[] getData()>
<sun.reflect.ByteVectorImpl: int getLength()>
<sun.reflect.ByteVectorImpl: void <init>()>
<sun.reflect.ByteVectorImpl: void <init>(int)>
<sun.reflect.ByteVectorImpl: void add(byte)>
<sun.reflect.ByteVectorImpl: void put(int,byte)>
<sun.reflect.ByteVectorImpl: void resize(int)>
<sun.reflect.ByteVectorImpl: void trim()>
<sun.reflect.ClassDefiner$1: java.lang.Object run()>
<sun.reflect.ClassDefiner$1: void <init>(java.lang.ClassLoader)>
<sun.reflect.ClassDefiner: java.lang.Class defineClass(java.lang.String,byte[],int,int,java.lang.ClassLoader)>
<sun.reflect.ClassDefiner: void <clinit>()>
<sun.reflect.ClassFileAssembler: int getStack()>
<sun.reflect.ClassFileAssembler: short cpi()>
<sun.reflect.ClassFileAssembler: short getLength()>
<sun.reflect.ClassFileAssembler: short getMaxLocals()>
<sun.reflect.ClassFileAssembler: short getMaxStack()>
<sun.reflect.ClassFileAssembler: void <init>()>
<sun.reflect.ClassFileAssembler: void <init>(sun.reflect.ByteVector)>
<sun.reflect.ClassFileAssembler: void append(sun.reflect.ByteVector)>
<sun.reflect.ClassFileAssembler: void append(sun.reflect.ClassFileAssembler)>
<sun.reflect.ClassFileAssembler: void decStack()>
<sun.reflect.ClassFileAssembler: void emitByte(byte)>
<sun.reflect.ClassFileAssembler: void emitConstantPoolClass(short)>
<sun.reflect.ClassFileAssembler: void emitConstantPoolMethodref(short,short)>
<sun.reflect.ClassFileAssembler: void emitConstantPoolNameAndType(short,short)>
<sun.reflect.ClassFileAssembler: void emitConstantPoolUTF8(java.lang.String)>
<sun.reflect.ClassFileAssembler: void emitInt(int)>
<sun.reflect.ClassFileAssembler: void emitMagicAndVersion()>
<sun.reflect.ClassFileAssembler: void emitShort(short)>
<sun.reflect.ClassFileAssembler: void emitShort(short,short)>
<sun.reflect.ClassFileAssembler: void incStack()>
<sun.reflect.ClassFileAssembler: void opc_aload_0()>
<sun.reflect.ClassFileAssembler: void opc_aload_1()>
<sun.reflect.ClassFileAssembler: void opc_areturn()>
<sun.reflect.ClassFileAssembler: void opc_arraylength()>
<sun.reflect.ClassFileAssembler: void opc_athrow()>
<sun.reflect.ClassFileAssembler: void opc_dup()>
<sun.reflect.ClassFileAssembler: void opc_dup_x1()>
<sun.reflect.ClassFileAssembler: void opc_if_icmpeq(sun.reflect.Label)>
<sun.reflect.ClassFileAssembler: void opc_ifnull(sun.reflect.Label)>
<sun.reflect.ClassFileAssembler: void opc_invokespecial(short,int,int)>
<sun.reflect.ClassFileAssembler: void opc_new(short)>
<sun.reflect.ClassFileAssembler: void opc_return()>
<sun.reflect.ClassFileAssembler: void opc_sipush(short)>
<sun.reflect.ClassFileAssembler: void opc_swap()>
<sun.reflect.ClassFileAssembler: void setMaxLocals(int)>
<sun.reflect.ClassFileAssembler: void setStack(int)>
<sun.reflect.ConstructorAccessorImpl: void <init>()>
<sun.reflect.DelegatingClassLoader: void <init>(java.lang.ClassLoader)>
<sun.reflect.DelegatingConstructorAccessorImpl: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.DelegatingConstructorAccessorImpl: void <init>(sun.reflect.ConstructorAccessorImpl)>
<sun.reflect.DelegatingConstructorAccessorImpl: void setDelegate(sun.reflect.ConstructorAccessorImpl)>
<sun.reflect.DelegatingMethodAccessorImpl: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>
<sun.reflect.DelegatingMethodAccessorImpl: void <init>(sun.reflect.MethodAccessorImpl)>
<sun.reflect.DelegatingMethodAccessorImpl: void setDelegate(sun.reflect.MethodAccessorImpl)>
<sun.reflect.FieldAccessorImpl: void <init>()>
<sun.reflect.GeneratedConstructorAccessor1: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.GeneratedConstructorAccessor2: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.GeneratedConstructorAccessor3: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.GeneratedConstructorAccessor4: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.Label$PatchInfo: void <init>(sun.reflect.ClassFileAssembler,short,short,int)>
<sun.reflect.Label: void <init>()>
<sun.reflect.Label: void add(sun.reflect.ClassFileAssembler,short,short,int)>
<sun.reflect.Label: void bind()>
<sun.reflect.MagicAccessorImpl: void <init>()>
<sun.reflect.MethodAccessorGenerator$1: java.lang.Object run()>
<sun.reflect.MethodAccessorGenerator$1: void <init>(sun.reflect.MethodAccessorGenerator,java.lang.String,byte[],java.lang.Class)>
<sun.reflect.MethodAccessorGenerator: boolean isInterface()>
<sun.reflect.MethodAccessorGenerator: boolean usesPrimitiveTypes()>
<sun.reflect.MethodAccessorGenerator: int numNonPrimitiveParameterTypes()>
<sun.reflect.MethodAccessorGenerator: java.lang.String buildInternalSignature()>
<sun.reflect.MethodAccessorGenerator: java.lang.String generateName(boolean,boolean)>
<sun.reflect.MethodAccessorGenerator: sun.reflect.ConstructorAccessor generateConstructor(java.lang.Class,java.lang.Class[],java.lang.Class[],int)>
<sun.reflect.MethodAccessorGenerator: sun.reflect.MagicAccessorImpl generate(java.lang.Class,java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class[],int,boolean,boolean,java.lang.Class)>
<sun.reflect.MethodAccessorGenerator: void <clinit>()>
<sun.reflect.MethodAccessorGenerator: void <init>()>
<sun.reflect.MethodAccessorGenerator: void emitInvoke()>
<sun.reflect.MethodAccessorImpl: void <init>()>
<sun.reflect.NativeConstructorAccessorImpl: java.lang.Object newInstance(java.lang.Object[])>
<sun.reflect.NativeConstructorAccessorImpl: void <init>(java.lang.reflect.Constructor)>
<sun.reflect.NativeConstructorAccessorImpl: void setParent(sun.reflect.DelegatingConstructorAccessorImpl)>
<sun.reflect.NativeMethodAccessorImpl: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>
<sun.reflect.NativeMethodAccessorImpl: void <init>(java.lang.reflect.Method)>
<sun.reflect.NativeMethodAccessorImpl: void setParent(sun.reflect.DelegatingMethodAccessorImpl)>
<sun.reflect.Reflection: boolean isSameClassPackage(java.lang.Class,java.lang.Class)>
<sun.reflect.Reflection: boolean isSameClassPackage(java.lang.ClassLoader,java.lang.String,java.lang.ClassLoader,java.lang.String)>
<sun.reflect.Reflection: boolean isSubclassOf(java.lang.Class,java.lang.Class)>
<sun.reflect.Reflection: boolean quickCheckMemberAccess(java.lang.Class,int)>
<sun.reflect.Reflection: boolean verifyMemberAccess(java.lang.Class,java.lang.Class,java.lang.Object,int)>
<sun.reflect.Reflection: java.lang.reflect.Field[] filterFields(java.lang.Class,java.lang.reflect.Field[])>
<sun.reflect.Reflection: void ensureMemberAccess(java.lang.Class,java.lang.Class,java.lang.Object,int)>
<sun.reflect.Reflection: void registerFieldsToFilter(java.lang.Class,java.lang.String[])>
<sun.reflect.ReflectionFactory: int inflationThreshold()>
<sun.reflect.ReflectionFactory: java.lang.reflect.Constructor copyConstructor(java.lang.reflect.Constructor)>
<sun.reflect.ReflectionFactory: java.lang.reflect.Field copyField(java.lang.reflect.Field)>
<sun.reflect.ReflectionFactory: java.lang.reflect.Method copyMethod(java.lang.reflect.Method)>
<sun.reflect.ReflectionFactory: sun.reflect.ConstructorAccessor newConstructorAccessor(java.lang.reflect.Constructor)>
<sun.reflect.ReflectionFactory: sun.reflect.FieldAccessor newFieldAccessor(java.lang.reflect.Field,boolean)>
<sun.reflect.ReflectionFactory: sun.reflect.LangReflectAccess langReflectAccess()>
<sun.reflect.ReflectionFactory: sun.reflect.MethodAccessor newMethodAccessor(java.lang.reflect.Method)>
<sun.reflect.ReflectionFactory: void checkInitted()>
<sun.reflect.UTF8: byte[] encode(java.lang.String)>
<sun.reflect.UTF8: int utf8Length(java.lang.String)>
<sun.reflect.UnsafeFieldAccessorFactory: sun.reflect.FieldAccessor newFieldAccessor(java.lang.reflect.Field,boolean)>
<sun.reflect.UnsafeFieldAccessorImpl: void <clinit>()>
<sun.reflect.UnsafeFieldAccessorImpl: void <init>(java.lang.reflect.Field)>
<sun.reflect.UnsafeQualifiedStaticFieldAccessorImpl: void <init>(java.lang.reflect.Field,boolean)>
<sun.reflect.UnsafeQualifiedStaticObjectFieldAccessorImpl: java.lang.Object get(java.lang.Object)>
<sun.reflect.UnsafeQualifiedStaticObjectFieldAccessorImpl: void <init>(java.lang.reflect.Field,boolean)>
<sun.reflect.UnsafeStaticFieldAccessorImpl: void <clinit>()>
<sun.reflect.UnsafeStaticFieldAccessorImpl: void <init>(java.lang.reflect.Field)>
<sun.reflect.UnsafeStaticObjectFieldAccessorImpl: void <init>(java.lang.reflect.Field)>
<sun.reflect.UnsafeStaticObjectFieldAccessorImpl: void set(java.lang.Object,java.lang.Object)>
<sun.security.action.GetBooleanAction: java.lang.Boolean run()>
<sun.security.action.GetBooleanAction: java.lang.Object run()>
<sun.security.action.GetBooleanAction: void <init>(java.lang.String)>
<sun.security.action.GetIntegerAction: java.lang.Integer run()>
<sun.security.action.GetIntegerAction: java.lang.Object run()>
<sun.security.action.GetIntegerAction: void <init>(java.lang.String)>
<sun.security.action.GetPropertyAction: java.lang.Object run()>
<sun.security.action.GetPropertyAction: java.lang.String run()>
<sun.security.action.GetPropertyAction: void <init>(java.lang.String)>
<sun.security.action.GetPropertyAction: void <init>(java.lang.String,java.lang.String)>
<sun.security.action.LoadLibraryAction: java.lang.Object run()>
<sun.security.action.LoadLibraryAction: void <init>(java.lang.String)>
<sun.security.jca.GetInstance$Instance: java.lang.Object[] toArray()>
<sun.security.jca.GetInstance$Instance: void <init>(java.security.Provider,java.lang.Object)>
<sun.security.jca.GetInstance$Instance: void <init>(java.security.Provider,java.lang.Object,sun.security.jca.GetInstance$1)>
<sun.security.jca.GetInstance: sun.security.jca.GetInstance$Instance getInstance(java.lang.String,java.lang.Class,java.lang.String)>
<sun.security.jca.GetInstance: sun.security.jca.GetInstance$Instance getInstance(java.security.Provider$Service,java.lang.Class)>
<sun.security.jca.GetInstance: void checkSuperClass(java.security.Provider$Service,java.lang.Class,java.lang.Class)>
<sun.security.jca.ProviderConfig$1: java.lang.Object run()>
<sun.security.jca.ProviderConfig$1: void <init>()>
<sun.security.jca.ProviderConfig$3: java.lang.Object run()>
<sun.security.jca.ProviderConfig$3: void <init>(sun.security.jca.ProviderConfig)>
<sun.security.jca.ProviderConfig: boolean access$200(sun.security.jca.ProviderConfig)>
<sun.security.jca.ProviderConfig: boolean equals(java.lang.Object)>
<sun.security.jca.ProviderConfig: boolean hasArgument()>
<sun.security.jca.ProviderConfig: boolean shouldLoad()>
<sun.security.jca.ProviderConfig: java.lang.Object getLock()>
<sun.security.jca.ProviderConfig: java.lang.String access$100(sun.security.jca.ProviderConfig)>
<sun.security.jca.ProviderConfig: java.lang.String expand(java.lang.String)>
<sun.security.jca.ProviderConfig: java.security.Provider doLoadProvider()>
<sun.security.jca.ProviderConfig: java.security.Provider getProvider()>
<sun.security.jca.ProviderConfig: sun.security.util.Debug access$000()>
<sun.security.jca.ProviderConfig: void <clinit>()>
<sun.security.jca.ProviderConfig: void <init>(java.lang.String)>
<sun.security.jca.ProviderConfig: void <init>(java.lang.String,java.lang.String)>
<sun.security.jca.ProviderList$1: void <init>(java.lang.String,double,java.lang.String)>
<sun.security.jca.ProviderList$2: java.lang.Object run()>
<sun.security.jca.ProviderList$2: void <init>()>
<sun.security.jca.ProviderList$3: int size()>
<sun.security.jca.ProviderList$3: java.lang.Object get(int)>
<sun.security.jca.ProviderList$3: java.security.Provider get(int)>
<sun.security.jca.ProviderList$3: void <init>(sun.security.jca.ProviderList)>
<sun.security.jca.ProviderList: java.security.Provider getProvider(int)>
<sun.security.jca.ProviderList: java.security.Provider$Service getService(java.lang.String,java.lang.String)>
<sun.security.jca.ProviderList: java.util.List providers()>
<sun.security.jca.ProviderList: sun.security.jca.ProviderConfig[] access$100(sun.security.jca.ProviderList)>
<sun.security.jca.ProviderList: sun.security.jca.ProviderList fromSecurityProperties()>
<sun.security.jca.ProviderList: void <clinit>()>
<sun.security.jca.ProviderList: void <init>()>
<sun.security.jca.ProviderList: void <init>(sun.security.jca.ProviderConfig[],boolean)>
<sun.security.jca.ProviderList: void <init>(sun.security.jca.ProviderList$1)>
<sun.security.jca.Providers: sun.security.jca.ProviderList getProviderList()>
<sun.security.jca.Providers: sun.security.jca.ProviderList getSystemProviderList()>
<sun.security.jca.Providers: sun.security.jca.ProviderList getThreadProviderList()>
<sun.security.jca.Providers: void <clinit>()>
<sun.security.provider.ByteArrayAccess: boolean unaligned()>
<sun.security.provider.ByteArrayAccess: void <clinit>()>
<sun.security.provider.ByteArrayAccess: void b2iBig64(byte[],int,int[])>
<sun.security.provider.ByteArrayAccess: void i2bBig(int[],int,byte[],int,int)>
<sun.security.provider.ByteArrayAccess: void i2bBig4(int,byte[],int)>
<sun.security.provider.DigestBase: byte[] engineDigest()>
<sun.security.provider.DigestBase: int engineDigest(byte[],int,int)>
<sun.security.provider.DigestBase: void <clinit>()>
<sun.security.provider.DigestBase: void <init>(java.lang.String,int,int)>
<sun.security.provider.DigestBase: void engineReset()>
<sun.security.provider.DigestBase: void engineUpdate(byte)>
<sun.security.provider.DigestBase: void engineUpdate(byte[],int,int)>
<sun.security.provider.NativePRNG$1: java.lang.Object run()>
<sun.security.provider.NativePRNG$1: void <init>()>
<sun.security.provider.NativePRNG$RandomIO: void <init>(java.io.File,java.io.File)>
<sun.security.provider.NativePRNG$RandomIO: void <init>(java.io.File,java.io.File,sun.security.provider.NativePRNG$1)>
<sun.security.provider.NativePRNG: boolean isAvailable()>
<sun.security.provider.NativePRNG: sun.security.provider.NativePRNG$RandomIO initIO()>
<sun.security.provider.NativePRNG: void <clinit>()>
<sun.security.provider.PolicyFile: java.lang.String canonPath(java.lang.String)>
<sun.security.provider.PolicyFile: void <clinit>()>
<sun.security.provider.SHA: void <init>()>
<sun.security.provider.SHA: void implCompress(byte[],int)>
<sun.security.provider.SHA: void implDigest(byte[],int)>
<sun.security.provider.SHA: void implReset()>
<sun.security.provider.SecureRandom$SeederHolder: sun.security.provider.SecureRandom access$100()>
<sun.security.provider.SecureRandom$SeederHolder: void <clinit>()>
<sun.security.provider.SecureRandom: void <init>()>
<sun.security.provider.SecureRandom: void <init>(byte[])>
<sun.security.provider.SecureRandom: void <init>(byte[],sun.security.provider.SecureRandom$1)>
<sun.security.provider.SecureRandom: void engineNextBytes(byte[])>
<sun.security.provider.SecureRandom: void engineSetSeed(byte[])>
<sun.security.provider.SecureRandom: void init(byte[])>
<sun.security.provider.SecureRandom: void updateState(byte[],byte[])>
<sun.security.provider.SeedGenerator$1: java.lang.Object run()>
<sun.security.provider.SeedGenerator$1: void <init>(java.security.MessageDigest)>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator$1: java.lang.Object run()>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator$1: void <init>(sun.security.provider.SeedGenerator$ThreadedSeedGenerator,java.lang.ThreadGroup[])>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator$BogusThread: void <init>()>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator$BogusThread: void <init>(sun.security.provider.SeedGenerator$1)>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator$BogusThread: void run()>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator: byte getSeedByte()>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator: void <clinit>()>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator: void <init>()>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator: void getSeedBytes(byte[])>
<sun.security.provider.SeedGenerator$ThreadedSeedGenerator: void run()>
<sun.security.provider.SeedGenerator: byte[] access$000(long)>
<sun.security.provider.SeedGenerator: byte[] getSystemEntropy()>
<sun.security.provider.SeedGenerator: byte[] longToByteArray(long)>
<sun.security.provider.SeedGenerator: void <clinit>()>
<sun.security.provider.SeedGenerator: void <init>()>
<sun.security.provider.SeedGenerator: void generateSeed(byte[])>
<sun.security.provider.Sun$1: java.lang.Object run()>
<sun.security.provider.Sun$1: void <init>()>
<sun.security.provider.Sun: java.lang.String getSeedSource()>
<sun.security.provider.Sun: void <clinit>()>
<sun.security.provider.Sun: void <init>()>
<sun.security.util.Debug: boolean isOn(java.lang.String)>
<sun.security.util.Debug: sun.security.util.Debug getInstance(java.lang.String)>
<sun.security.util.Debug: sun.security.util.Debug getInstance(java.lang.String,java.lang.String)>
<sun.text.resources.FormatData: java.lang.Object[][] getContents()>
<sun.text.resources.FormatData: void <init>()>
<sun.text.resources.FormatData_en: java.lang.Object[][] getContents()>
<sun.text.resources.FormatData_en: void <init>()>
<sun.text.resources.FormatData_en_US: java.lang.Object[][] getContents()>
<sun.text.resources.FormatData_en_US: void <init>()>
<sun.util.LocaleDataMetaInfo: java.lang.String getSupportedLocaleString(java.lang.String)>
<sun.util.LocaleDataMetaInfo: void <clinit>()>
<sun.util.LocaleServiceProviderPool$1: java.lang.Object run()>
<sun.util.LocaleServiceProviderPool$1: void <init>(sun.util.LocaleServiceProviderPool,java.lang.Class)>
<sun.util.LocaleServiceProviderPool: boolean hasProviders()>
<sun.util.LocaleServiceProviderPool: sun.util.LocaleServiceProviderPool getPool(java.lang.Class)>
<sun.util.LocaleServiceProviderPool: void <clinit>()>
<sun.util.LocaleServiceProviderPool: void <init>(java.lang.Class)>
<sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
<sun.util.PreHashedMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
<sun.util.PreHashedMap: java.lang.Object put(java.lang.String,java.lang.Object)>
<sun.util.PreHashedMap: java.lang.Object toV(java.lang.Object)>
<sun.util.ResourceBundleEnumeration: boolean hasMoreElements()>
<sun.util.ResourceBundleEnumeration: java.lang.Object nextElement()>
<sun.util.ResourceBundleEnumeration: java.lang.String nextElement()>
<sun.util.ResourceBundleEnumeration: void <init>(java.util.Set,java.util.Enumeration)>
<sun.util.TimeZoneNameUtility: java.lang.String[] retrieveDisplayNames(java.lang.String,java.util.Locale)>
<sun.util.TimeZoneNameUtility: java.lang.String[] retrieveDisplayNames(sun.util.resources.OpenListResourceBundle,java.lang.String,java.util.Locale)>
<sun.util.TimeZoneNameUtility: sun.util.resources.OpenListResourceBundle getBundle(java.util.Locale)>
<sun.util.TimeZoneNameUtility: void <clinit>()>
<sun.util.calendar.AbstractCalendar: long getDayOfWeekDateOnOrBefore(long,int)>
<sun.util.calendar.AbstractCalendar: sun.util.calendar.CalendarDate getCalendarDate(long,sun.util.calendar.CalendarDate)>
<sun.util.calendar.AbstractCalendar: sun.util.calendar.CalendarDate setTimeOfDay(sun.util.calendar.CalendarDate,int)>
<sun.util.calendar.AbstractCalendar: void <init>()>
<sun.util.calendar.BaseCalendar$Date: boolean hit(int)>
<sun.util.calendar.BaseCalendar$Date: boolean hit(long)>
<sun.util.calendar.BaseCalendar$Date: long getCachedJan1()>
<sun.util.calendar.BaseCalendar$Date: void <init>(java.util.TimeZone)>
<sun.util.calendar.BaseCalendar$Date: void setCache(int,long,int)>
<sun.util.calendar.BaseCalendar: boolean isLeapYear(int)>
<sun.util.calendar.BaseCalendar: boolean isLeapYear(sun.util.calendar.CalendarDate)>
<sun.util.calendar.BaseCalendar: int getDayOfWeekFromFixedDate(long)>
<sun.util.calendar.BaseCalendar: int getGregorianYearFromFixedDate(long)>
<sun.util.calendar.BaseCalendar: long getFixedDate(int,int,int,sun.util.calendar.BaseCalendar$Date)>
<sun.util.calendar.BaseCalendar: void <clinit>()>
<sun.util.calendar.BaseCalendar: void <init>()>
<sun.util.calendar.BaseCalendar: void getCalendarDateFromFixedDate(sun.util.calendar.CalendarDate,long)>
<sun.util.calendar.CalendarDate: boolean isDaylightTime()>
<sun.util.calendar.CalendarDate: boolean isNormalized()>
<sun.util.calendar.CalendarDate: boolean isStandardTime()>
<sun.util.calendar.CalendarDate: int getDayOfMonth()>
<sun.util.calendar.CalendarDate: int getDayOfWeek()>
<sun.util.calendar.CalendarDate: int getHours()>
<sun.util.calendar.CalendarDate: int getMinutes()>
<sun.util.calendar.CalendarDate: int getMonth()>
<sun.util.calendar.CalendarDate: int getSeconds()>
<sun.util.calendar.CalendarDate: int getYear()>
<sun.util.calendar.CalendarDate: java.util.TimeZone getZone()>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setDayOfMonth(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setHours(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setMillis(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setMinutes(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setMonth(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setSeconds(int)>
<sun.util.calendar.CalendarDate: sun.util.calendar.CalendarDate setYear(int)>
<sun.util.calendar.CalendarDate: void <init>(java.util.TimeZone)>
<sun.util.calendar.CalendarDate: void setDayOfWeek(int)>
<sun.util.calendar.CalendarDate: void setDaylightSaving(int)>
<sun.util.calendar.CalendarDate: void setLeapYear(boolean)>
<sun.util.calendar.CalendarDate: void setNormalized(boolean)>
<sun.util.calendar.CalendarDate: void setTimeOfDay(long)>
<sun.util.calendar.CalendarDate: void setZoneOffset(int)>
<sun.util.calendar.CalendarSystem: sun.util.calendar.Gregorian getGregorianCalendar()>
<sun.util.calendar.CalendarSystem: void <clinit>()>
<sun.util.calendar.CalendarSystem: void <init>()>
<sun.util.calendar.CalendarUtils: boolean isGregorianLeapYear(int)>
<sun.util.calendar.CalendarUtils: java.lang.StringBuilder sprintf0d(java.lang.StringBuilder,int,int)>
<sun.util.calendar.Gregorian$Date: int getNormalizedYear()>
<sun.util.calendar.Gregorian$Date: void <init>(java.util.TimeZone)>
<sun.util.calendar.Gregorian$Date: void setNormalizedYear(int)>
<sun.util.calendar.Gregorian: sun.util.calendar.CalendarDate getCalendarDate(long,java.util.TimeZone)>
<sun.util.calendar.Gregorian: sun.util.calendar.Gregorian$Date getCalendarDate(long,java.util.TimeZone)>
<sun.util.calendar.Gregorian: sun.util.calendar.Gregorian$Date getCalendarDate(long,sun.util.calendar.CalendarDate)>
<sun.util.calendar.Gregorian: sun.util.calendar.Gregorian$Date newCalendarDate(java.util.TimeZone)>
<sun.util.calendar.Gregorian: void <init>()>
<sun.util.calendar.ZoneInfo: boolean isDirty()>
<sun.util.calendar.ZoneInfo: int getLastRawOffset()>
<sun.util.calendar.ZoneInfo: int getOffsets(long,int[])>
<sun.util.calendar.ZoneInfo: int getOffsets(long,int[],int)>
<sun.util.calendar.ZoneInfo: int getOffsetsByWall(long,int[])>
<sun.util.calendar.ZoneInfo: java.lang.Object clone()>
<sun.util.calendar.ZoneInfo: java.util.Map getAliasTable()>
<sun.util.calendar.ZoneInfo: java.util.Map getCachedAliasTable()>
<sun.util.calendar.ZoneInfo: java.util.TimeZone getTimeZone(java.lang.String)>
<sun.util.calendar.ZoneInfo: void <clinit>()>
<sun.util.calendar.ZoneInfo: void <init>(java.lang.String,int)>
<sun.util.calendar.ZoneInfo: void <init>(java.lang.String,int,int,int,long[],int[],int[],boolean)>
<sun.util.calendar.ZoneInfoFile$1: java.lang.Object run()>
<sun.util.calendar.ZoneInfoFile$1: void <init>()>
<sun.util.calendar.ZoneInfoFile$2: byte[] run()>
<sun.util.calendar.ZoneInfoFile$2: java.lang.Object run()>
<sun.util.calendar.ZoneInfoFile$2: void <init>(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: byte[] getZoneInfoMappings()>
<sun.util.calendar.ZoneInfoFile: byte[] readZoneInfoFile(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: java.lang.String access$000()>
<sun.util.calendar.ZoneInfoFile: java.lang.String getFileName(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: java.lang.String toCustomID(int)>
<sun.util.calendar.ZoneInfoFile: java.util.Map getZoneAliases()>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo addToCache(java.lang.String,sun.util.calendar.ZoneInfo)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo createZoneInfo(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo getCustomTimeZone(java.lang.String,int)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo getFromCache(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: sun.util.calendar.ZoneInfo getZoneInfo(java.lang.String)>
<sun.util.calendar.ZoneInfoFile: void <clinit>()>
<sun.util.resources.CalendarData: java.lang.Object[][] getContents()>
<sun.util.resources.CalendarData: void <init>()>
<sun.util.resources.CalendarData_en: java.lang.Object[][] getContents()>
<sun.util.resources.CalendarData_en: void <init>()>
<sun.util.resources.CurrencyNames: void <init>()>
<sun.util.resources.CurrencyNames_en_US: java.lang.Object[][] getContents()>
<sun.util.resources.CurrencyNames_en_US: void <init>()>
<sun.util.resources.LocaleData$1: java.lang.Object run()>
<sun.util.resources.LocaleData$1: void <init>(java.lang.String,java.util.Locale)>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: java.util.List getCandidateLocales(java.lang.String,java.util.Locale)>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: sun.util.resources.LocaleData$LocaleDataResourceBundleControl getRBControlInstance()>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: void <clinit>()>
<sun.util.resources.LocaleData$LocaleDataResourceBundleControl: void <init>()>
<sun.util.resources.LocaleData: java.util.ResourceBundle getBundle(java.lang.String,java.util.Locale)>
<sun.util.resources.LocaleData: java.util.ResourceBundle getCalendarData(java.util.Locale)>
<sun.util.resources.LocaleData: java.util.ResourceBundle getCurrencyNames(java.util.Locale)>
<sun.util.resources.LocaleData: java.util.ResourceBundle getDateFormatData(java.util.Locale)>
<sun.util.resources.LocaleData: java.util.ResourceBundle getNumberFormatData(java.util.Locale)>
<sun.util.resources.LocaleData: sun.util.resources.OpenListResourceBundle getTimeZoneNames(java.util.Locale)>
<sun.util.resources.LocaleNamesBundle: void <init>()>
<sun.util.resources.OpenListResourceBundle: java.lang.Object handleGetObject(java.lang.String)>
<sun.util.resources.OpenListResourceBundle: java.util.Map createMap(int)>
<sun.util.resources.OpenListResourceBundle: void <init>()>
<sun.util.resources.OpenListResourceBundle: void loadLookup()>
<sun.util.resources.OpenListResourceBundle: void loadLookupTablesIfNecessary()>
<sun.util.resources.TimeZoneNames: java.lang.Object[][] getContents()>
<sun.util.resources.TimeZoneNames: void <init>()>
<sun.util.resources.TimeZoneNamesBundle: java.lang.Object handleGetObject(java.lang.String)>
<sun.util.resources.TimeZoneNamesBundle: java.util.Map createMap(int)>
<sun.util.resources.TimeZoneNamesBundle: void <init>()>
<sun.util.resources.TimeZoneNames_en: java.lang.Object[][] getContents()>
<sun.util.resources.TimeZoneNames_en: void <init>()>
